{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.f6a68c.css","path":"main.f6a68c.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.40e320.js","path":"mobile.40e320.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.f6a68c.js","path":"main.f6a68c.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"9a8e0e96695b197912d701e5369fa130e3be6326","modified":1492218610000},{"_id":"source/_posts/Jackblog-Express.md","hash":"3c3ca5a9d575d2fc3a7f759f9cc7ef246243a33e","modified":1492218610000},{"_id":"source/_posts/Jackblog-vue.md","hash":"31bd73fcb67fbca64840b3e7622b00bebb0d01bf","modified":1492218610000},{"_id":"source/_posts/async.md","hash":"b7bf6c58a2db7619f72ce3b8bc820ea1f6fa757d","modified":1492218610000},{"_id":"source/_posts/canvas.md","hash":"8b77a7c1e570a29c2d49edb21d7ecc96eab9c680","modified":1492218610000},{"_id":"source/_posts/eventTarget.md","hash":"191480e47685fd24b8aa2d9d63c014ceecbf3741","modified":1492728070043},{"_id":"source/_posts/express.md","hash":"38d77f3b7a226383e47332282a17ed429ff3d705","modified":1492218610000},{"_id":"source/_posts/expressR.md","hash":"ac3589468cc7f15e9d992d4d5b4332a785c92e41","modified":1492218610000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1492723485723},{"_id":"source/_posts/https.md","hash":"51173b216c33c12153390cbecfdb623dab846d71","modified":1492218610000},{"_id":"source/_posts/promise.md","hash":"c477aab24199e05690c23f0e5d139f7965e60dba","modified":1492218610000},{"_id":"source/_posts/regexp.md","hash":"abdda8c2f22a42ebfc6161bc45300f1d8b77c919","modified":1492218610000},{"_id":"source/_posts/urlTopage.md","hash":"e8e91efccef6b24a23e8cda5781a564c504d3d74","modified":1492218610000},{"_id":"source/_posts/vue.md","hash":"d6c9af0e2fc757707a39e9d644e85b199fa7dfc6","modified":1492726353459},{"_id":"source/_posts/webpack.md","hash":"34d4180bb5bd41072505c1a19cb0ef457a7cd09b","modified":1492218610000},{"_id":"source/img/avatar.jpg","hash":"ac1e4800122c20dc366263ae03e56e895553568e","modified":1492218610000},{"_id":"public/2016/09/23/regexp/index.html","hash":"a3cc2f195c94ab258b8db84c331f17bae0bea75e","modified":1492729149018},{"_id":"public/2016/10/18/Jackblog-vue/index.html","hash":"6d0ea442f0fe631982745ceff38adc35dd712a05","modified":1492729149018},{"_id":"public/2016/09/15/canvas/index.html","hash":"b02084d6596a7da9a465063f33f627dfc35f2530","modified":1492729149018},{"_id":"public/2016/09/20/expressR/index.html","hash":"140a86aba8bba8c9828f4dcd2142f632f9b030bf","modified":1492729149018},{"_id":"public/2016/10/21/Jackblog-Express/index.html","hash":"371bf5d8456cd8b0c5f9d0b75738380184d1edc4","modified":1492729149018},{"_id":"public/2016/10/22/webpack/index.html","hash":"b7e48bbd11c0bdc49bee54e97995314bc4b8aa9d","modified":1492729149018},{"_id":"public/2016/11/13/express/index.html","hash":"0c3b532d51f9253f1c441a298b49e7dfbfdf0a2d","modified":1492729149018},{"_id":"public/2017/02/27/https/index.html","hash":"62699f1500445bfdc806c44612f1d5873af6d317","modified":1492729149019},{"_id":"public/2017/02/28/promise/index.html","hash":"742a1527ff4a6aeac0b0cbd9b7bd3b7045b07218","modified":1492729149019},{"_id":"public/2017/03/23/eventTarget/index.html","hash":"decc577924cd43b29687ffb84178505183db926c","modified":1492729149019},{"_id":"public/archives/index.html","hash":"616f81beb5bd84e0b8b402bab8d5cb9b39813f61","modified":1492729149019},{"_id":"public/2017/04/07/async/index.html","hash":"a506c4375b6878312d489000bd6e67bd9716146e","modified":1492729149019},{"_id":"public/2017/04/13/urlTopage/index.html","hash":"e183673cbc27fe9e6c75b08677653f6db4958e03","modified":1492729149019},{"_id":"public/2017/04/20/hello-world/index.html","hash":"e5d30fe2f25dc95140ad7b6a738edc2da8e6a6eb","modified":1492726618524},{"_id":"public/archives/2016/index.html","hash":"10ab9159a4a445b542ee3a06430987e94b055a38","modified":1492729149019},{"_id":"public/archives/page/2/index.html","hash":"b86b80102d3dd8dc7d50755f510f39ab43395237","modified":1492729149019},{"_id":"public/archives/2016/11/index.html","hash":"5e7b693ab74ce499bb69d78ed9cc1c911e14710b","modified":1492729149020},{"_id":"public/archives/2016/09/index.html","hash":"82cf8e4fd4b96d3c657a38d31baff8683a58fa37","modified":1492729149019},{"_id":"public/archives/2016/10/index.html","hash":"d50948c3d58dc71410bc525f7672fe0b31a79b57","modified":1492729149019},{"_id":"public/archives/2017/index.html","hash":"a10226b8002c6378d43610654b34214dcfed1c1e","modified":1492729149023},{"_id":"public/index.html","hash":"f97e6765653405f767c904168796b8d8a4c6ef1c","modified":1492729149023},{"_id":"public/archives/2017/02/index.html","hash":"8318995c015b3137a6b98db35c2e43cc7c82b20e","modified":1492729149023},{"_id":"public/archives/2017/03/index.html","hash":"0bf3104736d8d4985604721307f2f5e293d6caf8","modified":1492729149023},{"_id":"public/2017/04/16/vue/index.html","hash":"f08cdd29fd6e5af51e9dd03d842c49e37094088a","modified":1492729149019},{"_id":"public/archives/2017/04/index.html","hash":"44c98d79b804489a20c7039c21b80abd14c9f2fa","modified":1492729149023},{"_id":"public/page/2/index.html","hash":"63215edac6b71688033e3aa8cfafde6e49056f2c","modified":1492729149023},{"_id":"public/tags/javascript/index.html","hash":"a3d46ac98679179a37e121b1256a76f830d6e697","modified":1492729149023},{"_id":"public/tags/canvas/index.html","hash":"408b3ad06a7d88fffe18822b2dc8c171ca77fcf8","modified":1492729149028},{"_id":"public/tags/nodejs/index.html","hash":"cd1430f7113e6373e645c1b2518591a8ab46a531","modified":1492729149028},{"_id":"public/tags/https/index.html","hash":"d7c9c8d1cc2a0e5033a45ad5a04ebed7ab86f965","modified":1492729149028},{"_id":"public/tags/regexp/index.html","hash":"a2dfe08a4182229259c5b805e790c729096d4333","modified":1492729149028},{"_id":"public/tags/HTML/index.html","hash":"43e022b4c7ec329861b378e786925b4663b879ea","modified":1492729149028},{"_id":"public/tags/webpack/index.html","hash":"2f9709d25617bab718c9577c85f1a13e097301af","modified":1492729149028},{"_id":"public/CNAME","hash":"9a8e0e96695b197912d701e5369fa130e3be6326","modified":1492726580660},{"_id":"public/img/avatar.jpg","hash":"ac1e4800122c20dc366263ae03e56e895553568e","modified":1492726580661},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1492726555923},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1492726555923},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1492726555923},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1492726555923},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1492726555923},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1492726555923},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1492726555923},{"_id":"themes/yilia/_config.yml","hash":"41e3d5d92f39f851dc85ca05fb82ad552cf5996e","modified":1492729140787},{"_id":"themes/yilia/package.json","hash":"946b26ae0dff42c590068f0a58ecd326ed059b68","modified":1492726555923},{"_id":"themes/yilia/webpack.config.js","hash":"c4dca5c60822c90359e48fad373be768ae9fb43d","modified":1492726555927},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1492726555891},{"_id":"themes/yilia/.git/index","hash":"e2703f322e6d2e19c76eb190c05dffaf1b60a31d","modified":1492726555927},{"_id":"themes/yilia/.git/config","hash":"45dbf7cad960774e3ebd63f878005463a78e4c69","modified":1492726555891},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1492726427683},{"_id":"themes/yilia/.git/packed-refs","hash":"f2c7824806e24eef83ae2f410b72a12d3ed2a00d","modified":1492726555891},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1492726555923},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1492726555923},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1492726555923},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1492726555923},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1492726555923},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1492726555923},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1492726555923},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1492726555923},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1492726555923},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1492726555923},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1492726555923},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1492726555923},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1492726555923},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1492726555923},{"_id":"themes/yilia/source/main.f6a68c.css","hash":"116e8d4922fc5c677b6a6970285f6258b20fe34d","modified":1492726555927},{"_id":"themes/yilia/source/mobile.40e320.js","hash":"cddc2fb9b2df3eee0c0e9d0cb937f9e54429970d","modified":1492726555927},{"_id":"themes/yilia/source/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1492726555927},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1492726555923},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1492726555927},{"_id":"themes/yilia/source/main.f6a68c.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1492726555927},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1492726427687},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1492726427683},{"_id":"themes/yilia/.git/logs/HEAD","hash":"90c0ef61f1ef76a6582a796086981f22117e27a0","modified":1492726555891},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1492726427683},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"fe8e368f5be6b8e0724c602380e787f88a360074","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"1c0680ad7a6750bb19effae183b58755256fe241","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1492726555923},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1492726555927},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1492726555927},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1492726555927},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1492726555927},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1492726555927},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1492726555927},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1492726555927},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1492726555927},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1492726555927},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1492726555923},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1492726555923},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1492726555923},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1492726555923},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1492726555923},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1492726555923},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1492726555923},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1492726555923},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1492726555923},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1492726555923},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1492726555923},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1492726555923},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1492726555923},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1492726555923},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1492726555923},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1492726555923},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1492726555923},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1492726555923},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1492726555923},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1492726555923},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1492726555923},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1492726555923},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1492726555923},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1492726555923},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1492726555923},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1492726555923},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1492726555923},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1492726555923},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1492726555923},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1492726555923},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1492726555927},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1492726555927},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1492726555927},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1492726555927},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1492726555927},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1492726555927},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1492726555927},{"_id":"themes/yilia/.git/objects/pack/pack-b28ee3c26bfd4ec44aa435f2b07650be71f48b11.idx","hash":"4821e9ea7ab46b5f98d9581dd783901d0200b23a","modified":1492726555863},{"_id":"themes/yilia/.git/refs/heads/master","hash":"f25c7071eabad44abcb3a813a2b8d9d56fbee9cf","modified":1492726555891},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"1ba1d4a4663eae37b1a2b75c47dfdff4fb3cbf52","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1492726555923},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"7851d961ae172f521ba71e255fdc60f4ca0b45ed","modified":1492726555923},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1492726555923},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1492726555923},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1492726555923},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1492726555923},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1492726555923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1492726555923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1492726555923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1492726555923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1492726555923},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1492726555923},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1492726555923},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1492726555923},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"90c0ef61f1ef76a6582a796086981f22117e27a0","modified":1492726555891},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1492726555891},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"90c0ef61f1ef76a6582a796086981f22117e27a0","modified":1492726555891},{"_id":"themes/yilia/.git/objects/pack/pack-b28ee3c26bfd4ec44aa435f2b07650be71f48b11.pack","hash":"1b55ecf85307ebb5489b9293dfe6b681d0073563","modified":1492726555863},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1492726618539},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1492726618539},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1492726618540},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1492726618540},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1492726618540},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1492726618540},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1492726618540},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1492726618540},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1492726618540},{"_id":"public/main.f6a68c.css","hash":"116e8d4922fc5c677b6a6970285f6258b20fe34d","modified":1492726618554},{"_id":"public/mobile.40e320.js","hash":"cddc2fb9b2df3eee0c0e9d0cb937f9e54429970d","modified":1492726618554},{"_id":"public/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1492726618554},{"_id":"public/main.f6a68c.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1492726618558}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Jackblog-express源码分析","date":"2016-10-21T10:18:51.000Z","_content":"Jackblog是一个前后端分离的项目，前两天把前端vue-blog的源码看完了，本人对express比较熟悉，所以这篇文章只是对代码的逻辑以及中间件的使用进行分析.<!--more-->\n### 整体流程\n通过gulp.src()加载gulp.task()的配置文件，加载nodemon启动app.js，express服务器打开. 用mongoose 以及es6原生promise以脱离回调函数的方式来写数据库的初始化以及CRUD. 在逻辑处理部分:require进来express的配置部分，require进来router的配置，很值得学习的地方，令人看着清晰明了.在router的配置部分,是通过对每个路由挂载一个require进来的router对象.对路由的处理函数分离出到api的文件夹里，每个函数都用module.exports暴露出来。 整个流程就是如此！\n### 技术栈\n* express4.X\n* mongoose\n* 各种中间件的使用\n### 中间件分析\n此处贴出express.js代码\n![]http://of8m1pnnt.bkt.clouddn.com/express.jpg\n[compression](https://github.com/expressjs/compression)\nNode.js的压缩中间件，支持deflate，gzip的编码\n[body-parser](https://github.com/expressjs/body-parser)\n对请求request的body部分进行解析，可通过req.body获取值\nuseage:\napp.use(bodyParser.urlencoded({extended:false})) //只解析urlencoded body，当extended是true的时候解析任意类型的键值对，当extended是false的时候，解析value是string或array的键值对\napp.use(bodyParser.json())//对json解析\n[cookie-parser](https://github.com/expressjs/cookie-parser)\n解析cookie header 并且用这个cookie对象来填充req.cookies\nusage:\napp.use(cookieParser())\n[cors](https://github.com/expressjs/cors)\n解决跨域问题的中间件，跨域是指不同域名之间相互访问，二级域名、端口、协议必须与主页面完全相同，否则就算是跨域.\n**usage:**\n```javascript\napp.use(cors()) // 允许任意来源的网站跨域访问\napp.use(cors({\n    origin:'http://example.com'  //只允许这个网站跨域访问\n}))\n```\n流程：　对于简单请求，浏览器发出CORS请求，即在请求的头信息中增加Origin字段。\n服务器根据这个字段指定的源来响应，若在范围内，响应的头信息添加以下几个头信息字段\nAccess-Control-Allow-Origin：表示接受某域名的请求\nAccess-Control-Allow-Credentials：表示是否允许发送Cookie，默认为false\nAccess-Control-Allow-Expose-Headers： CORS请求时，XMLHttpRequest对象的getResponseHeader()只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，必须在这个字段里指定.[参考链接](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[method-override](https://github.com/expressjs/method-override)\nLets you use HTTP verbs such as PUT or DELETE in places where the client doesn’t support it.\n在表单中 只能用get或者post提交，运用这个中间件的话，就可以实现delete或者put的提交了～\nusage:\n```javascript\napp.use(methodOverride('X-HTTP-Method-Override'))\nor\napp.use(methodOverride(function(req,res){\n    if(req.body&&typeof req.body==='object'&&'_method'in req.body){\n        var method = req.body._method\n        delete req.body._method\n        return method\n    }\n}))\n```\n[passport](https://github.com/jaredhanson/passport)\n这个中间件用来进行身份验证。你提供Passport一个认证请求，Passport返回一个钩子控制回调函数(成功或者失败)\nusage:\n以QQ为例\n```javascript\nvar passport=require(‘passport’)\nvar qqStrategy=require(‘passport-qq’).Strategy\n\npassport.use(new qqStrategy({\nclientID:xxxx,\nclientSecret:xxxx,\ncallbackURL:xxx,\npassReqToCallbacl:true\n}),function(req,accessToken,refreshToken,profile,done){})\n```\n[express-session](https://github.com/expressjs/session)\nusage:\napp.use(session({\n    secret: ‘any key’,\n    resave: true, //即使session没有被修改，也重新保存，默认为true\n    saveUninitialized:true,//每次请求重新设置session cookie 默认给哥connect.sid\n    cookie:{maxAge:6000*5}，\n    store:  //session的存储方式，默认存储在内存中，可以使用redisstore\n    store:new RedisStore({\n        host:xxx\n        port:xxx\n        pass:xxx//password 认证Redis\n    })\n\n}))\n[cookie与session](http://kirochen.com/2015/07/09/about-cookie-session/#)\n### 路由逻辑\nroutes.js\n![](http://of8m1pnnt.bkt.clouddn.com/routes.jpg)\nuser.js\n![](http://of8m1pnnt.bkt.clouddn.com/controller.jpg)\ncontroller.js\n![](http://of8m1pnnt.bkt.clouddn.com/user.jpg)\n这种思路很值得学习，具体没什么特别说的，对路由的请求处理～\n","source":"_posts/Jackblog-Express.md","raw":"---\ntitle: Jackblog-express源码分析\ndate: 2016-10-21 03:18:51\ntags: [javascript]\n---\nJackblog是一个前后端分离的项目，前两天把前端vue-blog的源码看完了，本人对express比较熟悉，所以这篇文章只是对代码的逻辑以及中间件的使用进行分析.<!--more-->\n### 整体流程\n通过gulp.src()加载gulp.task()的配置文件，加载nodemon启动app.js，express服务器打开. 用mongoose 以及es6原生promise以脱离回调函数的方式来写数据库的初始化以及CRUD. 在逻辑处理部分:require进来express的配置部分，require进来router的配置，很值得学习的地方，令人看着清晰明了.在router的配置部分,是通过对每个路由挂载一个require进来的router对象.对路由的处理函数分离出到api的文件夹里，每个函数都用module.exports暴露出来。 整个流程就是如此！\n### 技术栈\n* express4.X\n* mongoose\n* 各种中间件的使用\n### 中间件分析\n此处贴出express.js代码\n![]http://of8m1pnnt.bkt.clouddn.com/express.jpg\n[compression](https://github.com/expressjs/compression)\nNode.js的压缩中间件，支持deflate，gzip的编码\n[body-parser](https://github.com/expressjs/body-parser)\n对请求request的body部分进行解析，可通过req.body获取值\nuseage:\napp.use(bodyParser.urlencoded({extended:false})) //只解析urlencoded body，当extended是true的时候解析任意类型的键值对，当extended是false的时候，解析value是string或array的键值对\napp.use(bodyParser.json())//对json解析\n[cookie-parser](https://github.com/expressjs/cookie-parser)\n解析cookie header 并且用这个cookie对象来填充req.cookies\nusage:\napp.use(cookieParser())\n[cors](https://github.com/expressjs/cors)\n解决跨域问题的中间件，跨域是指不同域名之间相互访问，二级域名、端口、协议必须与主页面完全相同，否则就算是跨域.\n**usage:**\n```javascript\napp.use(cors()) // 允许任意来源的网站跨域访问\napp.use(cors({\n    origin:'http://example.com'  //只允许这个网站跨域访问\n}))\n```\n流程：　对于简单请求，浏览器发出CORS请求，即在请求的头信息中增加Origin字段。\n服务器根据这个字段指定的源来响应，若在范围内，响应的头信息添加以下几个头信息字段\nAccess-Control-Allow-Origin：表示接受某域名的请求\nAccess-Control-Allow-Credentials：表示是否允许发送Cookie，默认为false\nAccess-Control-Allow-Expose-Headers： CORS请求时，XMLHttpRequest对象的getResponseHeader()只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，必须在这个字段里指定.[参考链接](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[method-override](https://github.com/expressjs/method-override)\nLets you use HTTP verbs such as PUT or DELETE in places where the client doesn’t support it.\n在表单中 只能用get或者post提交，运用这个中间件的话，就可以实现delete或者put的提交了～\nusage:\n```javascript\napp.use(methodOverride('X-HTTP-Method-Override'))\nor\napp.use(methodOverride(function(req,res){\n    if(req.body&&typeof req.body==='object'&&'_method'in req.body){\n        var method = req.body._method\n        delete req.body._method\n        return method\n    }\n}))\n```\n[passport](https://github.com/jaredhanson/passport)\n这个中间件用来进行身份验证。你提供Passport一个认证请求，Passport返回一个钩子控制回调函数(成功或者失败)\nusage:\n以QQ为例\n```javascript\nvar passport=require(‘passport’)\nvar qqStrategy=require(‘passport-qq’).Strategy\n\npassport.use(new qqStrategy({\nclientID:xxxx,\nclientSecret:xxxx,\ncallbackURL:xxx,\npassReqToCallbacl:true\n}),function(req,accessToken,refreshToken,profile,done){})\n```\n[express-session](https://github.com/expressjs/session)\nusage:\napp.use(session({\n    secret: ‘any key’,\n    resave: true, //即使session没有被修改，也重新保存，默认为true\n    saveUninitialized:true,//每次请求重新设置session cookie 默认给哥connect.sid\n    cookie:{maxAge:6000*5}，\n    store:  //session的存储方式，默认存储在内存中，可以使用redisstore\n    store:new RedisStore({\n        host:xxx\n        port:xxx\n        pass:xxx//password 认证Redis\n    })\n\n}))\n[cookie与session](http://kirochen.com/2015/07/09/about-cookie-session/#)\n### 路由逻辑\nroutes.js\n![](http://of8m1pnnt.bkt.clouddn.com/routes.jpg)\nuser.js\n![](http://of8m1pnnt.bkt.clouddn.com/controller.jpg)\ncontroller.js\n![](http://of8m1pnnt.bkt.clouddn.com/user.jpg)\n这种思路很值得学习，具体没什么特别说的，对路由的请求处理～\n","slug":"Jackblog-Express","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4q50000oejx2dwaizk2","content":"<p>Jackblog是一个前后端分离的项目，前两天把前端vue-blog的源码看完了，本人对express比较熟悉，所以这篇文章只是对代码的逻辑以及中间件的使用进行分析.<a id=\"more\"></a></p>\n<h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p>通过gulp.src()加载gulp.task()的配置文件，加载nodemon启动app.js，express服务器打开. 用mongoose 以及es6原生promise以脱离回调函数的方式来写数据库的初始化以及CRUD. 在逻辑处理部分:require进来express的配置部分，require进来router的配置，很值得学习的地方，令人看着清晰明了.在router的配置部分,是通过对每个路由挂载一个require进来的router对象.对路由的处理函数分离出到api的文件夹里，每个函数都用module.exports暴露出来。 整个流程就是如此！</p>\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><ul>\n<li>express4.X</li>\n<li>mongoose</li>\n<li>各种中间件的使用<h3 id=\"中间件分析\"><a href=\"#中间件分析\" class=\"headerlink\" title=\"中间件分析\"></a>中间件分析</h3>此处贴出express.js代码<br>![]<a href=\"http://of8m1pnnt.bkt.clouddn.com/express.jpg\" target=\"_blank\" rel=\"external\">http://of8m1pnnt.bkt.clouddn.com/express.jpg</a><br><a href=\"https://github.com/expressjs/compression\" target=\"_blank\" rel=\"external\">compression</a><br>Node.js的压缩中间件，支持deflate，gzip的编码<br><a href=\"https://github.com/expressjs/body-parser\" target=\"_blank\" rel=\"external\">body-parser</a><br>对请求request的body部分进行解析，可通过req.body获取值<br>useage:<br>app.use(bodyParser.urlencoded({extended:false})) //只解析urlencoded body，当extended是true的时候解析任意类型的键值对，当extended是false的时候，解析value是string或array的键值对<br>app.use(bodyParser.json())//对json解析<br><a href=\"https://github.com/expressjs/cookie-parser\" target=\"_blank\" rel=\"external\">cookie-parser</a><br>解析cookie header 并且用这个cookie对象来填充req.cookies<br>usage:<br>app.use(cookieParser())<br><a href=\"https://github.com/expressjs/cors\" target=\"_blank\" rel=\"external\">cors</a><br>解决跨域问题的中间件，跨域是指不同域名之间相互访问，二级域名、端口、协议必须与主页面完全相同，否则就算是跨域.<br><strong>usage:</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(cors()) <span class=\"comment\">// 允许任意来源的网站跨域访问</span></div><div class=\"line\">app.use(cors(&#123;</div><div class=\"line\">    <span class=\"attr\">origin</span>:<span class=\"string\">'http://example.com'</span>  <span class=\"comment\">//只允许这个网站跨域访问</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>流程：　对于简单请求，浏览器发出CORS请求，即在请求的头信息中增加Origin字段。<br>服务器根据这个字段指定的源来响应，若在范围内，响应的头信息添加以下几个头信息字段<br>Access-Control-Allow-Origin：表示接受某域名的请求<br>Access-Control-Allow-Credentials：表示是否允许发送Cookie，默认为false<br>Access-Control-Allow-Expose-Headers： CORS请求时，XMLHttpRequest对象的getResponseHeader()只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，必须在这个字段里指定.<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"external\">参考链接</a><br><a href=\"https://github.com/expressjs/method-override\" target=\"_blank\" rel=\"external\">method-override</a><br>Lets you use HTTP verbs such as PUT or DELETE in places where the client doesn’t support it.<br>在表单中 只能用get或者post提交，运用这个中间件的话，就可以实现delete或者put的提交了～<br>usage:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(methodOverride(<span class=\"string\">'X-HTTP-Method-Override'</span>))</div><div class=\"line\">or</div><div class=\"line\">app.use(methodOverride(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(req.body&amp;&amp;<span class=\"keyword\">typeof</span> req.body===<span class=\"string\">'object'</span>&amp;&amp;<span class=\"string\">'_method'</span><span class=\"keyword\">in</span> req.body)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> method = req.body._method</div><div class=\"line\">        <span class=\"keyword\">delete</span> req.body._method</div><div class=\"line\">        <span class=\"keyword\">return</span> method</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/jaredhanson/passport\" target=\"_blank\" rel=\"external\">passport</a><br>这个中间件用来进行身份验证。你提供Passport一个认证请求，Passport返回一个钩子控制回调函数(成功或者失败)<br>usage:<br>以QQ为例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> passport=<span class=\"built_in\">require</span>(‘passport’)</div><div class=\"line\"><span class=\"keyword\">var</span> qqStrategy=<span class=\"built_in\">require</span>(‘passport-qq’).Strategy</div><div class=\"line\"></div><div class=\"line\">passport.use(<span class=\"keyword\">new</span> qqStrategy(&#123;</div><div class=\"line\"><span class=\"attr\">clientID</span>:xxxx,</div><div class=\"line\"><span class=\"attr\">clientSecret</span>:xxxx,</div><div class=\"line\"><span class=\"attr\">callbackURL</span>:xxx,</div><div class=\"line\"><span class=\"attr\">passReqToCallbacl</span>:<span class=\"literal\">true</span></div><div class=\"line\">&#125;),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,accessToken,refreshToken,profile,done</span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/expressjs/session\" target=\"_blank\" rel=\"external\">express-session</a><br>usage:<br>app.use(session({<br>    secret: ‘any key’,<br>    resave: true, //即使session没有被修改，也重新保存，默认为true<br>    saveUninitialized:true,//每次请求重新设置session cookie 默认给哥connect.sid<br>    cookie:{maxAge:6000*5}，<br>    store:  //session的存储方式，默认存储在内存中，可以使用redisstore<br>    store:new RedisStore({<br>        host:xxx<br>        port:xxx<br>        pass:xxx//password 认证Redis<br>    })</p>\n<p>}))<br><a href=\"http://kirochen.com/2015/07/09/about-cookie-session/#\" target=\"_blank\" rel=\"external\">cookie与session</a></p>\n<h3 id=\"路由逻辑\"><a href=\"#路由逻辑\" class=\"headerlink\" title=\"路由逻辑\"></a>路由逻辑</h3><p>routes.js<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/routes.jpg\" alt=\"\"><br>user.js<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/controller.jpg\" alt=\"\"><br>controller.js<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/user.jpg\" alt=\"\"><br>这种思路很值得学习，具体没什么特别说的，对路由的请求处理～</p>\n","site":{"data":{}},"excerpt":"<p>Jackblog是一个前后端分离的项目，前两天把前端vue-blog的源码看完了，本人对express比较熟悉，所以这篇文章只是对代码的逻辑以及中间件的使用进行分析.","more":"</p>\n<h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p>通过gulp.src()加载gulp.task()的配置文件，加载nodemon启动app.js，express服务器打开. 用mongoose 以及es6原生promise以脱离回调函数的方式来写数据库的初始化以及CRUD. 在逻辑处理部分:require进来express的配置部分，require进来router的配置，很值得学习的地方，令人看着清晰明了.在router的配置部分,是通过对每个路由挂载一个require进来的router对象.对路由的处理函数分离出到api的文件夹里，每个函数都用module.exports暴露出来。 整个流程就是如此！</p>\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><ul>\n<li>express4.X</li>\n<li>mongoose</li>\n<li>各种中间件的使用<h3 id=\"中间件分析\"><a href=\"#中间件分析\" class=\"headerlink\" title=\"中间件分析\"></a>中间件分析</h3>此处贴出express.js代码<br>![]<a href=\"http://of8m1pnnt.bkt.clouddn.com/express.jpg\">http://of8m1pnnt.bkt.clouddn.com/express.jpg</a><br><a href=\"https://github.com/expressjs/compression\">compression</a><br>Node.js的压缩中间件，支持deflate，gzip的编码<br><a href=\"https://github.com/expressjs/body-parser\">body-parser</a><br>对请求request的body部分进行解析，可通过req.body获取值<br>useage:<br>app.use(bodyParser.urlencoded({extended:false})) //只解析urlencoded body，当extended是true的时候解析任意类型的键值对，当extended是false的时候，解析value是string或array的键值对<br>app.use(bodyParser.json())//对json解析<br><a href=\"https://github.com/expressjs/cookie-parser\">cookie-parser</a><br>解析cookie header 并且用这个cookie对象来填充req.cookies<br>usage:<br>app.use(cookieParser())<br><a href=\"https://github.com/expressjs/cors\">cors</a><br>解决跨域问题的中间件，跨域是指不同域名之间相互访问，二级域名、端口、协议必须与主页面完全相同，否则就算是跨域.<br><strong>usage:</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(cors()) <span class=\"comment\">// 允许任意来源的网站跨域访问</span></div><div class=\"line\">app.use(cors(&#123;</div><div class=\"line\">    <span class=\"attr\">origin</span>:<span class=\"string\">'http://example.com'</span>  <span class=\"comment\">//只允许这个网站跨域访问</span></div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>流程：　对于简单请求，浏览器发出CORS请求，即在请求的头信息中增加Origin字段。<br>服务器根据这个字段指定的源来响应，若在范围内，响应的头信息添加以下几个头信息字段<br>Access-Control-Allow-Origin：表示接受某域名的请求<br>Access-Control-Allow-Credentials：表示是否允许发送Cookie，默认为false<br>Access-Control-Allow-Expose-Headers： CORS请求时，XMLHttpRequest对象的getResponseHeader()只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，必须在这个字段里指定.<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">参考链接</a><br><a href=\"https://github.com/expressjs/method-override\">method-override</a><br>Lets you use HTTP verbs such as PUT or DELETE in places where the client doesn’t support it.<br>在表单中 只能用get或者post提交，运用这个中间件的话，就可以实现delete或者put的提交了～<br>usage:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(methodOverride(<span class=\"string\">'X-HTTP-Method-Override'</span>))</div><div class=\"line\">or</div><div class=\"line\">app.use(methodOverride(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(req.body&amp;&amp;<span class=\"keyword\">typeof</span> req.body===<span class=\"string\">'object'</span>&amp;&amp;<span class=\"string\">'_method'</span><span class=\"keyword\">in</span> req.body)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> method = req.body._method</div><div class=\"line\">        <span class=\"keyword\">delete</span> req.body._method</div><div class=\"line\">        <span class=\"keyword\">return</span> method</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;))</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/jaredhanson/passport\">passport</a><br>这个中间件用来进行身份验证。你提供Passport一个认证请求，Passport返回一个钩子控制回调函数(成功或者失败)<br>usage:<br>以QQ为例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> passport=<span class=\"built_in\">require</span>(‘passport’)</div><div class=\"line\"><span class=\"keyword\">var</span> qqStrategy=<span class=\"built_in\">require</span>(‘passport-qq’).Strategy</div><div class=\"line\"></div><div class=\"line\">passport.use(<span class=\"keyword\">new</span> qqStrategy(&#123;</div><div class=\"line\"><span class=\"attr\">clientID</span>:xxxx,</div><div class=\"line\"><span class=\"attr\">clientSecret</span>:xxxx,</div><div class=\"line\"><span class=\"attr\">callbackURL</span>:xxx,</div><div class=\"line\"><span class=\"attr\">passReqToCallbacl</span>:<span class=\"literal\">true</span></div><div class=\"line\">&#125;),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,accessToken,refreshToken,profile,done</span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/expressjs/session\">express-session</a><br>usage:<br>app.use(session({<br>    secret: ‘any key’,<br>    resave: true, //即使session没有被修改，也重新保存，默认为true<br>    saveUninitialized:true,//每次请求重新设置session cookie 默认给哥connect.sid<br>    cookie:{maxAge:6000*5}，<br>    store:  //session的存储方式，默认存储在内存中，可以使用redisstore<br>    store:new RedisStore({<br>        host:xxx<br>        port:xxx<br>        pass:xxx//password 认证Redis<br>    })</p>\n<p>}))<br><a href=\"http://kirochen.com/2015/07/09/about-cookie-session/#\">cookie与session</a></p>\n<h3 id=\"路由逻辑\"><a href=\"#路由逻辑\" class=\"headerlink\" title=\"路由逻辑\"></a>路由逻辑</h3><p>routes.js<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/routes.jpg\" alt=\"\"><br>user.js<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/controller.jpg\" alt=\"\"><br>controller.js<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/user.jpg\" alt=\"\"><br>这种思路很值得学习，具体没什么特别说的，对路由的请求处理～</p>"},{"title":"Jackblog-vue源码分析","date":"2016-10-18T10:35:34.000Z","_content":"最近开始学习vue.js,在CNode社区发现了一篇Jackblog的帖子，觉得这是个值得学习的项目，通过这个项目来更好的学习vue.js。<!--more-->\n* 技能\n1. gulp:基于流的自动化构建工具.\n2. webpack模块加载器兼打包工具.\n3. vue.js构建数据驱动的前端框架.\n* 流程\n通过gulp.task启动webpack-dev-server和webpack,webpack对入口文件index.js以及import的模块进行打包,生成bundle.js。webpack-dev-server用模板插件生成index.html，并引用bundle.js 。\n然后是生成Vue实例，利用vuex和vue-router进行组件状态管理和路由跳转.\n* 详细分析：\n  项目目录：\n### gulpfile.js\n```javascript\t\ngulp.task('server',function(){})\n```\n1. server:直接调用new webpackDevServer(webpack(config),{‘对devserver的配置’}).listen(port,’localhost’,funtion(err){}).\n2. webpackDevServer:启动webpack-dev-server以及webpack.\n将webpack-dev-server添加到webpack的入口文件需要添加：’webpack-dev-server/client?http://localhost:8080‘.\n3. 将HMR(热替换文件)添加到webpack的入口文件需要添加：’webpack/hot/dev-server’.\n4. webpack-dev-server配置:inline:true—server对入口文件的自动打包和刷新,publicPath:服务器的静态文件目录,hot:true—HMR(热替换):无需刷新整个页面，只把变化的部分替换掉.\n### webpack.config.js\n这里主要说一下用到的插件以及loader.\n1. HtmlWebpackPlugin 用来简化创建服务于webpack bundle的HTML文件。配置信息的话可以自行百度.\n2. ExtractTextPlugin:用来独立出css样式.\n```javascript\nloaders:[\n    {test:/\\.css$/,loader:ExtractTextPlugin.extract(\"style-loader\",\"css-loader\")} //第一个参数是经过编译后通过style-loader单独提取出来，第二个参数用来编译代码的loader\n]\nplugins:[\n    new ExtractTextPlugin(\"style.css\",{allChunks:true}) //所有独立样式打包成一个css文件\n]\n```\n3. webpack.optimize.OccurenceOrderPlugin())为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多的模块\n4. 缓存\n```javascript\noutput:{\n    path:__dirname,\n    filename:'[name].[hash:5].js' //在文件名字后面加md5\n}\n```\n### Vue\nindex.js\n* Vue-Router\n```javascript\n\t\nVue.use(VueRouter)//安装路由功能\nconst router=new VueRouter({})//生成vuerouter实例\nconfigRouter(router)//对router进行路由配置\nconfigRouter()调用了router.map({\n    '/':{\n     \tname:\"...\",\n       \tcomponent:require('...')\n    } \n})\nrouter.start(Vue.extend(App),\"#root\")//启动一个启用了此路由的应用.创建Vue实例(以App为根组件)挂载到id=root的元素上.\n```\n* VueX\nVuex: state management pattern +library for Vue.js\nvuex把应用的数据和修改数据的方法放在了一个store对象里面统一管理，对数据的获取和修改通过配置属性vuex的getters和actions来进行\n![](http://of8m1pnnt.bkt.clouddn.com/vuex.png)\n目录图：\n核心：store.js actions.js\nVue.use(Vuex) //注册Vuex 必须一步\nexport default new Vuex.Store({}) //暴露出生成的store对象\n**注意**\n在根组件引入 store对象 ：import store from “../vuex/store”\nexport default{store} // 被vue-loader暴露出去被JS加载器加载。\n简单一句 Vue.use(Vuex) 然后在根组件内部引入 store 属性就能将store引入到vue的子组件里，通过在vue组件内部调用 this.$store 就能访问到store，而不是每个子组件引入一次store\n### api\nvue-resource 提供网络请求服务和处理响应通过XMLHttpRequrest\n支持 Promise API\n```javascript\nthis.$http.get('/someUrl').then((res)=>{\n    //success callback\n},(res)=>{\n    //error callback\n})\n2.Vue.resource('url'+{/id}).get({id:'someId'}).then((res)=>{\n    //succss callback\n},(res)=>{\n    //error callback\n}) //{/id} 占位符\n```\nndex.js 暴露出来的是前端向后端发送请求的API.供vuex中的actions调用。\n\n### 总结\n项目主要逻辑就是如此：\ngulp控制流程构建\nwebpack打包/加载(css-loader,image-loader,vue-loader…)/调用插件/优化请求\nwebpack-dev-server:详细配置：简书\nvue-loader:参考Thinksaas\nvue+vue-router+vuex+vue-resource 前端逻辑搭建\nvue-strap vue.js的bootstrap组件\nplugin，loader，参考github\n\n","source":"_posts/Jackblog-vue.md","raw":"---\ntitle: Jackblog-vue源码分析\ndate: 2016-10-18 03:35:34\ntags: [javascript]\n---\n最近开始学习vue.js,在CNode社区发现了一篇Jackblog的帖子，觉得这是个值得学习的项目，通过这个项目来更好的学习vue.js。<!--more-->\n* 技能\n1. gulp:基于流的自动化构建工具.\n2. webpack模块加载器兼打包工具.\n3. vue.js构建数据驱动的前端框架.\n* 流程\n通过gulp.task启动webpack-dev-server和webpack,webpack对入口文件index.js以及import的模块进行打包,生成bundle.js。webpack-dev-server用模板插件生成index.html，并引用bundle.js 。\n然后是生成Vue实例，利用vuex和vue-router进行组件状态管理和路由跳转.\n* 详细分析：\n  项目目录：\n### gulpfile.js\n```javascript\t\ngulp.task('server',function(){})\n```\n1. server:直接调用new webpackDevServer(webpack(config),{‘对devserver的配置’}).listen(port,’localhost’,funtion(err){}).\n2. webpackDevServer:启动webpack-dev-server以及webpack.\n将webpack-dev-server添加到webpack的入口文件需要添加：’webpack-dev-server/client?http://localhost:8080‘.\n3. 将HMR(热替换文件)添加到webpack的入口文件需要添加：’webpack/hot/dev-server’.\n4. webpack-dev-server配置:inline:true—server对入口文件的自动打包和刷新,publicPath:服务器的静态文件目录,hot:true—HMR(热替换):无需刷新整个页面，只把变化的部分替换掉.\n### webpack.config.js\n这里主要说一下用到的插件以及loader.\n1. HtmlWebpackPlugin 用来简化创建服务于webpack bundle的HTML文件。配置信息的话可以自行百度.\n2. ExtractTextPlugin:用来独立出css样式.\n```javascript\nloaders:[\n    {test:/\\.css$/,loader:ExtractTextPlugin.extract(\"style-loader\",\"css-loader\")} //第一个参数是经过编译后通过style-loader单独提取出来，第二个参数用来编译代码的loader\n]\nplugins:[\n    new ExtractTextPlugin(\"style.css\",{allChunks:true}) //所有独立样式打包成一个css文件\n]\n```\n3. webpack.optimize.OccurenceOrderPlugin())为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多的模块\n4. 缓存\n```javascript\noutput:{\n    path:__dirname,\n    filename:'[name].[hash:5].js' //在文件名字后面加md5\n}\n```\n### Vue\nindex.js\n* Vue-Router\n```javascript\n\t\nVue.use(VueRouter)//安装路由功能\nconst router=new VueRouter({})//生成vuerouter实例\nconfigRouter(router)//对router进行路由配置\nconfigRouter()调用了router.map({\n    '/':{\n     \tname:\"...\",\n       \tcomponent:require('...')\n    } \n})\nrouter.start(Vue.extend(App),\"#root\")//启动一个启用了此路由的应用.创建Vue实例(以App为根组件)挂载到id=root的元素上.\n```\n* VueX\nVuex: state management pattern +library for Vue.js\nvuex把应用的数据和修改数据的方法放在了一个store对象里面统一管理，对数据的获取和修改通过配置属性vuex的getters和actions来进行\n![](http://of8m1pnnt.bkt.clouddn.com/vuex.png)\n目录图：\n核心：store.js actions.js\nVue.use(Vuex) //注册Vuex 必须一步\nexport default new Vuex.Store({}) //暴露出生成的store对象\n**注意**\n在根组件引入 store对象 ：import store from “../vuex/store”\nexport default{store} // 被vue-loader暴露出去被JS加载器加载。\n简单一句 Vue.use(Vuex) 然后在根组件内部引入 store 属性就能将store引入到vue的子组件里，通过在vue组件内部调用 this.$store 就能访问到store，而不是每个子组件引入一次store\n### api\nvue-resource 提供网络请求服务和处理响应通过XMLHttpRequrest\n支持 Promise API\n```javascript\nthis.$http.get('/someUrl').then((res)=>{\n    //success callback\n},(res)=>{\n    //error callback\n})\n2.Vue.resource('url'+{/id}).get({id:'someId'}).then((res)=>{\n    //succss callback\n},(res)=>{\n    //error callback\n}) //{/id} 占位符\n```\nndex.js 暴露出来的是前端向后端发送请求的API.供vuex中的actions调用。\n\n### 总结\n项目主要逻辑就是如此：\ngulp控制流程构建\nwebpack打包/加载(css-loader,image-loader,vue-loader…)/调用插件/优化请求\nwebpack-dev-server:详细配置：简书\nvue-loader:参考Thinksaas\nvue+vue-router+vuex+vue-resource 前端逻辑搭建\nvue-strap vue.js的bootstrap组件\nplugin，loader，参考github\n\n","slug":"Jackblog-vue","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4qe0001oejx0h7na2qf","content":"<p>最近开始学习vue.js,在CNode社区发现了一篇Jackblog的帖子，觉得这是个值得学习的项目，通过这个项目来更好的学习vue.js。<a id=\"more\"></a></p>\n<ul>\n<li>技能</li>\n</ul>\n<ol>\n<li>gulp:基于流的自动化构建工具.</li>\n<li>webpack模块加载器兼打包工具.</li>\n<li>vue.js构建数据驱动的前端框架.</li>\n</ol>\n<ul>\n<li>流程<br>通过gulp.task启动webpack-dev-server和webpack,webpack对入口文件index.js以及import的模块进行打包,生成bundle.js。webpack-dev-server用模板插件生成index.html，并引用bundle.js 。<br>然后是生成Vue实例，利用vuex和vue-router进行组件状态管理和路由跳转.</li>\n<li>详细分析：<br>项目目录：<h3 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'server'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>server:直接调用new webpackDevServer(webpack(config),{‘对devserver的配置’}).listen(port,’localhost’,funtion(err){}).</li>\n<li>webpackDevServer:启动webpack-dev-server以及webpack.<br>将webpack-dev-server添加到webpack的入口文件需要添加：’webpack-dev-server/client?<a href=\"http://localhost:8080‘\" target=\"_blank\" rel=\"external\">http://localhost:8080‘</a>.</li>\n<li>将HMR(热替换文件)添加到webpack的入口文件需要添加：’webpack/hot/dev-server’.</li>\n<li>webpack-dev-server配置:inline:true—server对入口文件的自动打包和刷新,publicPath:服务器的静态文件目录,hot:true—HMR(热替换):无需刷新整个页面，只把变化的部分替换掉.<h3 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h3>这里主要说一下用到的插件以及loader.</li>\n<li>HtmlWebpackPlugin 用来简化创建服务于webpack bundle的HTML文件。配置信息的话可以自行百度.</li>\n<li><p>ExtractTextPlugin:用来独立出css样式.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders:[</div><div class=\"line\">    &#123;<span class=\"attr\">test</span>:<span class=\"regexp\">/\\.css$/</span>,<span class=\"attr\">loader</span>:ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>,<span class=\"string\">\"css-loader\"</span>)&#125; <span class=\"comment\">//第一个参数是经过编译后通过style-loader单独提取出来，第二个参数用来编译代码的loader</span></div><div class=\"line\">]</div><div class=\"line\">plugins:[</div><div class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"style.css\"</span>,&#123;<span class=\"attr\">allChunks</span>:<span class=\"literal\">true</span>&#125;) <span class=\"comment\">//所有独立样式打包成一个css文件</span></div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n<li><p>webpack.optimize.OccurenceOrderPlugin())为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多的模块</p>\n</li>\n<li>缓存<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">output:&#123;</div><div class=\"line\">    <span class=\"attr\">path</span>:__dirname,</div><div class=\"line\">    <span class=\"attr\">filename</span>:<span class=\"string\">'[name].[hash:5].js'</span> <span class=\"comment\">//在文件名字后面加md5</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>index.js</p>\n<ul>\n<li><p>Vue-Router</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div><div class=\"line\">Vue.use(VueRouter)<span class=\"comment\">//安装路由功能</span></div><div class=\"line\"><span class=\"keyword\">const</span> router=<span class=\"keyword\">new</span> VueRouter(&#123;&#125;)<span class=\"comment\">//生成vuerouter实例</span></div><div class=\"line\">configRouter(router)<span class=\"comment\">//对router进行路由配置</span></div><div class=\"line\">configRouter()调用了router.map(&#123;</div><div class=\"line\">    <span class=\"string\">'/'</span>:&#123;</div><div class=\"line\">     \t<span class=\"attr\">name</span>:<span class=\"string\">\"...\"</span>,</div><div class=\"line\">       \t<span class=\"attr\">component</span>:<span class=\"built_in\">require</span>(<span class=\"string\">'...'</span>)</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;)</div><div class=\"line\">router.start(Vue.extend(App),<span class=\"string\">\"#root\"</span>)<span class=\"comment\">//启动一个启用了此路由的应用.创建Vue实例(以App为根组件)挂载到id=root的元素上.</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>VueX<br>Vuex: state management pattern +library for Vue.js<br>vuex把应用的数据和修改数据的方法放在了一个store对象里面统一管理，对数据的获取和修改通过配置属性vuex的getters和actions来进行<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/vuex.png\" alt=\"\"><br>目录图：<br>核心：store.js actions.js<br>Vue.use(Vuex) //注册Vuex 必须一步<br>export default new Vuex.Store({}) //暴露出生成的store对象<br><strong>注意</strong><br>在根组件引入 store对象 ：import store from “../vuex/store”<br>export default{store} // 被vue-loader暴露出去被JS加载器加载。<br>简单一句 Vue.use(Vuex) 然后在根组件内部引入 store 属性就能将store引入到vue的子组件里，通过在vue组件内部调用 this.$store 就能访问到store，而不是每个子组件引入一次store</p>\n<h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h3><p>vue-resource 提供网络请求服务和处理响应通过XMLHttpRequrest<br>支持 Promise API</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$http.get(<span class=\"string\">'/someUrl'</span>).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//success callback</span></div><div class=\"line\">&#125;,(res)=&gt;&#123;</div><div class=\"line\">    <span class=\"comment\">//error callback</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"number\">2.</span>Vue.resource(<span class=\"string\">'url'</span>+&#123;/id&#125;).get(&#123;<span class=\"attr\">id</span>:<span class=\"string\">'someId'</span>&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//succss callback</span></div><div class=\"line\">&#125;,(res)=&gt;&#123;</div><div class=\"line\">    <span class=\"comment\">//error callback</span></div><div class=\"line\">&#125;) <span class=\"comment\">//&#123;/id&#125; 占位符</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ndex.js 暴露出来的是前端向后端发送请求的API.供vuex中的actions调用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>项目主要逻辑就是如此：<br>gulp控制流程构建<br>webpack打包/加载(css-loader,image-loader,vue-loader…)/调用插件/优化请求<br>webpack-dev-server:详细配置：简书<br>vue-loader:参考Thinksaas<br>vue+vue-router+vuex+vue-resource 前端逻辑搭建<br>vue-strap vue.js的bootstrap组件<br>plugin，loader，参考github</p>\n","site":{"data":{}},"excerpt":"<p>最近开始学习vue.js,在CNode社区发现了一篇Jackblog的帖子，觉得这是个值得学习的项目，通过这个项目来更好的学习vue.js。","more":"</p>\n<ul>\n<li>技能</li>\n</ul>\n<ol>\n<li>gulp:基于流的自动化构建工具.</li>\n<li>webpack模块加载器兼打包工具.</li>\n<li>vue.js构建数据驱动的前端框架.</li>\n</ol>\n<ul>\n<li>流程<br>通过gulp.task启动webpack-dev-server和webpack,webpack对入口文件index.js以及import的模块进行打包,生成bundle.js。webpack-dev-server用模板插件生成index.html，并引用bundle.js 。<br>然后是生成Vue实例，利用vuex和vue-router进行组件状态管理和路由跳转.</li>\n<li>详细分析：<br>项目目录：<h3 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">'server'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>server:直接调用new webpackDevServer(webpack(config),{‘对devserver的配置’}).listen(port,’localhost’,funtion(err){}).</li>\n<li>webpackDevServer:启动webpack-dev-server以及webpack.<br>将webpack-dev-server添加到webpack的入口文件需要添加：’webpack-dev-server/client?<a href=\"http://localhost:8080‘\">http://localhost:8080‘</a>.</li>\n<li>将HMR(热替换文件)添加到webpack的入口文件需要添加：’webpack/hot/dev-server’.</li>\n<li>webpack-dev-server配置:inline:true—server对入口文件的自动打包和刷新,publicPath:服务器的静态文件目录,hot:true—HMR(热替换):无需刷新整个页面，只把变化的部分替换掉.<h3 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h3>这里主要说一下用到的插件以及loader.</li>\n<li>HtmlWebpackPlugin 用来简化创建服务于webpack bundle的HTML文件。配置信息的话可以自行百度.</li>\n<li><p>ExtractTextPlugin:用来独立出css样式.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders:[</div><div class=\"line\">    &#123;<span class=\"attr\">test</span>:<span class=\"regexp\">/\\.css$/</span>,<span class=\"attr\">loader</span>:ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>,<span class=\"string\">\"css-loader\"</span>)&#125; <span class=\"comment\">//第一个参数是经过编译后通过style-loader单独提取出来，第二个参数用来编译代码的loader</span></div><div class=\"line\">]</div><div class=\"line\">plugins:[</div><div class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"style.css\"</span>,&#123;<span class=\"attr\">allChunks</span>:<span class=\"literal\">true</span>&#125;) <span class=\"comment\">//所有独立样式打包成一个css文件</span></div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n<li><p>webpack.optimize.OccurenceOrderPlugin())为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多的模块</p>\n</li>\n<li>缓存<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">output:&#123;</div><div class=\"line\">    <span class=\"attr\">path</span>:__dirname,</div><div class=\"line\">    <span class=\"attr\">filename</span>:<span class=\"string\">'[name].[hash:5].js'</span> <span class=\"comment\">//在文件名字后面加md5</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>index.js</p>\n<ul>\n<li><p>Vue-Router</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t</div><div class=\"line\">Vue.use(VueRouter)<span class=\"comment\">//安装路由功能</span></div><div class=\"line\"><span class=\"keyword\">const</span> router=<span class=\"keyword\">new</span> VueRouter(&#123;&#125;)<span class=\"comment\">//生成vuerouter实例</span></div><div class=\"line\">configRouter(router)<span class=\"comment\">//对router进行路由配置</span></div><div class=\"line\">configRouter()调用了router.map(&#123;</div><div class=\"line\">    <span class=\"string\">'/'</span>:&#123;</div><div class=\"line\">     \t<span class=\"attr\">name</span>:<span class=\"string\">\"...\"</span>,</div><div class=\"line\">       \t<span class=\"attr\">component</span>:<span class=\"built_in\">require</span>(<span class=\"string\">'...'</span>)</div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;)</div><div class=\"line\">router.start(Vue.extend(App),<span class=\"string\">\"#root\"</span>)<span class=\"comment\">//启动一个启用了此路由的应用.创建Vue实例(以App为根组件)挂载到id=root的元素上.</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>VueX<br>Vuex: state management pattern +library for Vue.js<br>vuex把应用的数据和修改数据的方法放在了一个store对象里面统一管理，对数据的获取和修改通过配置属性vuex的getters和actions来进行<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/vuex.png\" alt=\"\"><br>目录图：<br>核心：store.js actions.js<br>Vue.use(Vuex) //注册Vuex 必须一步<br>export default new Vuex.Store({}) //暴露出生成的store对象<br><strong>注意</strong><br>在根组件引入 store对象 ：import store from “../vuex/store”<br>export default{store} // 被vue-loader暴露出去被JS加载器加载。<br>简单一句 Vue.use(Vuex) 然后在根组件内部引入 store 属性就能将store引入到vue的子组件里，通过在vue组件内部调用 this.$store 就能访问到store，而不是每个子组件引入一次store</p>\n<h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h3><p>vue-resource 提供网络请求服务和处理响应通过XMLHttpRequrest<br>支持 Promise API</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$http.get(<span class=\"string\">'/someUrl'</span>).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//success callback</span></div><div class=\"line\">&#125;,(res)=&gt;&#123;</div><div class=\"line\">    <span class=\"comment\">//error callback</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"number\">2.</span>Vue.resource(<span class=\"string\">'url'</span>+&#123;/id&#125;).get(&#123;<span class=\"attr\">id</span>:<span class=\"string\">'someId'</span>&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//succss callback</span></div><div class=\"line\">&#125;,(res)=&gt;&#123;</div><div class=\"line\">    <span class=\"comment\">//error callback</span></div><div class=\"line\">&#125;) <span class=\"comment\">//&#123;/id&#125; 占位符</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ndex.js 暴露出来的是前端向后端发送请求的API.供vuex中的actions调用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>项目主要逻辑就是如此：<br>gulp控制流程构建<br>webpack打包/加载(css-loader,image-loader,vue-loader…)/调用插件/优化请求<br>webpack-dev-server:详细配置：简书<br>vue-loader:参考Thinksaas<br>vue+vue-router+vuex+vue-resource 前端逻辑搭建<br>vue-strap vue.js的bootstrap组件<br>plugin，loader，参考github</p>"},{"title":"实现ES7中的async","date":"2017-04-07T22:37:38.000Z","_content":"async函数是为了使得异步操作更加方便而引入的.async是什么？它就是Generator函数的语法糖，即自动执行的generator函数.\n***基本用法***\n**async**函数返回一个Promise对象，可以使用**then**方法添加回调函数.\n在函数执行的时候，遇到**await**就会先返回，等到异步操作完成，再接着执行函数体内后面的语句.<!--more-->\n一段示例代码如下:\n```js\nfunction timeout(ms){\n  return new Promise(function(resolve)=>{\n    setTimeout(resolve,ms)\n  })\n}\nasync function asyncPrint(value,ms){\n  await timeout(ms)\n  console.log(value)\n}\nasyncPrint('hello world',50)\n```\n上述代码 50ms之后输出**hello world**.\n***实现async函数所需要知道的***\n1. 首先，我们需要知道执行async函数后发生了什么？\n   返回一个promise对象，内部封装了一个自动执行的generator函数\n2. 如何实现自动执行的generator函数？\n   generator函数返回的是一个iterator对象，有一个value属性和一个next()方法.\n3. generator函数内部是怎样的呢？\n   generator函数内部是一个带有yield语句的普通函数.yield语句是暂停执行的标记，而next方法可以恢复执行.\n***实现async函数的代码***\n```javascript\nasync function fn(args){\n  //...\n} \n等同于 \nfunction fn(args){\n  return genExec(function*(){\n  //...\n  })\n}\n\n```\n函数genExec是一个返回值为promise对象的自动执行函数.\n```javascript\nfunction genExec(genF){\n   return new Promise((resolve,reject)=>{\n    var gen = genF()\n    function next(nextF){\n        try{\n          var ne = nextF()\n        }catch(e){\n          return reject(e)\n        }\n        if(ne.done){\n          resolve(ne.value)\n        }else{\n          Promise.resolve(ne.value).then(v=>{\n            next(function(){return gen.next(v)})\n          },e=>{\n            next(function(){ return gen.throw(e)})\n          })\n        }\n    }\n    next(function(){ return gen.next(undefined)})\n   \n    })\n}\n```\n综上所述，源代码可以更改为如下:\n```javascript\nfunction asyncPrint(value,ms){\n  return genExec(function*(){\n    yield timeout(ms)\n    console.log(value)\n  })\n}\n```\n","source":"_posts/async.md","raw":"---\ntitle: 实现ES7中的async\ndate: 2017-04-07 15:37:38\ntags: [javascript]\n---\nasync函数是为了使得异步操作更加方便而引入的.async是什么？它就是Generator函数的语法糖，即自动执行的generator函数.\n***基本用法***\n**async**函数返回一个Promise对象，可以使用**then**方法添加回调函数.\n在函数执行的时候，遇到**await**就会先返回，等到异步操作完成，再接着执行函数体内后面的语句.<!--more-->\n一段示例代码如下:\n```js\nfunction timeout(ms){\n  return new Promise(function(resolve)=>{\n    setTimeout(resolve,ms)\n  })\n}\nasync function asyncPrint(value,ms){\n  await timeout(ms)\n  console.log(value)\n}\nasyncPrint('hello world',50)\n```\n上述代码 50ms之后输出**hello world**.\n***实现async函数所需要知道的***\n1. 首先，我们需要知道执行async函数后发生了什么？\n   返回一个promise对象，内部封装了一个自动执行的generator函数\n2. 如何实现自动执行的generator函数？\n   generator函数返回的是一个iterator对象，有一个value属性和一个next()方法.\n3. generator函数内部是怎样的呢？\n   generator函数内部是一个带有yield语句的普通函数.yield语句是暂停执行的标记，而next方法可以恢复执行.\n***实现async函数的代码***\n```javascript\nasync function fn(args){\n  //...\n} \n等同于 \nfunction fn(args){\n  return genExec(function*(){\n  //...\n  })\n}\n\n```\n函数genExec是一个返回值为promise对象的自动执行函数.\n```javascript\nfunction genExec(genF){\n   return new Promise((resolve,reject)=>{\n    var gen = genF()\n    function next(nextF){\n        try{\n          var ne = nextF()\n        }catch(e){\n          return reject(e)\n        }\n        if(ne.done){\n          resolve(ne.value)\n        }else{\n          Promise.resolve(ne.value).then(v=>{\n            next(function(){return gen.next(v)})\n          },e=>{\n            next(function(){ return gen.throw(e)})\n          })\n        }\n    }\n    next(function(){ return gen.next(undefined)})\n   \n    })\n}\n```\n综上所述，源代码可以更改为如下:\n```javascript\nfunction asyncPrint(value,ms){\n  return genExec(function*(){\n    yield timeout(ms)\n    console.log(value)\n  })\n}\n```\n","slug":"async","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4qi0003oejxyiectf7r","content":"<p>async函数是为了使得异步操作更加方便而引入的.async是什么？它就是Generator函数的语法糖，即自动执行的generator函数.<br><strong><em>基本用法</em></strong><br><strong>async</strong>函数返回一个Promise对象，可以使用<strong>then</strong>方法添加回调函数.<br>在函数执行的时候，遇到<strong>await</strong>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句.<a id=\"more\"></a><br>一段示例代码如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)=&gt;</span>&#123;</div><div class=\"line\">    setTimeout(resolve,ms)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value,ms</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">await</span> timeout(ms)</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">&#125;</div><div class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>,<span class=\"number\">50</span>)</div></pre></td></tr></table></figure></p>\n<p>上述代码 50ms之后输出<strong>hello world</strong>.<br><strong><em>实现async函数所需要知道的</em></strong></p>\n<ol>\n<li>首先，我们需要知道执行async函数后发生了什么？<br>返回一个promise对象，内部封装了一个自动执行的generator函数</li>\n<li>如何实现自动执行的generator函数？<br>generator函数返回的是一个iterator对象，有一个value属性和一个next()方法.</li>\n<li>generator函数内部是怎样的呢？<br>generator函数内部是一个带有yield语句的普通函数.yield语句是暂停执行的标记，而next方法可以恢复执行.<br><strong><em>实现async函数的代码</em></strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125; </div><div class=\"line\">等同于 </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> genExec(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>函数genExec是一个返回值为promise对象的自动执行函数.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genExec</span>(<span class=\"params\">genF</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> gen = genF()</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">nextF</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">          <span class=\"keyword\">var</span> ne = nextF()</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> reject(e)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(ne.done)&#123;</div><div class=\"line\">          resolve(ne.value)</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">          <span class=\"built_in\">Promise</span>.resolve(ne.value).then(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span>&#123;</div><div class=\"line\">            next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> gen.next(v)&#125;)</div><div class=\"line\">          &#125;,e=&gt;&#123;</div><div class=\"line\">            next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> gen.throw(e)&#125;)</div><div class=\"line\">          &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> gen.next(<span class=\"literal\">undefined</span>)&#125;)</div><div class=\"line\">   </div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>综上所述，源代码可以更改为如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value,ms</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> genExec(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> timeout(ms)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>async函数是为了使得异步操作更加方便而引入的.async是什么？它就是Generator函数的语法糖，即自动执行的generator函数.<br><strong><em>基本用法</em></strong><br><strong>async</strong>函数返回一个Promise对象，可以使用<strong>then</strong>方法添加回调函数.<br>在函数执行的时候，遇到<strong>await</strong>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句.","more":"<br>一段示例代码如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)=&gt;</span>&#123;</div><div class=\"line\">    setTimeout(resolve,ms)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value,ms</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">await</span> timeout(ms)</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">&#125;</div><div class=\"line\">asyncPrint(<span class=\"string\">'hello world'</span>,<span class=\"number\">50</span>)</div></pre></td></tr></table></figure></p>\n<p>上述代码 50ms之后输出<strong>hello world</strong>.<br><strong><em>实现async函数所需要知道的</em></strong></p>\n<ol>\n<li>首先，我们需要知道执行async函数后发生了什么？<br>返回一个promise对象，内部封装了一个自动执行的generator函数</li>\n<li>如何实现自动执行的generator函数？<br>generator函数返回的是一个iterator对象，有一个value属性和一个next()方法.</li>\n<li>generator函数内部是怎样的呢？<br>generator函数内部是一个带有yield语句的普通函数.yield语句是暂停执行的标记，而next方法可以恢复执行.<br><strong><em>实现async函数的代码</em></strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125; </div><div class=\"line\">等同于 </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> genExec(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>函数genExec是一个返回值为promise对象的自动执行函数.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genExec</span>(<span class=\"params\">genF</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> gen = genF()</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">nextF</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">          <span class=\"keyword\">var</span> ne = nextF()</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> reject(e)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(ne.done)&#123;</div><div class=\"line\">          resolve(ne.value)</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">          <span class=\"built_in\">Promise</span>.resolve(ne.value).then(<span class=\"function\"><span class=\"params\">v</span>=&gt;</span>&#123;</div><div class=\"line\">            next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> gen.next(v)&#125;)</div><div class=\"line\">          &#125;,e=&gt;&#123;</div><div class=\"line\">            next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> gen.throw(e)&#125;)</div><div class=\"line\">          &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    next(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> gen.next(<span class=\"literal\">undefined</span>)&#125;)</div><div class=\"line\">   </div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>综上所述，源代码可以更改为如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value,ms</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> genExec(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> timeout(ms)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(value)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"canvas学习之旅","date":"2016-09-15T11:16:30.000Z","_content":"canvas之前有过一点点了解，最近看到了一些很酷的demo，好佩服～所以从今天开始好好看看html5的canvas.Yeah~<!--more-->\n***canvas***\n\n### 基本知识\n* context: var context = canvas.getContext(‘2d’)\n* context.fill() 填充 context.stroke() 绘制边框\n* context.fillStyle()填充样式 context.strokeStyle()边框样式\n* context.lineWidth()图形边框宽度\n* 绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)\n* 清除矩形区域 context.clearRect(x,y,width,height)\n* 圆弧context.arc(x,y,radius,starAngle,endAngle,anticlockwise)\n* 路径context.beginPath() context.closePath() 如果画完前面的路径没有指定beginPath，那么画其他路径时候会将前面指定的beginPath重新绘制\n* 绘制线段 context.moveTo(x,y) context.lineTo(x,y)每次画线都从moveTo的点到lineTo的点\n* 线性渐变 var lg=context.createLinearGradient(xStart,yStart,xEnd,yEnd)\n* 线性渐变颜色 lg.addColorStop(offset,color)\n* 径向渐变(发散) var rg=context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)\n* 径向渐变颜色:rg.addColorStop(offset,color)\n* 图形变形\n1. 平移context.translate(x,y) x:坐标原点向x轴方向平移X y：坐标原点向y轴方向平移y\n2. 缩放context.scale(x,y) x:x坐标轴按x比例缩放，y:y坐标轴按y比例缩放\n3. 旋转context.rotate(angle) angle:坐标轴旋转x角度\n4. 矩阵变换context.transform(a,b,c,d,e,f);\na:水平缩放绘图\nb:水平倾斜绘图\nc:垂直倾斜绘图\nd:垂直缩放绘图\ne:水平移动绘图\nf:垂直移动绘图\n* 图形组合 cotext.globalCompositeOperation=type\n1. source-over: 在原有图形上绘制新图形\n2. destination-over:在原有图形下绘制新图形\n3. source-in:显示原图与新图的交集，新图在上\n4. destination-in:显示交集，原图在上\n5. source-out：显示新图形非交集部分\n6. destination-out:显示原图形非交集部分\n7. source-atop:显示原有图形和交集部分，新图形在上\n8. destination-atop:显示新图形和交集部分，原图在上\n9. lighter:原有图形和新图形都显示，交集部分做颜色叠加\n10. xor：显示非交集部分\n11. copy:只显示新图形\n* 绘制阴影\n1. context.shadowOffsetX:阴影的横向位移量\n2. context.shadowOffsetY:阴影的纵向位移量\n3. context.shadowColor:阴影的颜色\n4. context.shadowBlur:阴影的模糊范围\n* 绘制文字\n1. 填充文字:context.fillText(text,x,y)\n2. 绘制文字轮廓:context.strokeText(text,x,y)\n  text:要绘制的文字\n　　x:文字起点的x坐标轴\n　　y:文字起点的y坐标轴\n　　context.font:设置字体样式\n　　context.textAlign:水平对齐方式: start、end、right、center\n　　context.textBaseline:垂直对齐方式:top、hanging、middle、bottom\n　　var length=context.measureText(text):计算字体长度(px)\n\n* 保存和恢复状态\n　　保存:context.save() 调用该方法,会保存当前context的状态、属性\n　　恢复:context.restore()　调用该方法就能恢复到savｅ时候context的状态、属性\n　   保存文件　canvas.toDataURL()\n总结就是今天暂时把基础知识看完了，跟着做了一些demo\n接下来做几个有意思的动画巩固一下，代码顺便传到github上去\n","source":"_posts/canvas.md","raw":"---\ntitle: canvas学习之旅\ndate: 2016-09-15 04:16:30\ntags: [canvas]\n---\ncanvas之前有过一点点了解，最近看到了一些很酷的demo，好佩服～所以从今天开始好好看看html5的canvas.Yeah~<!--more-->\n***canvas***\n\n### 基本知识\n* context: var context = canvas.getContext(‘2d’)\n* context.fill() 填充 context.stroke() 绘制边框\n* context.fillStyle()填充样式 context.strokeStyle()边框样式\n* context.lineWidth()图形边框宽度\n* 绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)\n* 清除矩形区域 context.clearRect(x,y,width,height)\n* 圆弧context.arc(x,y,radius,starAngle,endAngle,anticlockwise)\n* 路径context.beginPath() context.closePath() 如果画完前面的路径没有指定beginPath，那么画其他路径时候会将前面指定的beginPath重新绘制\n* 绘制线段 context.moveTo(x,y) context.lineTo(x,y)每次画线都从moveTo的点到lineTo的点\n* 线性渐变 var lg=context.createLinearGradient(xStart,yStart,xEnd,yEnd)\n* 线性渐变颜色 lg.addColorStop(offset,color)\n* 径向渐变(发散) var rg=context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)\n* 径向渐变颜色:rg.addColorStop(offset,color)\n* 图形变形\n1. 平移context.translate(x,y) x:坐标原点向x轴方向平移X y：坐标原点向y轴方向平移y\n2. 缩放context.scale(x,y) x:x坐标轴按x比例缩放，y:y坐标轴按y比例缩放\n3. 旋转context.rotate(angle) angle:坐标轴旋转x角度\n4. 矩阵变换context.transform(a,b,c,d,e,f);\na:水平缩放绘图\nb:水平倾斜绘图\nc:垂直倾斜绘图\nd:垂直缩放绘图\ne:水平移动绘图\nf:垂直移动绘图\n* 图形组合 cotext.globalCompositeOperation=type\n1. source-over: 在原有图形上绘制新图形\n2. destination-over:在原有图形下绘制新图形\n3. source-in:显示原图与新图的交集，新图在上\n4. destination-in:显示交集，原图在上\n5. source-out：显示新图形非交集部分\n6. destination-out:显示原图形非交集部分\n7. source-atop:显示原有图形和交集部分，新图形在上\n8. destination-atop:显示新图形和交集部分，原图在上\n9. lighter:原有图形和新图形都显示，交集部分做颜色叠加\n10. xor：显示非交集部分\n11. copy:只显示新图形\n* 绘制阴影\n1. context.shadowOffsetX:阴影的横向位移量\n2. context.shadowOffsetY:阴影的纵向位移量\n3. context.shadowColor:阴影的颜色\n4. context.shadowBlur:阴影的模糊范围\n* 绘制文字\n1. 填充文字:context.fillText(text,x,y)\n2. 绘制文字轮廓:context.strokeText(text,x,y)\n  text:要绘制的文字\n　　x:文字起点的x坐标轴\n　　y:文字起点的y坐标轴\n　　context.font:设置字体样式\n　　context.textAlign:水平对齐方式: start、end、right、center\n　　context.textBaseline:垂直对齐方式:top、hanging、middle、bottom\n　　var length=context.measureText(text):计算字体长度(px)\n\n* 保存和恢复状态\n　　保存:context.save() 调用该方法,会保存当前context的状态、属性\n　　恢复:context.restore()　调用该方法就能恢复到savｅ时候context的状态、属性\n　   保存文件　canvas.toDataURL()\n总结就是今天暂时把基础知识看完了，跟着做了一些demo\n接下来做几个有意思的动画巩固一下，代码顺便传到github上去\n","slug":"canvas","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4qr0004oejxk8sm5nat","content":"<p>canvas之前有过一点点了解，最近看到了一些很酷的demo，好佩服～所以从今天开始好好看看html5的canvas.Yeah~<a id=\"more\"></a><br><strong><em>canvas</em></strong></p>\n<h3 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h3><ul>\n<li>context: var context = canvas.getContext(‘2d’)</li>\n<li>context.fill() 填充 context.stroke() 绘制边框</li>\n<li>context.fillStyle()填充样式 context.strokeStyle()边框样式</li>\n<li>context.lineWidth()图形边框宽度</li>\n<li>绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)</li>\n<li>清除矩形区域 context.clearRect(x,y,width,height)</li>\n<li>圆弧context.arc(x,y,radius,starAngle,endAngle,anticlockwise)</li>\n<li>路径context.beginPath() context.closePath() 如果画完前面的路径没有指定beginPath，那么画其他路径时候会将前面指定的beginPath重新绘制</li>\n<li>绘制线段 context.moveTo(x,y) context.lineTo(x,y)每次画线都从moveTo的点到lineTo的点</li>\n<li>线性渐变 var lg=context.createLinearGradient(xStart,yStart,xEnd,yEnd)</li>\n<li>线性渐变颜色 lg.addColorStop(offset,color)</li>\n<li>径向渐变(发散) var rg=context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)</li>\n<li>径向渐变颜色:rg.addColorStop(offset,color)</li>\n<li>图形变形</li>\n</ul>\n<ol>\n<li>平移context.translate(x,y) x:坐标原点向x轴方向平移X y：坐标原点向y轴方向平移y</li>\n<li>缩放context.scale(x,y) x:x坐标轴按x比例缩放，y:y坐标轴按y比例缩放</li>\n<li>旋转context.rotate(angle) angle:坐标轴旋转x角度</li>\n<li>矩阵变换context.transform(a,b,c,d,e,f);<br>a:水平缩放绘图<br>b:水平倾斜绘图<br>c:垂直倾斜绘图<br>d:垂直缩放绘图<br>e:水平移动绘图<br>f:垂直移动绘图</li>\n</ol>\n<ul>\n<li>图形组合 cotext.globalCompositeOperation=type</li>\n</ul>\n<ol>\n<li>source-over: 在原有图形上绘制新图形</li>\n<li>destination-over:在原有图形下绘制新图形</li>\n<li>source-in:显示原图与新图的交集，新图在上</li>\n<li>destination-in:显示交集，原图在上</li>\n<li>source-out：显示新图形非交集部分</li>\n<li>destination-out:显示原图形非交集部分</li>\n<li>source-atop:显示原有图形和交集部分，新图形在上</li>\n<li>destination-atop:显示新图形和交集部分，原图在上</li>\n<li>lighter:原有图形和新图形都显示，交集部分做颜色叠加</li>\n<li>xor：显示非交集部分</li>\n<li>copy:只显示新图形</li>\n</ol>\n<ul>\n<li>绘制阴影</li>\n</ul>\n<ol>\n<li>context.shadowOffsetX:阴影的横向位移量</li>\n<li>context.shadowOffsetY:阴影的纵向位移量</li>\n<li>context.shadowColor:阴影的颜色</li>\n<li>context.shadowBlur:阴影的模糊范围</li>\n</ol>\n<ul>\n<li>绘制文字</li>\n</ul>\n<ol>\n<li>填充文字:context.fillText(text,x,y)</li>\n<li>绘制文字轮廓:context.strokeText(text,x,y)<br>text:要绘制的文字<br>　　x:文字起点的x坐标轴<br>　　y:文字起点的y坐标轴<br>　　context.font:设置字体样式<br>　　context.textAlign:水平对齐方式: start、end、right、center<br>　　context.textBaseline:垂直对齐方式:top、hanging、middle、bottom<br>　　var length=context.measureText(text):计算字体长度(px)</li>\n</ol>\n<ul>\n<li>保存和恢复状态<br>　　保存:context.save() 调用该方法,会保存当前context的状态、属性<br>　　恢复:context.restore()　调用该方法就能恢复到savｅ时候context的状态、属性<br>　   保存文件　canvas.toDataURL()<br>总结就是今天暂时把基础知识看完了，跟着做了一些demo<br>接下来做几个有意思的动画巩固一下，代码顺便传到github上去</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>canvas之前有过一点点了解，最近看到了一些很酷的demo，好佩服～所以从今天开始好好看看html5的canvas.Yeah~","more":"<br><strong><em>canvas</em></strong></p>\n<h3 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h3><ul>\n<li>context: var context = canvas.getContext(‘2d’)</li>\n<li>context.fill() 填充 context.stroke() 绘制边框</li>\n<li>context.fillStyle()填充样式 context.strokeStyle()边框样式</li>\n<li>context.lineWidth()图形边框宽度</li>\n<li>绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)</li>\n<li>清除矩形区域 context.clearRect(x,y,width,height)</li>\n<li>圆弧context.arc(x,y,radius,starAngle,endAngle,anticlockwise)</li>\n<li>路径context.beginPath() context.closePath() 如果画完前面的路径没有指定beginPath，那么画其他路径时候会将前面指定的beginPath重新绘制</li>\n<li>绘制线段 context.moveTo(x,y) context.lineTo(x,y)每次画线都从moveTo的点到lineTo的点</li>\n<li>线性渐变 var lg=context.createLinearGradient(xStart,yStart,xEnd,yEnd)</li>\n<li>线性渐变颜色 lg.addColorStop(offset,color)</li>\n<li>径向渐变(发散) var rg=context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)</li>\n<li>径向渐变颜色:rg.addColorStop(offset,color)</li>\n<li>图形变形</li>\n</ul>\n<ol>\n<li>平移context.translate(x,y) x:坐标原点向x轴方向平移X y：坐标原点向y轴方向平移y</li>\n<li>缩放context.scale(x,y) x:x坐标轴按x比例缩放，y:y坐标轴按y比例缩放</li>\n<li>旋转context.rotate(angle) angle:坐标轴旋转x角度</li>\n<li>矩阵变换context.transform(a,b,c,d,e,f);<br>a:水平缩放绘图<br>b:水平倾斜绘图<br>c:垂直倾斜绘图<br>d:垂直缩放绘图<br>e:水平移动绘图<br>f:垂直移动绘图</li>\n</ol>\n<ul>\n<li>图形组合 cotext.globalCompositeOperation=type</li>\n</ul>\n<ol>\n<li>source-over: 在原有图形上绘制新图形</li>\n<li>destination-over:在原有图形下绘制新图形</li>\n<li>source-in:显示原图与新图的交集，新图在上</li>\n<li>destination-in:显示交集，原图在上</li>\n<li>source-out：显示新图形非交集部分</li>\n<li>destination-out:显示原图形非交集部分</li>\n<li>source-atop:显示原有图形和交集部分，新图形在上</li>\n<li>destination-atop:显示新图形和交集部分，原图在上</li>\n<li>lighter:原有图形和新图形都显示，交集部分做颜色叠加</li>\n<li>xor：显示非交集部分</li>\n<li>copy:只显示新图形</li>\n</ol>\n<ul>\n<li>绘制阴影</li>\n</ul>\n<ol>\n<li>context.shadowOffsetX:阴影的横向位移量</li>\n<li>context.shadowOffsetY:阴影的纵向位移量</li>\n<li>context.shadowColor:阴影的颜色</li>\n<li>context.shadowBlur:阴影的模糊范围</li>\n</ol>\n<ul>\n<li>绘制文字</li>\n</ul>\n<ol>\n<li>填充文字:context.fillText(text,x,y)</li>\n<li>绘制文字轮廓:context.strokeText(text,x,y)<br>text:要绘制的文字<br>　　x:文字起点的x坐标轴<br>　　y:文字起点的y坐标轴<br>　　context.font:设置字体样式<br>　　context.textAlign:水平对齐方式: start、end、right、center<br>　　context.textBaseline:垂直对齐方式:top、hanging、middle、bottom<br>　　var length=context.measureText(text):计算字体长度(px)</li>\n</ol>\n<ul>\n<li>保存和恢复状态<br>　　保存:context.save() 调用该方法,会保存当前context的状态、属性<br>　　恢复:context.restore()　调用该方法就能恢复到savｅ时候context的状态、属性<br>　   保存文件　canvas.toDataURL()<br>总结就是今天暂时把基础知识看完了，跟着做了一些demo<br>接下来做几个有意思的动画巩固一下，代码顺便传到github上去</li>\n</ul>"},{"title":"Javascript自定义事件","date":"2017-03-23T16:22:15.000Z","_content":"###原生事件监听器注册方法\n首先，Js中自带的事件监听函数是window.addEventListener(type,callback,false/true),IE可能不支持需要用element.attachEvent(type,callback)\n但是，这个监听器只可以对特定的时间进行监听，无法实现自定义事件监听。\n所以我们可以写出一个具有兼容性的addlistener函数，代码如下：<!--more-->\n```javascript\nfunction addlistener(el,type,callback,flag){\n  if(el.addEventListener){\n    el.addEventListener(type,callback,flag)\n  }else if(el.attachEvent){\n    el.attachEvent('on'+type,callback)\n  }\n}\n```\n###自定义事件\n因此，我们需要自己去实现一个事件监听器注册的函数，解析在代码的注释中，直接上代码：\n```javascript\nfunction EventTarget(){\n  this.handlers={} //用来存储事件相对应的callback\n}\nEventTarget.prototype={\n  constructor:EventTarget,\n  add(type,callback){\n      if(!this.handlers[type]){\n        this.handlers[type]=[callback]\n        \n      }else{\n        this.handlers[type].push(callback)\n      }\n  },\n  fire(type){\n    console.log(this.handlers[type])\n    if(this.handlers[type].length!=0 ){\n      var handlers = this.handlers[type]\n      for(var i=0;i<handlers.length;i++){\n        handlers[i]()\n      }\n    }else{\n      console.log(`no this ${type} function`)\n    }\n    \n  },\n  remove(type,handle){\n    if(this.handlers[type] !=undefined){\n      var handlers=this.handlers[type]\n      \n      for(var i=0;i<handlers.length;i++){\n        if(handlers[i]==handler){\n          break;\n        }\n      }\n      handlers.splice(i,1)\n    }else{\n      console.log('error')\n    }\n  }\n}\nvar event = new EventTarget()\nvar handler = function(){\n  console.log('haha')\n}\nevent.add('test',handler)\nevent.fire('test')\nevent.remove('test',handler)\nevent.fire('test')\n```\n","source":"_posts/eventTarget.md","raw":"---\ntitle: Javascript自定义事件\ndate: 2017-03-23 09:22:15\ntags: [javascript]\n---\n###原生事件监听器注册方法\n首先，Js中自带的事件监听函数是window.addEventListener(type,callback,false/true),IE可能不支持需要用element.attachEvent(type,callback)\n但是，这个监听器只可以对特定的时间进行监听，无法实现自定义事件监听。\n所以我们可以写出一个具有兼容性的addlistener函数，代码如下：<!--more-->\n```javascript\nfunction addlistener(el,type,callback,flag){\n  if(el.addEventListener){\n    el.addEventListener(type,callback,flag)\n  }else if(el.attachEvent){\n    el.attachEvent('on'+type,callback)\n  }\n}\n```\n###自定义事件\n因此，我们需要自己去实现一个事件监听器注册的函数，解析在代码的注释中，直接上代码：\n```javascript\nfunction EventTarget(){\n  this.handlers={} //用来存储事件相对应的callback\n}\nEventTarget.prototype={\n  constructor:EventTarget,\n  add(type,callback){\n      if(!this.handlers[type]){\n        this.handlers[type]=[callback]\n        \n      }else{\n        this.handlers[type].push(callback)\n      }\n  },\n  fire(type){\n    console.log(this.handlers[type])\n    if(this.handlers[type].length!=0 ){\n      var handlers = this.handlers[type]\n      for(var i=0;i<handlers.length;i++){\n        handlers[i]()\n      }\n    }else{\n      console.log(`no this ${type} function`)\n    }\n    \n  },\n  remove(type,handle){\n    if(this.handlers[type] !=undefined){\n      var handlers=this.handlers[type]\n      \n      for(var i=0;i<handlers.length;i++){\n        if(handlers[i]==handler){\n          break;\n        }\n      }\n      handlers.splice(i,1)\n    }else{\n      console.log('error')\n    }\n  }\n}\nvar event = new EventTarget()\nvar handler = function(){\n  console.log('haha')\n}\nevent.add('test',handler)\nevent.fire('test')\nevent.remove('test',handler)\nevent.fire('test')\n```\n","slug":"eventTarget","published":1,"updated":"2017-04-20T22:41:10.043Z","_id":"cj1qyv4qs0005oejx9iquinfg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>###原生事件监听器注册方法<br>首先，Js中自带的事件监听函数是window.addEventListener(type,callback,false/true),IE可能不支持需要用element.attachEvent(type,callback)<br>但是，这个监听器只可以对特定的时间进行监听，无法实现自定义事件监听。<br>所以我们可以写出一个具有兼容性的addlistener函数，代码如下：<a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addlistener</span>(<span class=\"params\">el,type,callback,flag</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(el.addEventListener)&#123;</div><div class=\"line\">    el.addEventListener(type,callback,flag)</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(el.attachEvent)&#123;</div><div class=\"line\">    el.attachEvent(<span class=\"string\">'on'</span>+type,callback)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>###自定义事件<br>因此，我们需要自己去实现一个事件监听器注册的函数，解析在代码的注释中，直接上代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">EventTarget</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.handlers=&#123;&#125; <span class=\"comment\">//用来存储事件相对应的callback</span></div><div class=\"line\">&#125;</div><div class=\"line\">EventTarget.prototype=&#123;</div><div class=\"line\">  <span class=\"attr\">constructor</span>:EventTarget,</div><div class=\"line\">  add(type,callback)&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.handlers[type])&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.handlers[type]=[callback]</div><div class=\"line\">        </div><div class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.handlers[type].push(callback)</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  fire(type)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.handlers[type])</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.handlers[type].length!=<span class=\"number\">0</span> )&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> handlers = <span class=\"keyword\">this</span>.handlers[type]</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;handlers.length;i++)&#123;</div><div class=\"line\">        handlers[i]()</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`no this <span class=\"subst\">$&#123;type&#125;</span> function`</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">  &#125;,</div><div class=\"line\">  remove(type,handle)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.handlers[type] !=<span class=\"literal\">undefined</span>)&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> handlers=<span class=\"keyword\">this</span>.handlers[type]</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;handlers.length;i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(handlers[i]==handler)&#123;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      handlers.splice(i,<span class=\"number\">1</span>)</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> EventTarget()</div><div class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'haha'</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">event.add(<span class=\"string\">'test'</span>,handler)</div><div class=\"line\">event.fire(<span class=\"string\">'test'</span>)</div><div class=\"line\">event.remove(<span class=\"string\">'test'</span>,handler)</div><div class=\"line\">event.fire(<span class=\"string\">'test'</span>)</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>###原生事件监听器注册方法<br>首先，Js中自带的事件监听函数是window.addEventListener(type,callback,false/true),IE可能不支持需要用element.attachEvent(type,callback)<br>但是，这个监听器只可以对特定的时间进行监听，无法实现自定义事件监听。<br>所以我们可以写出一个具有兼容性的addlistener函数，代码如下：","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addlistener</span>(<span class=\"params\">el,type,callback,flag</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(el.addEventListener)&#123;</div><div class=\"line\">    el.addEventListener(type,callback,flag)</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(el.attachEvent)&#123;</div><div class=\"line\">    el.attachEvent(<span class=\"string\">'on'</span>+type,callback)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>###自定义事件<br>因此，我们需要自己去实现一个事件监听器注册的函数，解析在代码的注释中，直接上代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">EventTarget</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.handlers=&#123;&#125; <span class=\"comment\">//用来存储事件相对应的callback</span></div><div class=\"line\">&#125;</div><div class=\"line\">EventTarget.prototype=&#123;</div><div class=\"line\">  <span class=\"attr\">constructor</span>:EventTarget,</div><div class=\"line\">  add(type,callback)&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.handlers[type])&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.handlers[type]=[callback]</div><div class=\"line\">        </div><div class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.handlers[type].push(callback)</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  fire(type)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.handlers[type])</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.handlers[type].length!=<span class=\"number\">0</span> )&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> handlers = <span class=\"keyword\">this</span>.handlers[type]</div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;handlers.length;i++)&#123;</div><div class=\"line\">        handlers[i]()</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`no this <span class=\"subst\">$&#123;type&#125;</span> function`</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">  &#125;,</div><div class=\"line\">  remove(type,handle)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.handlers[type] !=<span class=\"literal\">undefined</span>)&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> handlers=<span class=\"keyword\">this</span>.handlers[type]</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;handlers.length;i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(handlers[i]==handler)&#123;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      handlers.splice(i,<span class=\"number\">1</span>)</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> EventTarget()</div><div class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'haha'</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">event.add(<span class=\"string\">'test'</span>,handler)</div><div class=\"line\">event.fire(<span class=\"string\">'test'</span>)</div><div class=\"line\">event.remove(<span class=\"string\">'test'</span>,handler)</div><div class=\"line\">event.fire(<span class=\"string\">'test'</span>)</div></pre></td></tr></table></figure></p>"},{"title":"Express的简单实现","date":"2016-11-13T11:07:07.000Z","_content":"最近在写express框架的简单实现，其中的next，开始的时候总是想不明白，仔细看了源码后，理解了代码的含义。<!--more-->\n### Express\nExress 是 基于connect的Nodejs框架，核心功能就是中间件.\n简单的express框架实现主要是对app.use,app.hindle,app.listen的实现\n先给出express.js app的定义\n```javascript\nlet _proto={}\nfunction createServer(){\n    function app(req,res,next){\n        app.handle(req,res,next)\n    }\n    Object.assign(app,_proto)\n    Object.assign(app,EventEmitter.prototype)\n    app._route='/'\n    app._stack=[]\n    return app\n}\n```\napp是一个函数，参数列表为req,res,next。我开始纠结的是next是在什么时候被作为参数传递进来的，源码看了好久，最后才明白。当存在子app的时候，next在上一个handle函数传给子app.handle(req,res,next).开始的时候next参数为空. 通过不断调用handle内部的next()函数 传递next\n### app.use\n代码如下：\n```javascript\n_proto.use=function(route,fn){\n    if(typeof route!=='string'){\n        fn=route\n        route='/'\n    }\n    if(typeof fn.handle==='function'){\n        fn._route=route\n        fn=fn.handle.bind(fn)\n    }\n    if(route[route.length-1]==='/')\n        route = route.slice(0,-1)\n    this._stack.push({route:route,handle:fn})\n    return this\n}\n```\napp.use这个函数的参数列表为route和fn，在app函数内定义了一个数组stack用来存储中间件，即路由和对应的回调函数。有一点需要注意，就是fn为子app的时候。\n### app.handle\n代码如下\n```javacript\n console.log(out)\n    let index = 0,\n        removed=''\n    let next= err =>{\n        \n        if(removed.length){\n            req.url = removed+req.url\n            removed = ''\n        }\n        let layer = this._stack[index++]\n        if(!layer){\n        console.log('out')\n            out && out(err)\n            return \n        }\n        let route = layer.route\n        if(req.url.substr(0,route.length).toLowerCase()!==route.toLowerCase())\n            return next(err)\n        let border = req.url[route.length]\n\n        if(border !== undefined && border !=='/')\n            return next(err)\n        if(route.length !==0 && route!=='/'){\n            req.url = req.url.substr(route.length)\n            removed = route\n            \n        }\n        let handle = layer.handle\n        if(err&&handle.length ===4)\n            return handle(err,req,res,next)\n        else if(!err && handle.length <4)\n            return handle(req,res,next)\n        next(err)\n    }\n    next()\n}\n```\n### app.listen\n代码如下:\n```javascript\n_proto.listen=function(...args){\n    const server = http.createServer(this)\n    return server.listen.apply(server,args)\n}\n```\n代码很简单 调用http.createServer(this) // app 是一个函数 。\n最后一句 server.listen.apply(server,args) //这里用apply的原因是 listen内部可能用到server的this指代，所以用apply() 用 server代替this.\n\n总结： 通过看源码收获了很多，不仅仅知道了next（）什么时候用，怎么用，更是明白了express底层的机制原理！\n","source":"_posts/express.md","raw":"---\ntitle: Express的简单实现\ndate: 2016-11-13 03:07:07\ntags: [javascript]\n---\n最近在写express框架的简单实现，其中的next，开始的时候总是想不明白，仔细看了源码后，理解了代码的含义。<!--more-->\n### Express\nExress 是 基于connect的Nodejs框架，核心功能就是中间件.\n简单的express框架实现主要是对app.use,app.hindle,app.listen的实现\n先给出express.js app的定义\n```javascript\nlet _proto={}\nfunction createServer(){\n    function app(req,res,next){\n        app.handle(req,res,next)\n    }\n    Object.assign(app,_proto)\n    Object.assign(app,EventEmitter.prototype)\n    app._route='/'\n    app._stack=[]\n    return app\n}\n```\napp是一个函数，参数列表为req,res,next。我开始纠结的是next是在什么时候被作为参数传递进来的，源码看了好久，最后才明白。当存在子app的时候，next在上一个handle函数传给子app.handle(req,res,next).开始的时候next参数为空. 通过不断调用handle内部的next()函数 传递next\n### app.use\n代码如下：\n```javascript\n_proto.use=function(route,fn){\n    if(typeof route!=='string'){\n        fn=route\n        route='/'\n    }\n    if(typeof fn.handle==='function'){\n        fn._route=route\n        fn=fn.handle.bind(fn)\n    }\n    if(route[route.length-1]==='/')\n        route = route.slice(0,-1)\n    this._stack.push({route:route,handle:fn})\n    return this\n}\n```\napp.use这个函数的参数列表为route和fn，在app函数内定义了一个数组stack用来存储中间件，即路由和对应的回调函数。有一点需要注意，就是fn为子app的时候。\n### app.handle\n代码如下\n```javacript\n console.log(out)\n    let index = 0,\n        removed=''\n    let next= err =>{\n        \n        if(removed.length){\n            req.url = removed+req.url\n            removed = ''\n        }\n        let layer = this._stack[index++]\n        if(!layer){\n        console.log('out')\n            out && out(err)\n            return \n        }\n        let route = layer.route\n        if(req.url.substr(0,route.length).toLowerCase()!==route.toLowerCase())\n            return next(err)\n        let border = req.url[route.length]\n\n        if(border !== undefined && border !=='/')\n            return next(err)\n        if(route.length !==0 && route!=='/'){\n            req.url = req.url.substr(route.length)\n            removed = route\n            \n        }\n        let handle = layer.handle\n        if(err&&handle.length ===4)\n            return handle(err,req,res,next)\n        else if(!err && handle.length <4)\n            return handle(req,res,next)\n        next(err)\n    }\n    next()\n}\n```\n### app.listen\n代码如下:\n```javascript\n_proto.listen=function(...args){\n    const server = http.createServer(this)\n    return server.listen.apply(server,args)\n}\n```\n代码很简单 调用http.createServer(this) // app 是一个函数 。\n最后一句 server.listen.apply(server,args) //这里用apply的原因是 listen内部可能用到server的this指代，所以用apply() 用 server代替this.\n\n总结： 通过看源码收获了很多，不仅仅知道了next（）什么时候用，怎么用，更是明白了express底层的机制原理！\n","slug":"express","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4qx0008oejxlcql8spc","content":"<p>最近在写express框架的简单实现，其中的next，开始的时候总是想不明白，仔细看了源码后，理解了代码的含义。<a id=\"more\"></a></p>\n<h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><p>Exress 是 基于connect的Nodejs框架，核心功能就是中间件.<br>简单的express框架实现主要是对app.use,app.hindle,app.listen的实现<br>先给出express.js app的定义<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> _proto=&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createServer</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">app</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</div><div class=\"line\">        app.handle(req,res,next)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.assign(app,_proto)</div><div class=\"line\">    <span class=\"built_in\">Object</span>.assign(app,EventEmitter.prototype)</div><div class=\"line\">    app._route=<span class=\"string\">'/'</span></div><div class=\"line\">    app._stack=[]</div><div class=\"line\">    <span class=\"keyword\">return</span> app</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>app是一个函数，参数列表为req,res,next。我开始纠结的是next是在什么时候被作为参数传递进来的，源码看了好久，最后才明白。当存在子app的时候，next在上一个handle函数传给子app.handle(req,res,next).开始的时候next参数为空. 通过不断调用handle内部的next()函数 传递next</p>\n<h3 id=\"app-use\"><a href=\"#app-use\" class=\"headerlink\" title=\"app.use\"></a>app.use</h3><p>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">_proto.use=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">route,fn</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> route!==<span class=\"string\">'string'</span>)&#123;</div><div class=\"line\">        fn=route</div><div class=\"line\">        route=<span class=\"string\">'/'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fn.handle===<span class=\"string\">'function'</span>)&#123;</div><div class=\"line\">        fn._route=route</div><div class=\"line\">        fn=fn.handle.bind(fn)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(route[route.length<span class=\"number\">-1</span>]===<span class=\"string\">'/'</span>)</div><div class=\"line\">        route = route.slice(<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>._stack.push(&#123;<span class=\"attr\">route</span>:route,<span class=\"attr\">handle</span>:fn&#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>app.use这个函数的参数列表为route和fn，在app函数内定义了一个数组stack用来存储中间件，即路由和对应的回调函数。有一点需要注意，就是fn为子app的时候。</p>\n<h3 id=\"app-handle\"><a href=\"#app-handle\" class=\"headerlink\" title=\"app.handle\"></a>app.handle</h3><p>代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"> console.log(out)</div><div class=\"line\">    let index = 0,</div><div class=\"line\">        removed=&apos;&apos;</div><div class=\"line\">    let next= err =&gt;&#123;</div><div class=\"line\">        </div><div class=\"line\">        if(removed.length)&#123;</div><div class=\"line\">            req.url = removed+req.url</div><div class=\"line\">            removed = &apos;&apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">        let layer = this._stack[index++]</div><div class=\"line\">        if(!layer)&#123;</div><div class=\"line\">        console.log(&apos;out&apos;)</div><div class=\"line\">            out &amp;&amp; out(err)</div><div class=\"line\">            return </div><div class=\"line\">        &#125;</div><div class=\"line\">        let route = layer.route</div><div class=\"line\">        if(req.url.substr(0,route.length).toLowerCase()!==route.toLowerCase())</div><div class=\"line\">            return next(err)</div><div class=\"line\">        let border = req.url[route.length]</div><div class=\"line\"></div><div class=\"line\">        if(border !== undefined &amp;&amp; border !==&apos;/&apos;)</div><div class=\"line\">            return next(err)</div><div class=\"line\">        if(route.length !==0 &amp;&amp; route!==&apos;/&apos;)&#123;</div><div class=\"line\">            req.url = req.url.substr(route.length)</div><div class=\"line\">            removed = route</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        let handle = layer.handle</div><div class=\"line\">        if(err&amp;&amp;handle.length ===4)</div><div class=\"line\">            return handle(err,req,res,next)</div><div class=\"line\">        else if(!err &amp;&amp; handle.length &lt;4)</div><div class=\"line\">            return handle(req,res,next)</div><div class=\"line\">        next(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    next()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"app-listen\"><a href=\"#app-listen\" class=\"headerlink\" title=\"app.listen\"></a>app.listen</h3><p>代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_proto.listen=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> server = http.createServer(<span class=\"keyword\">this</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> server.listen.apply(server,args)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>代码很简单 调用http.createServer(this) // app 是一个函数 。<br>最后一句 server.listen.apply(server,args) //这里用apply的原因是 listen内部可能用到server的this指代，所以用apply() 用 server代替this.</p>\n<p>总结： 通过看源码收获了很多，不仅仅知道了next（）什么时候用，怎么用，更是明白了express底层的机制原理！</p>\n","site":{"data":{}},"excerpt":"<p>最近在写express框架的简单实现，其中的next，开始的时候总是想不明白，仔细看了源码后，理解了代码的含义。","more":"</p>\n<h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><p>Exress 是 基于connect的Nodejs框架，核心功能就是中间件.<br>简单的express框架实现主要是对app.use,app.hindle,app.listen的实现<br>先给出express.js app的定义<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> _proto=&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createServer</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">app</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</div><div class=\"line\">        app.handle(req,res,next)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.assign(app,_proto)</div><div class=\"line\">    <span class=\"built_in\">Object</span>.assign(app,EventEmitter.prototype)</div><div class=\"line\">    app._route=<span class=\"string\">'/'</span></div><div class=\"line\">    app._stack=[]</div><div class=\"line\">    <span class=\"keyword\">return</span> app</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>app是一个函数，参数列表为req,res,next。我开始纠结的是next是在什么时候被作为参数传递进来的，源码看了好久，最后才明白。当存在子app的时候，next在上一个handle函数传给子app.handle(req,res,next).开始的时候next参数为空. 通过不断调用handle内部的next()函数 传递next</p>\n<h3 id=\"app-use\"><a href=\"#app-use\" class=\"headerlink\" title=\"app.use\"></a>app.use</h3><p>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">_proto.use=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">route,fn</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> route!==<span class=\"string\">'string'</span>)&#123;</div><div class=\"line\">        fn=route</div><div class=\"line\">        route=<span class=\"string\">'/'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fn.handle===<span class=\"string\">'function'</span>)&#123;</div><div class=\"line\">        fn._route=route</div><div class=\"line\">        fn=fn.handle.bind(fn)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(route[route.length<span class=\"number\">-1</span>]===<span class=\"string\">'/'</span>)</div><div class=\"line\">        route = route.slice(<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>._stack.push(&#123;<span class=\"attr\">route</span>:route,<span class=\"attr\">handle</span>:fn&#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>app.use这个函数的参数列表为route和fn，在app函数内定义了一个数组stack用来存储中间件，即路由和对应的回调函数。有一点需要注意，就是fn为子app的时候。</p>\n<h3 id=\"app-handle\"><a href=\"#app-handle\" class=\"headerlink\" title=\"app.handle\"></a>app.handle</h3><p>代码如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"> console.log(out)</div><div class=\"line\">    let index = 0,</div><div class=\"line\">        removed=&apos;&apos;</div><div class=\"line\">    let next= err =&gt;&#123;</div><div class=\"line\">        </div><div class=\"line\">        if(removed.length)&#123;</div><div class=\"line\">            req.url = removed+req.url</div><div class=\"line\">            removed = &apos;&apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">        let layer = this._stack[index++]</div><div class=\"line\">        if(!layer)&#123;</div><div class=\"line\">        console.log(&apos;out&apos;)</div><div class=\"line\">            out &amp;&amp; out(err)</div><div class=\"line\">            return </div><div class=\"line\">        &#125;</div><div class=\"line\">        let route = layer.route</div><div class=\"line\">        if(req.url.substr(0,route.length).toLowerCase()!==route.toLowerCase())</div><div class=\"line\">            return next(err)</div><div class=\"line\">        let border = req.url[route.length]</div><div class=\"line\"></div><div class=\"line\">        if(border !== undefined &amp;&amp; border !==&apos;/&apos;)</div><div class=\"line\">            return next(err)</div><div class=\"line\">        if(route.length !==0 &amp;&amp; route!==&apos;/&apos;)&#123;</div><div class=\"line\">            req.url = req.url.substr(route.length)</div><div class=\"line\">            removed = route</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        let handle = layer.handle</div><div class=\"line\">        if(err&amp;&amp;handle.length ===4)</div><div class=\"line\">            return handle(err,req,res,next)</div><div class=\"line\">        else if(!err &amp;&amp; handle.length &lt;4)</div><div class=\"line\">            return handle(req,res,next)</div><div class=\"line\">        next(err)</div><div class=\"line\">    &#125;</div><div class=\"line\">    next()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"app-listen\"><a href=\"#app-listen\" class=\"headerlink\" title=\"app.listen\"></a>app.listen</h3><p>代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_proto.listen=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> server = http.createServer(<span class=\"keyword\">this</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> server.listen.apply(server,args)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>代码很简单 调用http.createServer(this) // app 是一个函数 。<br>最后一句 server.listen.apply(server,args) //这里用apply的原因是 listen内部可能用到server的this指代，所以用apply() 用 server代替this.</p>\n<p>总结： 通过看源码收获了很多，不仅仅知道了next（）什么时候用，怎么用，更是明白了express底层的机制原理！</p>"},{"title":"express整理","date":"2016-09-20T10:55:35.000Z","_content":"之前对express粗糙的用过，写过express+mongoose个人博客，上周看了深入浅出node.js，现在打算花费一周时间来整体捋一下express<!--more-->\n### Express基于Node.Js平台，快速开放、极简的web开发框架\n* npm install express –save  //安装express</li>\n* npm install express=gengerator -g //通过Express生成器创建express应用</li>\n* express路由 :路由是由一个URI(路径)和一个特定的http方法(GET,POST)组成<a id=\"more\"></a>\n　　每个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个函数将被执行\n　　路由的定义由如下结构组成:\n**app.METHOD(path,handler)**\n<pre>\n app.get(‘/‘,function(req,res){}})\n app.post(‘/‘,function(req,res){})\n</pre>\n**app.route()**//定义了链式路由句柄\n<pre>\napp.route(‘/‘).get(function(req,res){}).post(function(req,res){})\n</pre>\n**express.Router** //Router实例是一个完整的中间件和路由系统\n<pre>\nvar express = require(‘express’)\nvar router = express.Router()\n//该路由使用的中间件\nrouter.use(function timeLog(req,res,next){\nconsole.log(‘Time’,Date.now())\nnext()\n})\n//定义网站主页的路由\nrouter.get(‘/‘,function(req,res){})\nmodule.exports=router\n//在应用中加载路由模块\nvar route = require(‘./route.js’)\napp.use(‘/‘,route)</pre></li>\n* 利用Express托管静态文件\napp.use(express.static(‘public’)) //调用express.static中间件\n\n## [](#MVC模型 \"MVC模型\")MVC模型\nM:Model V：view C：Control\n\n## [](#express响应方法 \"express响应方法\")express响应方法\n<table><thead><th>方法</th><th>描述</th></thead><tbody><tr><td>res.download()</td><td>提示下载文件</td></tr><tr><td>res.end()</td><td>终结响应处理流程</td>\n</tr><tr><td>res.json()</td><td>发送一个JSON形式的响应</td></tr><tr><td>res.redirect()</td><td>重定向请求</td></tr><tr><td>res.render()</td><td>渲染视图模板</td></tr><tr><td>res.send()</td><td>发送各种类型的响应</td></tr></tbody></table>\n</li>\n</ol>\n\n\n* 使用中间件\n中间件(Middleware)是一个函数，它可以访问请求对象req，响应对象res和web应用中处于请求响应循环流程中的中间件，一般被命名为next的变量。如果当前中间件没有终结请求响应循环则必须调用next()方法将控制权交给下一个中间件，否则请求就会挂起\n**错误处理中间件** //四个参数\napp.use(function(err,req,res,next){\n console.error(err.stack)\n res.status(500).send(‘Something broke’)\n})\n**内置中间件**\n从4.x版本开始，除了express.static,Express以前的中间件已经全部单独作为模块安装使用\n* 在Express中使用模板引擎\n在应用中进行如下设置才能让Express渲染模板文件\n\n* views,放模板文件的目录，app.set(‘views’,’./views’)\n* view engine ,模板引擎 ,app.set(‘view engine’,’jade’)\n* 调试Express </br>内部使用debug模块调试，在启动应用时，设置DEBUG环境变量为express:_ 代码为:\nDEBUG=express:_ node index.js\n\n### Express API\n\n* **Properties**\n**app.locals***:the app.locals object is a JavaScript object,and its properties are local variables within the application.\n* Events\n**app.on(‘mount’,callback(parent))**//监听挂载事件\n* **Methods**\napp.all(path,callback)\napp.disable(name) =&gt; app.set(name,fasle)\napp.disabled(name) if app.disable(name) then app.disabled(name)=&gt;true\napp.enable(name) =&gt;app.set(name,true)\napp.enabled(name)\napp.engine(ext,callback)// ex: app.engine(‘jade’,require(‘jade’).__express)\napp.get(name)//return the value of name app setting\napp.param([name],function(req,res,next,id){}) called only once and the priority is the highest\napp.path() // return the cannonical path of the app,a string\napp.route(path)\napp.use([path],function{}) //mount the middleware at the path\n* **Request properties**\nreq.app =&gt; return the instance of express\nreq.baseUrl=&gt; return the path of mounted router instance\nreq.body=&gt; Contains key-value which is submitted in the request body.But: require(‘body-parser’), then app.use(bodyParse.json()),app.use(bodyParse.urlencoded({extended:false}))\nreq.rookies =&gt; require(‘cookie-parser’)\nreq.fresh //Indicates whether the request is “fresh”.THe follows is true\n　　if-modified-since == last-modified\nreq.hostname ,req.ip,req.originalUrl\nreq.params example: route: /user/:name =&gt;req.params.name\nreq.path =&gt;return the path part of the request URL\nreq.query example:route: /search?q=1 =&gt;req.query.q = 1\nreq.param =&gt; req.params req.query req.body\n* **Response properties**\nres.headersSent Indicate if the app sent HTTP headers for the response\nres.locals.An object that contains response local variablesscoped to the request.\nres.cookie(name,value,[options]) =&gt;Sets cookie name to value\nres.clearCookie(name,[options])\nres.download(path,[filename])\nres.end() =&gt;Ends the response process\nres.get(field) =&gt; returns the HTTPresponse header\nres.location() == res.redirect([status],path)\nres.render()  // 内部调用app.render() =&gt;生成视图的工具\nres.send([body]) the parameter can be Buffer object, String,Array,Object\nres.sendStatus() 200=&gt;OK 403=&gt;Forbidden 404=&gt;NOt FOund 500 =&gt;Internal Server Err\n\n* * *\n\n## [](#Mongoose \"Mongoose\")Mongoose\n\n1.名词解释\n　　<font style=\"background=#f1f1f1\">Schema</font>:**_一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力_**\n　　<font style=\"background=#f1f1f1\">Model</font>：**_由Schema发布生成的模型，具有抽象属性和行为的数据库操作对_**\n　　<font style=\"background=#f1f1f1\">Entity</font>: **_由Model创建的实体，操作会影响数据库_**\n\n1.  使用\n<pre style=\"background=#f1f1f1\">\nvar mongoose = require(‘mongoose’)//引用mongoose模块\nvar db = mongoose.createConnection(‘localhost’,’test’)//创建数据库连接\n//定义一个**_Schema_**\nvar PersonSchema = new mongoose.Schema({\n name:String //定义一个属性name，类型为String\n})\n//将Schema发布为Model\nvar PersonModel = db.model(‘Person’,PersonSchema)\n//用Model创建Entity\nvar PersonEntity = new PersonModel({name:’Krouky’})\n//Entity是具有具体的数据库操作CRUD的\nPersonEntity.save()\n//执行查询\nPersonModel.find(function(err,persons){})</pre>\n\n1.  具体语法\n更新：\n1.PersonModel.findById(id,function(err,person){\n person.name=’Mdragon’\n person.save=(function(err){})\n})\n2.PersonModel.findById(id,function(err,person){\n person.name=’MDragon’\n var _id=person._id\n delete person._id\n PersonModel.update({_id:_id},person,function(err){})\n}) // update 第一个参数是查询条件，第二个参数是更新的对象，不可以更新主键\nPersonModel.update({_id:_id},{$set:{name:’MDragon’}},function(err){})\n新增：1.使用Entity增加数据\nvar krouky = new PersonModel({name:’krouky’})\nkrouky.save(callback)\n2.使用Model来增加一条数据\nvar MDragon = {name:’MDragon’}\nPersonModel.create(MDragon,callback)\n查询\n1.PersonModel.findOne({‘name’:’MDragon’},’select’,function({err,person}))\n2.var query = PersonModel.find({name:’MDragon’})\nquery.select(‘select’)\nquery.exec(function(err,person))\n验证\n1.required:非空验证 2.min/max: 范围验证 3. enum/match： 枚举验证 4.validate:自定义验证\n\n## [](#Cheerio-superagent-爬虫 \"Cheerio + superagent 爬虫\")Cheerio + superagent 爬虫\n\n## [](#cheerio-API \"cheerio API\")**_cheerio API_**\n\n1.  npm install cheerio\n2.  将html告诉你的服务器\n<pre style=\"background=#f1f1f1\">\nvar cheerio = require(‘cheerio’)\n$ = cheerio.load(html)\n$data = $(data)\n//接下来即跟jquery用法相同了\n</pre>\n**_superagent API_**\n3.  npm install superagent\n4.  使用<pre style=\"background=#f1f1f1\">\nvar superAgent =require(\"superagent\")\nsuperAgent.get(url).end(function(err,sres){}) // get\nsuperAgent.post(url).send({name:'haha',species:'cat'}).end(function(res))\nsuperAgent.del(url).end(function(res))\n</pre>\n\n* * *\n\n## [](#使用eventproxy控制并发 \"使用eventproxy控制并发\")使用eventproxy控制并发\n\n**_eventproxy API_**\n\n1.  npm install eventproxy\n2.  使用<pre style=\"background=#f1f1f1\">\nvar ep = new EventProxy()\nep.all('data1_event','data2_event','data3_event',function(data1,data2,data2){})\n//监听了3个事件，当三个事件全部完成后调用回调函数\nep.after('got_file',files.length,function(list){})\n//after方法适合重复异步协作 // files数组 list数组存储的是文件的内容\nfor(var i =0,i<files.length,i++) {=\"\" fs.readfile(files[i],'utf-8',function(err,content){=\"\" ep.emit('got_file',content)=\"\" })=\"\" }=\"\" ep.tail('tp1','data',function(tp1,data))=\"\" 在所有制定事件出发后，将会被调用执行=\"\" <=\"\" pre=\"\">\n</files.length,i++)></pre>\n\n* * *\n\n## [](#使用async控制并发 \"使用async控制并发\")使用async控制并发\n\nasync的mapLimit(arr,limit,iterator,callback)接口\narr:数组 limit:并发量 iterator: 迭代函数 callback:回调函数\n\n## [](#mocha-should \"mocha should\")mocha should\n\n1.  sudo npm install mocha -g\n2.  npm install should\n3.  使用\n<pre>\n//新建一个main.js\nvar fibonacci=function(n){\nif(n==0)\nreturn 0\nif(n==1)\nreturn 1\nreturn fibonacci(n-2)+fibonacci(n-1)\n}\nexports.fibonacci=fibonacci\n//新建一个test.js\nvar main = require(‘./main’)\nvar should = require(‘should’)\ndescript(‘/test.js’,function(){\n it(‘should equal 55 when n ===10’,function(){\n\n        main.fibonacci(10).should.equal(55)\n })\n})\n//执行mocha即可\ndescript:描述的是你要测试的主题，\nit:描述的是具体的case内容\nshould模块：是一个断言库\n</pre>\n\n    ### [](#关于exports和module-exports \"关于exports和module.exports\")关于exports和module.exports\n\n4.  exports是指向<font style=\"color:blue;\">module.exports</font>的引用\n5.  module.exports初始值是一个空对象{}\n6.  require()返回的是module.exports\n\n    ### [](#ejs \"ejs\")ejs\n&lt;%=code%&gt;会对code进行html转义\n&lt;%-code%&gt;不会对code进行html转义\n&lt;%code%&gt;执行其中的js代码\n基础知识仔细回顾一边之后，做个项目来理一理express开发的流程\n代码在[github](https://github.com/yooki0328)\n","source":"_posts/expressR.md","raw":"---\ntitle: express整理\ndate: 2016-09-20 03:55:35\ntags: [nodejs]\n---\n之前对express粗糙的用过，写过express+mongoose个人博客，上周看了深入浅出node.js，现在打算花费一周时间来整体捋一下express<!--more-->\n### Express基于Node.Js平台，快速开放、极简的web开发框架\n* npm install express –save  //安装express</li>\n* npm install express=gengerator -g //通过Express生成器创建express应用</li>\n* express路由 :路由是由一个URI(路径)和一个特定的http方法(GET,POST)组成<a id=\"more\"></a>\n　　每个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个函数将被执行\n　　路由的定义由如下结构组成:\n**app.METHOD(path,handler)**\n<pre>\n app.get(‘/‘,function(req,res){}})\n app.post(‘/‘,function(req,res){})\n</pre>\n**app.route()**//定义了链式路由句柄\n<pre>\napp.route(‘/‘).get(function(req,res){}).post(function(req,res){})\n</pre>\n**express.Router** //Router实例是一个完整的中间件和路由系统\n<pre>\nvar express = require(‘express’)\nvar router = express.Router()\n//该路由使用的中间件\nrouter.use(function timeLog(req,res,next){\nconsole.log(‘Time’,Date.now())\nnext()\n})\n//定义网站主页的路由\nrouter.get(‘/‘,function(req,res){})\nmodule.exports=router\n//在应用中加载路由模块\nvar route = require(‘./route.js’)\napp.use(‘/‘,route)</pre></li>\n* 利用Express托管静态文件\napp.use(express.static(‘public’)) //调用express.static中间件\n\n## [](#MVC模型 \"MVC模型\")MVC模型\nM:Model V：view C：Control\n\n## [](#express响应方法 \"express响应方法\")express响应方法\n<table><thead><th>方法</th><th>描述</th></thead><tbody><tr><td>res.download()</td><td>提示下载文件</td></tr><tr><td>res.end()</td><td>终结响应处理流程</td>\n</tr><tr><td>res.json()</td><td>发送一个JSON形式的响应</td></tr><tr><td>res.redirect()</td><td>重定向请求</td></tr><tr><td>res.render()</td><td>渲染视图模板</td></tr><tr><td>res.send()</td><td>发送各种类型的响应</td></tr></tbody></table>\n</li>\n</ol>\n\n\n* 使用中间件\n中间件(Middleware)是一个函数，它可以访问请求对象req，响应对象res和web应用中处于请求响应循环流程中的中间件，一般被命名为next的变量。如果当前中间件没有终结请求响应循环则必须调用next()方法将控制权交给下一个中间件，否则请求就会挂起\n**错误处理中间件** //四个参数\napp.use(function(err,req,res,next){\n console.error(err.stack)\n res.status(500).send(‘Something broke’)\n})\n**内置中间件**\n从4.x版本开始，除了express.static,Express以前的中间件已经全部单独作为模块安装使用\n* 在Express中使用模板引擎\n在应用中进行如下设置才能让Express渲染模板文件\n\n* views,放模板文件的目录，app.set(‘views’,’./views’)\n* view engine ,模板引擎 ,app.set(‘view engine’,’jade’)\n* 调试Express </br>内部使用debug模块调试，在启动应用时，设置DEBUG环境变量为express:_ 代码为:\nDEBUG=express:_ node index.js\n\n### Express API\n\n* **Properties**\n**app.locals***:the app.locals object is a JavaScript object,and its properties are local variables within the application.\n* Events\n**app.on(‘mount’,callback(parent))**//监听挂载事件\n* **Methods**\napp.all(path,callback)\napp.disable(name) =&gt; app.set(name,fasle)\napp.disabled(name) if app.disable(name) then app.disabled(name)=&gt;true\napp.enable(name) =&gt;app.set(name,true)\napp.enabled(name)\napp.engine(ext,callback)// ex: app.engine(‘jade’,require(‘jade’).__express)\napp.get(name)//return the value of name app setting\napp.param([name],function(req,res,next,id){}) called only once and the priority is the highest\napp.path() // return the cannonical path of the app,a string\napp.route(path)\napp.use([path],function{}) //mount the middleware at the path\n* **Request properties**\nreq.app =&gt; return the instance of express\nreq.baseUrl=&gt; return the path of mounted router instance\nreq.body=&gt; Contains key-value which is submitted in the request body.But: require(‘body-parser’), then app.use(bodyParse.json()),app.use(bodyParse.urlencoded({extended:false}))\nreq.rookies =&gt; require(‘cookie-parser’)\nreq.fresh //Indicates whether the request is “fresh”.THe follows is true\n　　if-modified-since == last-modified\nreq.hostname ,req.ip,req.originalUrl\nreq.params example: route: /user/:name =&gt;req.params.name\nreq.path =&gt;return the path part of the request URL\nreq.query example:route: /search?q=1 =&gt;req.query.q = 1\nreq.param =&gt; req.params req.query req.body\n* **Response properties**\nres.headersSent Indicate if the app sent HTTP headers for the response\nres.locals.An object that contains response local variablesscoped to the request.\nres.cookie(name,value,[options]) =&gt;Sets cookie name to value\nres.clearCookie(name,[options])\nres.download(path,[filename])\nres.end() =&gt;Ends the response process\nres.get(field) =&gt; returns the HTTPresponse header\nres.location() == res.redirect([status],path)\nres.render()  // 内部调用app.render() =&gt;生成视图的工具\nres.send([body]) the parameter can be Buffer object, String,Array,Object\nres.sendStatus() 200=&gt;OK 403=&gt;Forbidden 404=&gt;NOt FOund 500 =&gt;Internal Server Err\n\n* * *\n\n## [](#Mongoose \"Mongoose\")Mongoose\n\n1.名词解释\n　　<font style=\"background=#f1f1f1\">Schema</font>:**_一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力_**\n　　<font style=\"background=#f1f1f1\">Model</font>：**_由Schema发布生成的模型，具有抽象属性和行为的数据库操作对_**\n　　<font style=\"background=#f1f1f1\">Entity</font>: **_由Model创建的实体，操作会影响数据库_**\n\n1.  使用\n<pre style=\"background=#f1f1f1\">\nvar mongoose = require(‘mongoose’)//引用mongoose模块\nvar db = mongoose.createConnection(‘localhost’,’test’)//创建数据库连接\n//定义一个**_Schema_**\nvar PersonSchema = new mongoose.Schema({\n name:String //定义一个属性name，类型为String\n})\n//将Schema发布为Model\nvar PersonModel = db.model(‘Person’,PersonSchema)\n//用Model创建Entity\nvar PersonEntity = new PersonModel({name:’Krouky’})\n//Entity是具有具体的数据库操作CRUD的\nPersonEntity.save()\n//执行查询\nPersonModel.find(function(err,persons){})</pre>\n\n1.  具体语法\n更新：\n1.PersonModel.findById(id,function(err,person){\n person.name=’Mdragon’\n person.save=(function(err){})\n})\n2.PersonModel.findById(id,function(err,person){\n person.name=’MDragon’\n var _id=person._id\n delete person._id\n PersonModel.update({_id:_id},person,function(err){})\n}) // update 第一个参数是查询条件，第二个参数是更新的对象，不可以更新主键\nPersonModel.update({_id:_id},{$set:{name:’MDragon’}},function(err){})\n新增：1.使用Entity增加数据\nvar krouky = new PersonModel({name:’krouky’})\nkrouky.save(callback)\n2.使用Model来增加一条数据\nvar MDragon = {name:’MDragon’}\nPersonModel.create(MDragon,callback)\n查询\n1.PersonModel.findOne({‘name’:’MDragon’},’select’,function({err,person}))\n2.var query = PersonModel.find({name:’MDragon’})\nquery.select(‘select’)\nquery.exec(function(err,person))\n验证\n1.required:非空验证 2.min/max: 范围验证 3. enum/match： 枚举验证 4.validate:自定义验证\n\n## [](#Cheerio-superagent-爬虫 \"Cheerio + superagent 爬虫\")Cheerio + superagent 爬虫\n\n## [](#cheerio-API \"cheerio API\")**_cheerio API_**\n\n1.  npm install cheerio\n2.  将html告诉你的服务器\n<pre style=\"background=#f1f1f1\">\nvar cheerio = require(‘cheerio’)\n$ = cheerio.load(html)\n$data = $(data)\n//接下来即跟jquery用法相同了\n</pre>\n**_superagent API_**\n3.  npm install superagent\n4.  使用<pre style=\"background=#f1f1f1\">\nvar superAgent =require(\"superagent\")\nsuperAgent.get(url).end(function(err,sres){}) // get\nsuperAgent.post(url).send({name:'haha',species:'cat'}).end(function(res))\nsuperAgent.del(url).end(function(res))\n</pre>\n\n* * *\n\n## [](#使用eventproxy控制并发 \"使用eventproxy控制并发\")使用eventproxy控制并发\n\n**_eventproxy API_**\n\n1.  npm install eventproxy\n2.  使用<pre style=\"background=#f1f1f1\">\nvar ep = new EventProxy()\nep.all('data1_event','data2_event','data3_event',function(data1,data2,data2){})\n//监听了3个事件，当三个事件全部完成后调用回调函数\nep.after('got_file',files.length,function(list){})\n//after方法适合重复异步协作 // files数组 list数组存储的是文件的内容\nfor(var i =0,i<files.length,i++) {=\"\" fs.readfile(files[i],'utf-8',function(err,content){=\"\" ep.emit('got_file',content)=\"\" })=\"\" }=\"\" ep.tail('tp1','data',function(tp1,data))=\"\" 在所有制定事件出发后，将会被调用执行=\"\" <=\"\" pre=\"\">\n</files.length,i++)></pre>\n\n* * *\n\n## [](#使用async控制并发 \"使用async控制并发\")使用async控制并发\n\nasync的mapLimit(arr,limit,iterator,callback)接口\narr:数组 limit:并发量 iterator: 迭代函数 callback:回调函数\n\n## [](#mocha-should \"mocha should\")mocha should\n\n1.  sudo npm install mocha -g\n2.  npm install should\n3.  使用\n<pre>\n//新建一个main.js\nvar fibonacci=function(n){\nif(n==0)\nreturn 0\nif(n==1)\nreturn 1\nreturn fibonacci(n-2)+fibonacci(n-1)\n}\nexports.fibonacci=fibonacci\n//新建一个test.js\nvar main = require(‘./main’)\nvar should = require(‘should’)\ndescript(‘/test.js’,function(){\n it(‘should equal 55 when n ===10’,function(){\n\n        main.fibonacci(10).should.equal(55)\n })\n})\n//执行mocha即可\ndescript:描述的是你要测试的主题，\nit:描述的是具体的case内容\nshould模块：是一个断言库\n</pre>\n\n    ### [](#关于exports和module-exports \"关于exports和module.exports\")关于exports和module.exports\n\n4.  exports是指向<font style=\"color:blue;\">module.exports</font>的引用\n5.  module.exports初始值是一个空对象{}\n6.  require()返回的是module.exports\n\n    ### [](#ejs \"ejs\")ejs\n&lt;%=code%&gt;会对code进行html转义\n&lt;%-code%&gt;不会对code进行html转义\n&lt;%code%&gt;执行其中的js代码\n基础知识仔细回顾一边之后，做个项目来理一理express开发的流程\n代码在[github](https://github.com/yooki0328)\n","slug":"expressR","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4qz000aoejx7ttys0fy","content":"<p>之前对express粗糙的用过，写过express+mongoose个人博客，上周看了深入浅出node.js，现在打算花费一周时间来整体捋一下express<a id=\"more\"></a></p>\n<h3 id=\"Express基于Node-Js平台，快速开放、极简的web开发框架\"><a href=\"#Express基于Node-Js平台，快速开放、极简的web开发框架\" class=\"headerlink\" title=\"Express基于Node.Js平台，快速开放、极简的web开发框架\"></a>Express基于Node.Js平台，快速开放、极简的web开发框架</h3><ul>\n<li>npm install express –save  //安装express</li>\n<li>npm install express=gengerator -g //通过Express生成器创建express应用</li>\n<li>express路由 :路由是由一个URI(路径)和一个特定的http方法(GET,POST)组成<a id=\"more\"></a><br>　　每个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个函数将被执行<br>　　路由的定义由如下结构组成:<br><strong>app.METHOD(path,handler)</strong><br><pre><br>app.get(‘/‘,function(req,res){}})<br>app.post(‘/‘,function(req,res){})<br></pre><br><strong>app.route()</strong>//定义了链式路由句柄<br><pre><br>app.route(‘/‘).get(function(req,res){}).post(function(req,res){})<br></pre><br><strong>express.Router</strong> //Router实例是一个完整的中间件和路由系统<br><pre><br>var express = require(‘express’)<br>var router = express.Router()<br>//该路由使用的中间件<br>router.use(function timeLog(req,res,next){<br>console.log(‘Time’,Date.now())<br>next()<br>})<br>//定义网站主页的路由<br>router.get(‘/‘,function(req,res){})<br>module.exports=router<br>//在应用中加载路由模块<br>var route = require(‘./route.js’)<br>app.use(‘/‘,route)</pre></li>\n<li>利用Express托管静态文件<br>app.use(express.static(‘public’)) //调用express.static中间件</li>\n</ul>\n<h2 id=\"MVC模型\"><a href=\"#MVC模型\" class=\"headerlink\" title=\"MVC模型\"></a><a href=\"#MVC模型\" title=\"MVC模型\"></a>MVC模型</h2><p>M:Model V：view C：Control</p>\n<h2 id=\"express响应方法\"><a href=\"#express响应方法\" class=\"headerlink\" title=\"express响应方法\"></a><a href=\"#express响应方法\" title=\"express响应方法\"></a>express响应方法</h2><p><table><thead><th>方法</th><th>描述</th></thead><tbody><tr><td>res.download()</td><td>提示下载文件</td></tr><tr><td>res.end()</td><td>终结响应处理流程</td><br></tr><tr><td>res.json()</td><td>发送一个JSON形式的响应</td></tr><tr><td>res.redirect()</td><td>重定向请求</td></tr><tr><td>res.render()</td><td>渲染视图模板</td></tr><tr><td>res.send()</td><td>发送各种类型的响应</td></tr></tbody></table><br><br></p>\n<ul>\n<li>使用中间件<br>中间件(Middleware)是一个函数，它可以访问请求对象req，响应对象res和web应用中处于请求响应循环流程中的中间件，一般被命名为next的变量。如果当前中间件没有终结请求响应循环则必须调用next()方法将控制权交给下一个中间件，否则请求就会挂起<br><strong>错误处理中间件</strong> //四个参数<br>app.use(function(err,req,res,next){<br>console.error(err.stack)<br>res.status(500).send(‘Something broke’)<br>})<br><strong>内置中间件</strong><br>从4.x版本开始，除了express.static,Express以前的中间件已经全部单独作为模块安装使用</li>\n<li><p>在Express中使用模板引擎<br>在应用中进行如下设置才能让Express渲染模板文件</p>\n</li>\n<li><p>views,放模板文件的目录，app.set(‘views’,’./views’)</p>\n</li>\n<li>view engine ,模板引擎 ,app.set(‘view engine’,’jade’)</li>\n<li>调试Express <br>内部使用debug模块调试，在启动应用时，设置DEBUG环境变量为express:<em> 代码为:<br>DEBUG=express:</em> node index.js</li>\n</ul>\n<h3 id=\"Express-API\"><a href=\"#Express-API\" class=\"headerlink\" title=\"Express API\"></a>Express API</h3><ul>\n<li><strong>Properties</strong><br><strong>app.locals*</strong>:the app.locals object is a JavaScript object,and its properties are local variables within the application.</li>\n<li>Events<br><strong>app.on(‘mount’,callback(parent))</strong>//监听挂载事件</li>\n<li><strong>Methods</strong><br>app.all(path,callback)<br>app.disable(name) =&gt; app.set(name,fasle)<br>app.disabled(name) if app.disable(name) then app.disabled(name)=&gt;true<br>app.enable(name) =&gt;app.set(name,true)<br>app.enabled(name)<br>app.engine(ext,callback)// ex: app.engine(‘jade’,require(‘jade’).__express)<br>app.get(name)//return the value of name app setting<br>app.param([name],function(req,res,next,id){}) called only once and the priority is the highest<br>app.path() // return the cannonical path of the app,a string<br>app.route(path)<br>app.use([path],function{}) //mount the middleware at the path</li>\n<li><strong>Request properties</strong><br>req.app =&gt; return the instance of express<br>req.baseUrl=&gt; return the path of mounted router instance<br>req.body=&gt; Contains key-value which is submitted in the request body.But: require(‘body-parser’), then app.use(bodyParse.json()),app.use(bodyParse.urlencoded({extended:false}))<br>req.rookies =&gt; require(‘cookie-parser’)<br>req.fresh //Indicates whether the request is “fresh”.THe follows is true<br>　　if-modified-since == last-modified<br>req.hostname ,req.ip,req.originalUrl<br>req.params example: route: /user/:name =&gt;req.params.name<br>req.path =&gt;return the path part of the request URL<br>req.query example:route: /search?q=1 =&gt;req.query.q = 1<br>req.param =&gt; req.params req.query req.body</li>\n<li><strong>Response properties</strong><br>res.headersSent Indicate if the app sent HTTP headers for the response<br>res.locals.An object that contains response local variablesscoped to the request.<br>res.cookie(name,value,[options]) =&gt;Sets cookie name to value<br>res.clearCookie(name,[options])<br>res.download(path,[filename])<br>res.end() =&gt;Ends the response process<br>res.get(field) =&gt; returns the HTTPresponse header<br>res.location() == res.redirect([status],path)<br>res.render()  // 内部调用app.render() =&gt;生成视图的工具<br>res.send([body]) the parameter can be Buffer object, String,Array,Object<br>res.sendStatus() 200=&gt;OK 403=&gt;Forbidden 404=&gt;NOt FOund 500 =&gt;Internal Server Err</li>\n</ul>\n<hr>\n<h2 id=\"Mongoose\"><a href=\"#Mongoose\" class=\"headerlink\" title=\"Mongoose\"></a><a href=\"#Mongoose\" title=\"Mongoose\"></a>Mongoose</h2><p>1.名词解释<br>　　<font style=\"background=#f1f1f1\">Schema</font>:<strong><em>一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力</em></strong><br>　　<font style=\"background=#f1f1f1\">Model</font>：<strong><em>由Schema发布生成的模型，具有抽象属性和行为的数据库操作对</em></strong><br>　　<font style=\"background=#f1f1f1\">Entity</font>: <strong><em>由Model创建的实体，操作会影响数据库</em></strong></p>\n<ol>\n<li><p>使用</p>\n<pre style=\"background=#f1f1f1\">\nvar mongoose = require(‘mongoose’)//引用mongoose模块\nvar db = mongoose.createConnection(‘localhost’,’test’)//创建数据库连接\n//定义一个**_Schema_**\nvar PersonSchema = new mongoose.Schema({\nname:String //定义一个属性name，类型为String\n})\n//将Schema发布为Model\nvar PersonModel = db.model(‘Person’,PersonSchema)\n//用Model创建Entity\nvar PersonEntity = new PersonModel({name:’Krouky’})\n//Entity是具有具体的数据库操作CRUD的\nPersonEntity.save()\n//执行查询\nPersonModel.find(function(err,persons){})</pre>\n</li>\n<li><p>具体语法<br>更新：<br>1.PersonModel.findById(id,function(err,person){<br>person.name=’Mdragon’<br>person.save=(function(err){})<br>})<br>2.PersonModel.findById(id,function(err,person){<br>person.name=’MDragon’<br>var _id=person._id<br>delete person._id<br>PersonModel.update({_id:_id},person,function(err){})<br>}) // update 第一个参数是查询条件，第二个参数是更新的对象，不可以更新主键<br>PersonModel.update({_id:_id},{$set:{name:’MDragon’}},function(err){})<br>新增：1.使用Entity增加数据<br>var krouky = new PersonModel({name:’krouky’})<br>krouky.save(callback)<br>2.使用Model来增加一条数据<br>var MDragon = {name:’MDragon’}<br>PersonModel.create(MDragon,callback)<br>查询<br>1.PersonModel.findOne({‘name’:’MDragon’},’select’,function({err,person}))<br>2.var query = PersonModel.find({name:’MDragon’})<br>query.select(‘select’)<br>query.exec(function(err,person))<br>验证<br>1.required:非空验证 2.min/max: 范围验证 3. enum/match： 枚举验证 4.validate:自定义验证</p>\n</li>\n</ol>\n<h2 id=\"Cheerio-superagent-爬虫\"><a href=\"#Cheerio-superagent-爬虫\" class=\"headerlink\" title=\"Cheerio + superagent 爬虫\"></a><a href=\"#Cheerio-superagent-爬虫\" title=\"Cheerio + superagent 爬虫\"></a>Cheerio + superagent 爬虫</h2><h2 id=\"cheerio-API\"><a href=\"#cheerio-API\" class=\"headerlink\" title=\"cheerio API\"></a><a href=\"#cheerio-API\" title=\"cheerio API\"></a><strong><em>cheerio API</em></strong></h2><ol>\n<li>npm install cheerio</li>\n<li>将html告诉你的服务器<br><pre style=\"background=#f1f1f1\"><br>var cheerio = require(‘cheerio’)<br>$ = cheerio.load(html)<br>$data = $(data)<br>//接下来即跟jquery用法相同了<br></pre><br><strong><em>superagent API</em></strong></li>\n<li>npm install superagent</li>\n<li>使用<pre style=\"background=#f1f1f1\"><br>var superAgent =require(“superagent”)<br>superAgent.get(url).end(function(err,sres){}) // get<br>superAgent.post(url).send({name:’haha’,species:’cat’}).end(function(res))<br>superAgent.del(url).end(function(res))<br></pre></li>\n</ol>\n<hr>\n<h2 id=\"使用eventproxy控制并发\"><a href=\"#使用eventproxy控制并发\" class=\"headerlink\" title=\"使用eventproxy控制并发\"></a><a href=\"#使用eventproxy控制并发\" title=\"使用eventproxy控制并发\"></a>使用eventproxy控制并发</h2><p><strong><em>eventproxy API</em></strong></p>\n<ol>\n<li>npm install eventproxy</li>\n<li>使用<pre style=\"background=#f1f1f1\"><br>var ep = new EventProxy()<br>ep.all(‘data1_event’,’data2_event’,’data3_event’,function(data1,data2,data2){})<br>//监听了3个事件，当三个事件全部完成后调用回调函数<br>ep.after(‘got_file’,files.length,function(list){})<br>//after方法适合重复异步协作 // files数组 list数组存储的是文件的内容<br>for(var i =0,i<files.length,i++) {=\"\" fs.readfile(files[i],'utf-8',function(err,content){=\"\" ep.emit('got_file',content)=\"\" })=\"\" }=\"\" ep.tail('tp1','data',function(tp1,data))=\"\" 在所有制定事件出发后，将会被调用执行=\"\" <=\"\" pre=\"\"><br></files.length,i++)></pre></li>\n</ol>\n<hr>\n<h2 id=\"使用async控制并发\"><a href=\"#使用async控制并发\" class=\"headerlink\" title=\"使用async控制并发\"></a><a href=\"#使用async控制并发\" title=\"使用async控制并发\"></a>使用async控制并发</h2><p>async的mapLimit(arr,limit,iterator,callback)接口<br>arr:数组 limit:并发量 iterator: 迭代函数 callback:回调函数</p>\n<h2 id=\"mocha-should\"><a href=\"#mocha-should\" class=\"headerlink\" title=\"mocha should\"></a><a href=\"#mocha-should\" title=\"mocha should\"></a>mocha should</h2><ol>\n<li>sudo npm install mocha -g</li>\n<li>npm install should</li>\n<li><p>使用</p>\n<pre>\n//新建一个main.js\nvar fibonacci=function(n){\nif(n==0)\nreturn 0\nif(n==1)\nreturn 1\nreturn fibonacci(n-2)+fibonacci(n-1)\n}\nexports.fibonacci=fibonacci\n//新建一个test.js\nvar main = require(‘./main’)\nvar should = require(‘should’)\ndescript(‘/test.js’,function(){\nit(‘should equal 55 when n ===10’,function(){\n\n    main.fibonacci(10).should.equal(55)\n})\n})\n//执行mocha即可\ndescript:描述的是你要测试的主题，\nit:描述的是具体的case内容\nshould模块：是一个断言库\n</pre>\n\n<h3 id=\"关于exports和module-exports\"><a href=\"#关于exports和module-exports\" class=\"headerlink\" title=\"关于exports和module.exports\"></a><a href=\"#关于exports和module-exports\" title=\"关于exports和module.exports\"></a>关于exports和module.exports</h3></li>\n<li><p>exports是指向<font style=\"color:blue;\">module.exports</font>的引用</p>\n</li>\n<li>module.exports初始值是一个空对象{}</li>\n<li><p>require()返回的是module.exports</p>\n<h3 id=\"ejs\"><a href=\"#ejs\" class=\"headerlink\" title=\"ejs\"></a><a href=\"#ejs\" title=\"ejs\"></a>ejs</h3><p>&lt;%=code%&gt;会对code进行html转义<br>&lt;%-code%&gt;不会对code进行html转义<br>&lt;%code%&gt;执行其中的js代码<br>基础知识仔细回顾一边之后，做个项目来理一理express开发的流程<br>代码在<a href=\"https://github.com/yooki0328\" target=\"_blank\" rel=\"external\">github</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>之前对express粗糙的用过，写过express+mongoose个人博客，上周看了深入浅出node.js，现在打算花费一周时间来整体捋一下express","more":"</p>\n<h3 id=\"Express基于Node-Js平台，快速开放、极简的web开发框架\"><a href=\"#Express基于Node-Js平台，快速开放、极简的web开发框架\" class=\"headerlink\" title=\"Express基于Node.Js平台，快速开放、极简的web开发框架\"></a>Express基于Node.Js平台，快速开放、极简的web开发框架</h3><ul>\n<li>npm install express –save  //安装express</li></li>\n<li>npm install express=gengerator -g //通过Express生成器创建express应用</li></li>\n<li>express路由 :路由是由一个URI(路径)和一个特定的http方法(GET,POST)组成<a id=\"more\"></a><br>　　每个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个函数将被执行<br>　　路由的定义由如下结构组成:<br><strong>app.METHOD(path,handler)</strong><br><pre><br>app.get(‘/‘,function(req,res){}})<br>app.post(‘/‘,function(req,res){})<br></pre><br><strong>app.route()</strong>//定义了链式路由句柄<br><pre><br>app.route(‘/‘).get(function(req,res){}).post(function(req,res){})<br></pre><br><strong>express.Router</strong> //Router实例是一个完整的中间件和路由系统<br><pre><br>var express = require(‘express’)<br>var router = express.Router()<br>//该路由使用的中间件<br>router.use(function timeLog(req,res,next){<br>console.log(‘Time’,Date.now())<br>next()<br>})<br>//定义网站主页的路由<br>router.get(‘/‘,function(req,res){})<br>module.exports=router<br>//在应用中加载路由模块<br>var route = require(‘./route.js’)<br>app.use(‘/‘,route)</pre></li></li>\n<li>利用Express托管静态文件<br>app.use(express.static(‘public’)) //调用express.static中间件</li>\n</ul>\n<h2 id=\"MVC模型\"><a href=\"#MVC模型\" class=\"headerlink\" title=\"MVC模型\"></a><a href=\"#MVC模型\" title=\"MVC模型\"></a>MVC模型</h2><p>M:Model V：view C：Control</p>\n<h2 id=\"express响应方法\"><a href=\"#express响应方法\" class=\"headerlink\" title=\"express响应方法\"></a><a href=\"#express响应方法\" title=\"express响应方法\"></a>express响应方法</h2><p><table><thead><th>方法</th><th>描述</th></thead><tbody><tr><td>res.download()</td><td>提示下载文件</td></tr><tr><td>res.end()</td><td>终结响应处理流程</td><br></tr><tr><td>res.json()</td><td>发送一个JSON形式的响应</td></tr><tr><td>res.redirect()</td><td>重定向请求</td></tr><tr><td>res.render()</td><td>渲染视图模板</td></tr><tr><td>res.send()</td><td>发送各种类型的响应</td></tr></tbody></table><br></li><br></ol></p>\n<ul>\n<li>使用中间件<br>中间件(Middleware)是一个函数，它可以访问请求对象req，响应对象res和web应用中处于请求响应循环流程中的中间件，一般被命名为next的变量。如果当前中间件没有终结请求响应循环则必须调用next()方法将控制权交给下一个中间件，否则请求就会挂起<br><strong>错误处理中间件</strong> //四个参数<br>app.use(function(err,req,res,next){<br>console.error(err.stack)<br>res.status(500).send(‘Something broke’)<br>})<br><strong>内置中间件</strong><br>从4.x版本开始，除了express.static,Express以前的中间件已经全部单独作为模块安装使用</li>\n<li><p>在Express中使用模板引擎<br>在应用中进行如下设置才能让Express渲染模板文件</p>\n</li>\n<li><p>views,放模板文件的目录，app.set(‘views’,’./views’)</p>\n</li>\n<li>view engine ,模板引擎 ,app.set(‘view engine’,’jade’)</li>\n<li>调试Express </br>内部使用debug模块调试，在启动应用时，设置DEBUG环境变量为express:<em> 代码为:<br>DEBUG=express:</em> node index.js</li>\n</ul>\n<h3 id=\"Express-API\"><a href=\"#Express-API\" class=\"headerlink\" title=\"Express API\"></a>Express API</h3><ul>\n<li><strong>Properties</strong><br><strong>app.locals*</strong>:the app.locals object is a JavaScript object,and its properties are local variables within the application.</li>\n<li>Events<br><strong>app.on(‘mount’,callback(parent))</strong>//监听挂载事件</li>\n<li><strong>Methods</strong><br>app.all(path,callback)<br>app.disable(name) =&gt; app.set(name,fasle)<br>app.disabled(name) if app.disable(name) then app.disabled(name)=&gt;true<br>app.enable(name) =&gt;app.set(name,true)<br>app.enabled(name)<br>app.engine(ext,callback)// ex: app.engine(‘jade’,require(‘jade’).__express)<br>app.get(name)//return the value of name app setting<br>app.param([name],function(req,res,next,id){}) called only once and the priority is the highest<br>app.path() // return the cannonical path of the app,a string<br>app.route(path)<br>app.use([path],function{}) //mount the middleware at the path</li>\n<li><strong>Request properties</strong><br>req.app =&gt; return the instance of express<br>req.baseUrl=&gt; return the path of mounted router instance<br>req.body=&gt; Contains key-value which is submitted in the request body.But: require(‘body-parser’), then app.use(bodyParse.json()),app.use(bodyParse.urlencoded({extended:false}))<br>req.rookies =&gt; require(‘cookie-parser’)<br>req.fresh //Indicates whether the request is “fresh”.THe follows is true<br>　　if-modified-since == last-modified<br>req.hostname ,req.ip,req.originalUrl<br>req.params example: route: /user/:name =&gt;req.params.name<br>req.path =&gt;return the path part of the request URL<br>req.query example:route: /search?q=1 =&gt;req.query.q = 1<br>req.param =&gt; req.params req.query req.body</li>\n<li><strong>Response properties</strong><br>res.headersSent Indicate if the app sent HTTP headers for the response<br>res.locals.An object that contains response local variablesscoped to the request.<br>res.cookie(name,value,[options]) =&gt;Sets cookie name to value<br>res.clearCookie(name,[options])<br>res.download(path,[filename])<br>res.end() =&gt;Ends the response process<br>res.get(field) =&gt; returns the HTTPresponse header<br>res.location() == res.redirect([status],path)<br>res.render()  // 内部调用app.render() =&gt;生成视图的工具<br>res.send([body]) the parameter can be Buffer object, String,Array,Object<br>res.sendStatus() 200=&gt;OK 403=&gt;Forbidden 404=&gt;NOt FOund 500 =&gt;Internal Server Err</li>\n</ul>\n<hr>\n<h2 id=\"Mongoose\"><a href=\"#Mongoose\" class=\"headerlink\" title=\"Mongoose\"></a><a href=\"#Mongoose\" title=\"Mongoose\"></a>Mongoose</h2><p>1.名词解释<br>　　<font style=\"background=#f1f1f1\">Schema</font>:<strong><em>一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力</em></strong><br>　　<font style=\"background=#f1f1f1\">Model</font>：<strong><em>由Schema发布生成的模型，具有抽象属性和行为的数据库操作对</em></strong><br>　　<font style=\"background=#f1f1f1\">Entity</font>: <strong><em>由Model创建的实体，操作会影响数据库</em></strong></p>\n<ol>\n<li><p>使用</p>\n<pre style=\"background=#f1f1f1\">\nvar mongoose = require(‘mongoose’)//引用mongoose模块\nvar db = mongoose.createConnection(‘localhost’,’test’)//创建数据库连接\n//定义一个**_Schema_**\nvar PersonSchema = new mongoose.Schema({\nname:String //定义一个属性name，类型为String\n})\n//将Schema发布为Model\nvar PersonModel = db.model(‘Person’,PersonSchema)\n//用Model创建Entity\nvar PersonEntity = new PersonModel({name:’Krouky’})\n//Entity是具有具体的数据库操作CRUD的\nPersonEntity.save()\n//执行查询\nPersonModel.find(function(err,persons){})</pre>\n</li>\n<li><p>具体语法<br>更新：<br>1.PersonModel.findById(id,function(err,person){<br>person.name=’Mdragon’<br>person.save=(function(err){})<br>})<br>2.PersonModel.findById(id,function(err,person){<br>person.name=’MDragon’<br>var _id=person._id<br>delete person._id<br>PersonModel.update({_id:_id},person,function(err){})<br>}) // update 第一个参数是查询条件，第二个参数是更新的对象，不可以更新主键<br>PersonModel.update({_id:_id},{$set:{name:’MDragon’}},function(err){})<br>新增：1.使用Entity增加数据<br>var krouky = new PersonModel({name:’krouky’})<br>krouky.save(callback)<br>2.使用Model来增加一条数据<br>var MDragon = {name:’MDragon’}<br>PersonModel.create(MDragon,callback)<br>查询<br>1.PersonModel.findOne({‘name’:’MDragon’},’select’,function({err,person}))<br>2.var query = PersonModel.find({name:’MDragon’})<br>query.select(‘select’)<br>query.exec(function(err,person))<br>验证<br>1.required:非空验证 2.min/max: 范围验证 3. enum/match： 枚举验证 4.validate:自定义验证</p>\n</li>\n</ol>\n<h2 id=\"Cheerio-superagent-爬虫\"><a href=\"#Cheerio-superagent-爬虫\" class=\"headerlink\" title=\"Cheerio + superagent 爬虫\"></a><a href=\"#Cheerio-superagent-爬虫\" title=\"Cheerio + superagent 爬虫\"></a>Cheerio + superagent 爬虫</h2><h2 id=\"cheerio-API\"><a href=\"#cheerio-API\" class=\"headerlink\" title=\"cheerio API\"></a><a href=\"#cheerio-API\" title=\"cheerio API\"></a><strong><em>cheerio API</em></strong></h2><ol>\n<li>npm install cheerio</li>\n<li>将html告诉你的服务器<br><pre style=\"background=#f1f1f1\"><br>var cheerio = require(‘cheerio’)<br>$ = cheerio.load(html)<br>$data = $(data)<br>//接下来即跟jquery用法相同了<br></pre><br><strong><em>superagent API</em></strong></li>\n<li>npm install superagent</li>\n<li>使用<pre style=\"background=#f1f1f1\"><br>var superAgent =require(“superagent”)<br>superAgent.get(url).end(function(err,sres){}) // get<br>superAgent.post(url).send({name:’haha’,species:’cat’}).end(function(res))<br>superAgent.del(url).end(function(res))<br></pre></li>\n</ol>\n<hr>\n<h2 id=\"使用eventproxy控制并发\"><a href=\"#使用eventproxy控制并发\" class=\"headerlink\" title=\"使用eventproxy控制并发\"></a><a href=\"#使用eventproxy控制并发\" title=\"使用eventproxy控制并发\"></a>使用eventproxy控制并发</h2><p><strong><em>eventproxy API</em></strong></p>\n<ol>\n<li>npm install eventproxy</li>\n<li>使用<pre style=\"background=#f1f1f1\"><br>var ep = new EventProxy()<br>ep.all(‘data1_event’,’data2_event’,’data3_event’,function(data1,data2,data2){})<br>//监听了3个事件，当三个事件全部完成后调用回调函数<br>ep.after(‘got_file’,files.length,function(list){})<br>//after方法适合重复异步协作 // files数组 list数组存储的是文件的内容<br>for(var i =0,i<files.length,i++) {=\"\" fs.readfile(files[i],'utf-8',function(err,content){=\"\" ep.emit('got_file',content)=\"\" })=\"\" }=\"\" ep.tail('tp1','data',function(tp1,data))=\"\" 在所有制定事件出发后，将会被调用执行=\"\" <=\"\" pre=\"\"><br></files.length,i++)></pre></li>\n</ol>\n<hr>\n<h2 id=\"使用async控制并发\"><a href=\"#使用async控制并发\" class=\"headerlink\" title=\"使用async控制并发\"></a><a href=\"#使用async控制并发\" title=\"使用async控制并发\"></a>使用async控制并发</h2><p>async的mapLimit(arr,limit,iterator,callback)接口<br>arr:数组 limit:并发量 iterator: 迭代函数 callback:回调函数</p>\n<h2 id=\"mocha-should\"><a href=\"#mocha-should\" class=\"headerlink\" title=\"mocha should\"></a><a href=\"#mocha-should\" title=\"mocha should\"></a>mocha should</h2><ol>\n<li>sudo npm install mocha -g</li>\n<li>npm install should</li>\n<li><p>使用</p>\n<pre>\n//新建一个main.js\nvar fibonacci=function(n){\nif(n==0)\nreturn 0\nif(n==1)\nreturn 1\nreturn fibonacci(n-2)+fibonacci(n-1)\n}\nexports.fibonacci=fibonacci\n//新建一个test.js\nvar main = require(‘./main’)\nvar should = require(‘should’)\ndescript(‘/test.js’,function(){\nit(‘should equal 55 when n ===10’,function(){\n\n    main.fibonacci(10).should.equal(55)\n})\n})\n//执行mocha即可\ndescript:描述的是你要测试的主题，\nit:描述的是具体的case内容\nshould模块：是一个断言库\n</pre>\n\n<h3 id=\"关于exports和module-exports\"><a href=\"#关于exports和module-exports\" class=\"headerlink\" title=\"关于exports和module.exports\"></a><a href=\"#关于exports和module-exports\" title=\"关于exports和module.exports\"></a>关于exports和module.exports</h3></li>\n<li><p>exports是指向<font style=\"color:blue;\">module.exports</font>的引用</p>\n</li>\n<li>module.exports初始值是一个空对象{}</li>\n<li><p>require()返回的是module.exports</p>\n<h3 id=\"ejs\"><a href=\"#ejs\" class=\"headerlink\" title=\"ejs\"></a><a href=\"#ejs\" title=\"ejs\"></a>ejs</h3><p>&lt;%=code%&gt;会对code进行html转义<br>&lt;%-code%&gt;不会对code进行html转义<br>&lt;%code%&gt;执行其中的js代码<br>基础知识仔细回顾一边之后，做个项目来理一理express开发的流程<br>代码在<a href=\"https://github.com/yooki0328\">github</a></p>\n</li>\n</ol>"},{"title":"https的配置","date":"2017-02-27T22:01:09.000Z","_content":"这两天在准备前端面试题，看到了很多关于https的问题，于是乎，打算给自己的博客弄上https，并且写下关于https的心得<!--more-->\n## HTTPS\n### 何为https？\nhttps就是基于http的安全的传输协议。从表面看，当访问一个网站时：如果配置了https，地址栏处则会有绿色的锁，(SSL),换句话说可以通过https进行访问。http是利用了对称加密算法，非对称加密算法，以及hash算法对数据传输进行加密的传输协议。\n### https的握手过程\n当在地址栏处通过https://url 访问一个网站的时候，建立https的过程如下所示：\n1. 浏览器将自己支持的一套加密规则在http的基础上发送给网站\n2. 网站收到浏览器的消息之后，把这个网站的证书(包括 url，公钥，hash算法，加密规则)等发送给浏览器。\n3. 浏览器收到证书之后，对该证书进行验证，如果此证书得到信任，则随机生成一串数字作为密码。然后根据hash算法对握手消息进行计算，并用随机数对其进行加密，然后用公钥对加密过的握手消息及随机数进行加密，发送给网站。\n4. 网站收到加密的握手消息，首先用私钥进行解密，得到加密的握手消息和随机数，用随机数对握手消息进行解密，得到握手消息。并用hash算法进行计算，与浏览器发送过来的进行比较。若一致，然后用密码对一段握手消息进行加密，发送给浏览器.\n5. 浏览器解密握手消息，用hash进行计算判断是否一致，若一致则完成此次握手过程。\n### https与http的区别\nhttp是超文本链接协议。https:安全超文本链接协议，它是http的安全版。\n最大的区别在于:http传输是明文传输，端口号是80。https传输是密文传输，端口号是443,且可以加密传输，身份认证(ssl)\n### https在个人博客的配置\n一般申请CA证书都需要收费，这里使用了Cloudflare(有免费的).\n其原理是：用户访问url的时候，需要进行DNS解析，然后在该域名解析的地方，将该域名解析服务器更改为CF提供的域名服务器，如果在该域名服务器已经添加了解析记录，则CF会起到中转的作用，可以成功的获得该url映射的ip地址，然后就可以访问该url了。\n步骤：\n1. github page 是有自带的https。如果使用了自定义域名的话，则需要自己对其进行配置。以我的博客为例:yooki.top 。 我是在阿里云购买的域名，这里的域名解析设置2个A记录，相应的值为github的ip地址.![](http://of8m1pnnt.bkt.clouddn.com/%E8%A7%A3%E6%9E%90.png)\n2. [CLOUDFLARE](https://www.cloudflare.com/a/add-site)传送.按照引导设置即可\n ![](http://of8m1pnnt.bkt.clouddn.com/nameserver.png)\n3. 更改域名nameserver为CLOUDFLARE的nameserver 等待status从pending转变为active，大约5分钟的等待时间。\n4. 对Crypto进行SSL设置，为flexible，如图所示.![](http://of8m1pnnt.bkt.clouddn.com/flexbile.png)\n5. 对Page Rules进行设置，如图所示\n![](http://of8m1pnnt.bkt.clouddn.com/page%20rules.png)\n![](http://of8m1pnnt.bkt.clouddn.com/page%20rule1.png)\n![](http://of8m1pnnt.bkt.clouddn.com/page%20rule2.png)\n这就结束了，等待一段时间之后就可以通过https进行访问url了.\n","source":"_posts/https.md","raw":"---\ntitle: https的配置\ndate: 2017-02-27 14:01:09\ntags: [https]\n---\n这两天在准备前端面试题，看到了很多关于https的问题，于是乎，打算给自己的博客弄上https，并且写下关于https的心得<!--more-->\n## HTTPS\n### 何为https？\nhttps就是基于http的安全的传输协议。从表面看，当访问一个网站时：如果配置了https，地址栏处则会有绿色的锁，(SSL),换句话说可以通过https进行访问。http是利用了对称加密算法，非对称加密算法，以及hash算法对数据传输进行加密的传输协议。\n### https的握手过程\n当在地址栏处通过https://url 访问一个网站的时候，建立https的过程如下所示：\n1. 浏览器将自己支持的一套加密规则在http的基础上发送给网站\n2. 网站收到浏览器的消息之后，把这个网站的证书(包括 url，公钥，hash算法，加密规则)等发送给浏览器。\n3. 浏览器收到证书之后，对该证书进行验证，如果此证书得到信任，则随机生成一串数字作为密码。然后根据hash算法对握手消息进行计算，并用随机数对其进行加密，然后用公钥对加密过的握手消息及随机数进行加密，发送给网站。\n4. 网站收到加密的握手消息，首先用私钥进行解密，得到加密的握手消息和随机数，用随机数对握手消息进行解密，得到握手消息。并用hash算法进行计算，与浏览器发送过来的进行比较。若一致，然后用密码对一段握手消息进行加密，发送给浏览器.\n5. 浏览器解密握手消息，用hash进行计算判断是否一致，若一致则完成此次握手过程。\n### https与http的区别\nhttp是超文本链接协议。https:安全超文本链接协议，它是http的安全版。\n最大的区别在于:http传输是明文传输，端口号是80。https传输是密文传输，端口号是443,且可以加密传输，身份认证(ssl)\n### https在个人博客的配置\n一般申请CA证书都需要收费，这里使用了Cloudflare(有免费的).\n其原理是：用户访问url的时候，需要进行DNS解析，然后在该域名解析的地方，将该域名解析服务器更改为CF提供的域名服务器，如果在该域名服务器已经添加了解析记录，则CF会起到中转的作用，可以成功的获得该url映射的ip地址，然后就可以访问该url了。\n步骤：\n1. github page 是有自带的https。如果使用了自定义域名的话，则需要自己对其进行配置。以我的博客为例:yooki.top 。 我是在阿里云购买的域名，这里的域名解析设置2个A记录，相应的值为github的ip地址.![](http://of8m1pnnt.bkt.clouddn.com/%E8%A7%A3%E6%9E%90.png)\n2. [CLOUDFLARE](https://www.cloudflare.com/a/add-site)传送.按照引导设置即可\n ![](http://of8m1pnnt.bkt.clouddn.com/nameserver.png)\n3. 更改域名nameserver为CLOUDFLARE的nameserver 等待status从pending转变为active，大约5分钟的等待时间。\n4. 对Crypto进行SSL设置，为flexible，如图所示.![](http://of8m1pnnt.bkt.clouddn.com/flexbile.png)\n5. 对Page Rules进行设置，如图所示\n![](http://of8m1pnnt.bkt.clouddn.com/page%20rules.png)\n![](http://of8m1pnnt.bkt.clouddn.com/page%20rule1.png)\n![](http://of8m1pnnt.bkt.clouddn.com/page%20rule2.png)\n这就结束了，等待一段时间之后就可以通过https进行访问url了.\n","slug":"https","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4r9000foejxtf5fg8bw","content":"<p>这两天在准备前端面试题，看到了很多关于https的问题，于是乎，打算给自己的博客弄上https，并且写下关于https的心得<a id=\"more\"></a></p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><h3 id=\"何为https？\"><a href=\"#何为https？\" class=\"headerlink\" title=\"何为https？\"></a>何为https？</h3><p>https就是基于http的安全的传输协议。从表面看，当访问一个网站时：如果配置了https，地址栏处则会有绿色的锁，(SSL),换句话说可以通过https进行访问。http是利用了对称加密算法，非对称加密算法，以及hash算法对数据传输进行加密的传输协议。</p>\n<h3 id=\"https的握手过程\"><a href=\"#https的握手过程\" class=\"headerlink\" title=\"https的握手过程\"></a>https的握手过程</h3><p>当在地址栏处通过<a href=\"https://url\" target=\"_blank\" rel=\"external\">https://url</a> 访问一个网站的时候，建立https的过程如下所示：</p>\n<ol>\n<li>浏览器将自己支持的一套加密规则在http的基础上发送给网站</li>\n<li>网站收到浏览器的消息之后，把这个网站的证书(包括 url，公钥，hash算法，加密规则)等发送给浏览器。</li>\n<li>浏览器收到证书之后，对该证书进行验证，如果此证书得到信任，则随机生成一串数字作为密码。然后根据hash算法对握手消息进行计算，并用随机数对其进行加密，然后用公钥对加密过的握手消息及随机数进行加密，发送给网站。</li>\n<li>网站收到加密的握手消息，首先用私钥进行解密，得到加密的握手消息和随机数，用随机数对握手消息进行解密，得到握手消息。并用hash算法进行计算，与浏览器发送过来的进行比较。若一致，然后用密码对一段握手消息进行加密，发送给浏览器.</li>\n<li>浏览器解密握手消息，用hash进行计算判断是否一致，若一致则完成此次握手过程。<h3 id=\"https与http的区别\"><a href=\"#https与http的区别\" class=\"headerlink\" title=\"https与http的区别\"></a>https与http的区别</h3>http是超文本链接协议。https:安全超文本链接协议，它是http的安全版。<br>最大的区别在于:http传输是明文传输，端口号是80。https传输是密文传输，端口号是443,且可以加密传输，身份认证(ssl)<h3 id=\"https在个人博客的配置\"><a href=\"#https在个人博客的配置\" class=\"headerlink\" title=\"https在个人博客的配置\"></a>https在个人博客的配置</h3>一般申请CA证书都需要收费，这里使用了Cloudflare(有免费的).<br>其原理是：用户访问url的时候，需要进行DNS解析，然后在该域名解析的地方，将该域名解析服务器更改为CF提供的域名服务器，如果在该域名服务器已经添加了解析记录，则CF会起到中转的作用，可以成功的获得该url映射的ip地址，然后就可以访问该url了。<br>步骤：</li>\n<li>github page 是有自带的https。如果使用了自定义域名的话，则需要自己对其进行配置。以我的博客为例:yooki.top 。 我是在阿里云购买的域名，这里的域名解析设置2个A记录，相应的值为github的ip地址.<img src=\"http://of8m1pnnt.bkt.clouddn.com/%E8%A7%A3%E6%9E%90.png\" alt=\"\"></li>\n<li><a href=\"https://www.cloudflare.com/a/add-site\" target=\"_blank\" rel=\"external\">CLOUDFLARE</a>传送.按照引导设置即可<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/nameserver.png\" alt=\"\"></li>\n<li>更改域名nameserver为CLOUDFLARE的nameserver 等待status从pending转变为active，大约5分钟的等待时间。</li>\n<li>对Crypto进行SSL设置，为flexible，如图所示.<img src=\"http://of8m1pnnt.bkt.clouddn.com/flexbile.png\" alt=\"\"></li>\n<li>对Page Rules进行设置，如图所示<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/page%20rules.png\" alt=\"\"><br><img src=\"http://of8m1pnnt.bkt.clouddn.com/page%20rule1.png\" alt=\"\"><br><img src=\"http://of8m1pnnt.bkt.clouddn.com/page%20rule2.png\" alt=\"\"><br>这就结束了，等待一段时间之后就可以通过https进行访问url了.</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这两天在准备前端面试题，看到了很多关于https的问题，于是乎，打算给自己的博客弄上https，并且写下关于https的心得","more":"</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><h3 id=\"何为https？\"><a href=\"#何为https？\" class=\"headerlink\" title=\"何为https？\"></a>何为https？</h3><p>https就是基于http的安全的传输协议。从表面看，当访问一个网站时：如果配置了https，地址栏处则会有绿色的锁，(SSL),换句话说可以通过https进行访问。http是利用了对称加密算法，非对称加密算法，以及hash算法对数据传输进行加密的传输协议。</p>\n<h3 id=\"https的握手过程\"><a href=\"#https的握手过程\" class=\"headerlink\" title=\"https的握手过程\"></a>https的握手过程</h3><p>当在地址栏处通过<a href=\"https://url\">https://url</a> 访问一个网站的时候，建立https的过程如下所示：</p>\n<ol>\n<li>浏览器将自己支持的一套加密规则在http的基础上发送给网站</li>\n<li>网站收到浏览器的消息之后，把这个网站的证书(包括 url，公钥，hash算法，加密规则)等发送给浏览器。</li>\n<li>浏览器收到证书之后，对该证书进行验证，如果此证书得到信任，则随机生成一串数字作为密码。然后根据hash算法对握手消息进行计算，并用随机数对其进行加密，然后用公钥对加密过的握手消息及随机数进行加密，发送给网站。</li>\n<li>网站收到加密的握手消息，首先用私钥进行解密，得到加密的握手消息和随机数，用随机数对握手消息进行解密，得到握手消息。并用hash算法进行计算，与浏览器发送过来的进行比较。若一致，然后用密码对一段握手消息进行加密，发送给浏览器.</li>\n<li>浏览器解密握手消息，用hash进行计算判断是否一致，若一致则完成此次握手过程。<h3 id=\"https与http的区别\"><a href=\"#https与http的区别\" class=\"headerlink\" title=\"https与http的区别\"></a>https与http的区别</h3>http是超文本链接协议。https:安全超文本链接协议，它是http的安全版。<br>最大的区别在于:http传输是明文传输，端口号是80。https传输是密文传输，端口号是443,且可以加密传输，身份认证(ssl)<h3 id=\"https在个人博客的配置\"><a href=\"#https在个人博客的配置\" class=\"headerlink\" title=\"https在个人博客的配置\"></a>https在个人博客的配置</h3>一般申请CA证书都需要收费，这里使用了Cloudflare(有免费的).<br>其原理是：用户访问url的时候，需要进行DNS解析，然后在该域名解析的地方，将该域名解析服务器更改为CF提供的域名服务器，如果在该域名服务器已经添加了解析记录，则CF会起到中转的作用，可以成功的获得该url映射的ip地址，然后就可以访问该url了。<br>步骤：</li>\n<li>github page 是有自带的https。如果使用了自定义域名的话，则需要自己对其进行配置。以我的博客为例:yooki.top 。 我是在阿里云购买的域名，这里的域名解析设置2个A记录，相应的值为github的ip地址.<img src=\"http://of8m1pnnt.bkt.clouddn.com/%E8%A7%A3%E6%9E%90.png\" alt=\"\"></li>\n<li><a href=\"https://www.cloudflare.com/a/add-site\">CLOUDFLARE</a>传送.按照引导设置即可<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/nameserver.png\" alt=\"\"></li>\n<li>更改域名nameserver为CLOUDFLARE的nameserver 等待status从pending转变为active，大约5分钟的等待时间。</li>\n<li>对Crypto进行SSL设置，为flexible，如图所示.<img src=\"http://of8m1pnnt.bkt.clouddn.com/flexbile.png\" alt=\"\"></li>\n<li>对Page Rules进行设置，如图所示<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/page%20rules.png\" alt=\"\"><br><img src=\"http://of8m1pnnt.bkt.clouddn.com/page%20rule1.png\" alt=\"\"><br><img src=\"http://of8m1pnnt.bkt.clouddn.com/page%20rule2.png\" alt=\"\"><br>这就结束了，等待一段时间之后就可以通过https进行访问url了.</li>\n</ol>"},{"title":"手动实现ES6中的promise","date":"2017-02-28T21:35:21.000Z","_content":"Promise是ES6中的一个重要的概念。promise是一个对象，简单来说，是一个容器，里面保存着某个未来才会结束的事件的结果.从它可以获取异步操作的消息。我们要是实现Promise，就要了解Promise的运行机制以及特点。<!--more-->\n## Promise的特点及用法\n1. 特点：对象有三种状态:Pending,Resolved,Rejected.状态从pending到Resolved，或者 从pending到Rejected。只有这两种状态改变且改变之后不会再改变.\n2. 用法：ES6规定，Promise对象是一个构造函数，用来生成Promise实例.\n3. 实例：\n```javascript\nfunction fn1(resolve,reject){\n  setTimeout(function(){\n    console.log('步骤一:执行')\n    resolve('1')\n  },1000)\n}\nfunction fn2(resolve,reject){\n  setTimeout(function(){\n    console.log('步骤二:执行')\n    resolve('2')\n  },500)\n}\nnew Promise(fn1).then(function(val){\n  console.log(val)\n  return new Promise(fn2)\n}).then(function(val){\n  console.log(val)\n  return 1111\n}).then(function(val){\n  console.log(val)\n})\n```\n运行结果如下图:![]()\n这里解释一下:promise的运行机制:then()是好比一个入队列的操作，把待执行的函数，压入队列中.resolve()好比是一个出队列的操作,取出要执行的函数并执行，且then的返回值是一个新的promise对象.于是乎，我们可以大致写出这么一个对象promise：\n```javascript\nfunction promise(fn){\n  var value = null\n  var self = this\n  self._resolves=[]\n  self._rejects =[]\n  self.then=function(done){\n        self._resolves.push(done)\n        return self\n  }\n  function resolve(value){\n    setTimeout(function(){     //确保执行之前then全部执行完\n      self._resolves.forEach(function(callback){\n        value = callback&&callback(value)\n      })\n    },0)\n  }\n  function reject(reson){\n  \n  }\n  try{\n    fn(resolve,reject)\n  }catch(e){\n    throw e\n  }\n}\n```\n先把fn1添加到resolves中，接着调用then方法依次把function放进队列中，执行到任务队列末尾，调用fn1的settimeout函数，输出'步骤一:执行'，接着调用resolve('1')。\n可以发现这里出现了个问题：如果返回值是promise对象的话，则上一个promise的_resolves数组中的callback无法调用，为了解决这个问题，把then函数改为返回一个promise对象。并且对then中的函数用handle包装起来，如果返回值是promise对象的话，就使 promise.then调用上一个promise的resolve()。这样就可以保证有序的执行，得到我们想要的结果了\n```javascript\nfunction promise(fn){\n  var value = null\n  var self = this\n  self._resolves=[]\n  self._rejects =[]\n  self._status = 'PENDING'\n  this.then=function(onfulfilled){\n    return new promise(function(resolve){\n      function handle(value){\n       var ret = typeof onfulfilled === 'function' &&onfulfilled(value)||value\n        if(ret && ret['then'] === 'function'){\n            ret.then(function(value){\n              resolve(value)\n            })\n        }else {\n          resolve(ret)\n        }\n      }\n      if(self._status === 'PENDING')\n        self._resolves.push(handle)\n      else if(self._status === 'FULFILLED')\n        handle(value)\n    })\n  }\n  function resolve(val){\n    setTimeout(function(){     //确保执行之前then全部执行完\n      self._status = 'FULLFILED'\n      self._resolves.forEach(function(callback){\n\t  callback(val)\n\t})\n\t},0)\n  }\n  function reject(reson){\n  \n  }\n  try{\n    fn(resolve,reject)\n  }catch(e){\n    throw e\n  }\n}\n```\n接下来就是把reject添加进去就大致完成了promise\n```javascript\nfunction promise(fn){\n  var value = null\n  var self = this\n  self._resolves=[]\n  self._rejects =[]\n  self._status = 'PENDING'\n  self.then=function(onfulfilled,onRejected){\n    return new promise(function(resolve){\n      function handle(value){\n       var ret = typeof onfulfilled === 'function' &&onfulfilled(value)||value\n        if(ret && ret['then'] === 'function'){\n            ret.then(function(value){\n              resolve(value)\n            })\n        }else {\n          resolve(ret)\n        }\n      }\n      function errback(reason){\n\treason = isFunction(onRejected)&&onRejected(reason)||reason\n\treject(reason)\n      }\n      if(self._status === 'PENDING'){\n        self._resolves.push(handle)\n\tself._rejects.push(errback)\n      }\n      else if(self._status === 'FULFILLED')\n        handle(value)\n    })else if(self._status === 'REJECTED'){\n\terrback(self._reason)\n\t}\n  }\n  function resolve(val){\n    setTimeout(function(){     //确保执行之前then全部执行完\n      self._status = 'FULLFILED'\n      self._resolves.forEach(function(callback){\n\t  callback(val)\n\t})\n\t},0)\n  }\n  function reject(reson){\n      setTimeout(function(){\n\tself._status = 'REJECTED'\n\tself._rejects.forEach(function(callback){\n\t\tself._reason = callback(value)\n\t})\n\t},0)\n  }\n  try{\n    fn(resolve,reject)\n  }catch(e){\n    throw e\n  }\n}\n```\n这样的话，promise大致就简单的实现了～～～yeah\n***后序更新***\n### promise.all()的实现\npromise.all(args) 参数为一个promise数组，当且进当数组中所有的promise都执行完才执行后续的回调函数.内部的实现原理为:对数组进行遍历，对每个promise元素添加一个回调函数(通过then())，这个回调函数是一个闭包函数，记录着promise元素的返回值和promise执行完的个数，当个数等于数组的长度的时候 代表所有的promise都已经执行完毕.如果有一个reject则promise.all()直接调用reject返回。\n### promise.race()的实现\npromise.race(args) 与all(),差不太多。区别就是当且仅当有一个promise元素resolve之后promise.all()则执行resolve()函数.内部的实现原理为：对数组进行遍历，对每隔promise元素添加一个回调函数(通过then())，这个回调函数同样是一个比包函数，记录着promise元素的返回值和promise失败的个数，当个数等于数组的长度的时候，promise.all()执行reject()函数，当任意一个promise执行过resolve之后，则promise.all()直接调用resovle函数.\n","source":"_posts/promise.md","raw":"---\ntitle: 手动实现ES6中的promise\ndate: 2017-02-28 13:35:21\ntags: [javascript]\n---\nPromise是ES6中的一个重要的概念。promise是一个对象，简单来说，是一个容器，里面保存着某个未来才会结束的事件的结果.从它可以获取异步操作的消息。我们要是实现Promise，就要了解Promise的运行机制以及特点。<!--more-->\n## Promise的特点及用法\n1. 特点：对象有三种状态:Pending,Resolved,Rejected.状态从pending到Resolved，或者 从pending到Rejected。只有这两种状态改变且改变之后不会再改变.\n2. 用法：ES6规定，Promise对象是一个构造函数，用来生成Promise实例.\n3. 实例：\n```javascript\nfunction fn1(resolve,reject){\n  setTimeout(function(){\n    console.log('步骤一:执行')\n    resolve('1')\n  },1000)\n}\nfunction fn2(resolve,reject){\n  setTimeout(function(){\n    console.log('步骤二:执行')\n    resolve('2')\n  },500)\n}\nnew Promise(fn1).then(function(val){\n  console.log(val)\n  return new Promise(fn2)\n}).then(function(val){\n  console.log(val)\n  return 1111\n}).then(function(val){\n  console.log(val)\n})\n```\n运行结果如下图:![]()\n这里解释一下:promise的运行机制:then()是好比一个入队列的操作，把待执行的函数，压入队列中.resolve()好比是一个出队列的操作,取出要执行的函数并执行，且then的返回值是一个新的promise对象.于是乎，我们可以大致写出这么一个对象promise：\n```javascript\nfunction promise(fn){\n  var value = null\n  var self = this\n  self._resolves=[]\n  self._rejects =[]\n  self.then=function(done){\n        self._resolves.push(done)\n        return self\n  }\n  function resolve(value){\n    setTimeout(function(){     //确保执行之前then全部执行完\n      self._resolves.forEach(function(callback){\n        value = callback&&callback(value)\n      })\n    },0)\n  }\n  function reject(reson){\n  \n  }\n  try{\n    fn(resolve,reject)\n  }catch(e){\n    throw e\n  }\n}\n```\n先把fn1添加到resolves中，接着调用then方法依次把function放进队列中，执行到任务队列末尾，调用fn1的settimeout函数，输出'步骤一:执行'，接着调用resolve('1')。\n可以发现这里出现了个问题：如果返回值是promise对象的话，则上一个promise的_resolves数组中的callback无法调用，为了解决这个问题，把then函数改为返回一个promise对象。并且对then中的函数用handle包装起来，如果返回值是promise对象的话，就使 promise.then调用上一个promise的resolve()。这样就可以保证有序的执行，得到我们想要的结果了\n```javascript\nfunction promise(fn){\n  var value = null\n  var self = this\n  self._resolves=[]\n  self._rejects =[]\n  self._status = 'PENDING'\n  this.then=function(onfulfilled){\n    return new promise(function(resolve){\n      function handle(value){\n       var ret = typeof onfulfilled === 'function' &&onfulfilled(value)||value\n        if(ret && ret['then'] === 'function'){\n            ret.then(function(value){\n              resolve(value)\n            })\n        }else {\n          resolve(ret)\n        }\n      }\n      if(self._status === 'PENDING')\n        self._resolves.push(handle)\n      else if(self._status === 'FULFILLED')\n        handle(value)\n    })\n  }\n  function resolve(val){\n    setTimeout(function(){     //确保执行之前then全部执行完\n      self._status = 'FULLFILED'\n      self._resolves.forEach(function(callback){\n\t  callback(val)\n\t})\n\t},0)\n  }\n  function reject(reson){\n  \n  }\n  try{\n    fn(resolve,reject)\n  }catch(e){\n    throw e\n  }\n}\n```\n接下来就是把reject添加进去就大致完成了promise\n```javascript\nfunction promise(fn){\n  var value = null\n  var self = this\n  self._resolves=[]\n  self._rejects =[]\n  self._status = 'PENDING'\n  self.then=function(onfulfilled,onRejected){\n    return new promise(function(resolve){\n      function handle(value){\n       var ret = typeof onfulfilled === 'function' &&onfulfilled(value)||value\n        if(ret && ret['then'] === 'function'){\n            ret.then(function(value){\n              resolve(value)\n            })\n        }else {\n          resolve(ret)\n        }\n      }\n      function errback(reason){\n\treason = isFunction(onRejected)&&onRejected(reason)||reason\n\treject(reason)\n      }\n      if(self._status === 'PENDING'){\n        self._resolves.push(handle)\n\tself._rejects.push(errback)\n      }\n      else if(self._status === 'FULFILLED')\n        handle(value)\n    })else if(self._status === 'REJECTED'){\n\terrback(self._reason)\n\t}\n  }\n  function resolve(val){\n    setTimeout(function(){     //确保执行之前then全部执行完\n      self._status = 'FULLFILED'\n      self._resolves.forEach(function(callback){\n\t  callback(val)\n\t})\n\t},0)\n  }\n  function reject(reson){\n      setTimeout(function(){\n\tself._status = 'REJECTED'\n\tself._rejects.forEach(function(callback){\n\t\tself._reason = callback(value)\n\t})\n\t},0)\n  }\n  try{\n    fn(resolve,reject)\n  }catch(e){\n    throw e\n  }\n}\n```\n这样的话，promise大致就简单的实现了～～～yeah\n***后序更新***\n### promise.all()的实现\npromise.all(args) 参数为一个promise数组，当且进当数组中所有的promise都执行完才执行后续的回调函数.内部的实现原理为:对数组进行遍历，对每个promise元素添加一个回调函数(通过then())，这个回调函数是一个闭包函数，记录着promise元素的返回值和promise执行完的个数，当个数等于数组的长度的时候 代表所有的promise都已经执行完毕.如果有一个reject则promise.all()直接调用reject返回。\n### promise.race()的实现\npromise.race(args) 与all(),差不太多。区别就是当且仅当有一个promise元素resolve之后promise.all()则执行resolve()函数.内部的实现原理为：对数组进行遍历，对每隔promise元素添加一个回调函数(通过then())，这个回调函数同样是一个比包函数，记录着promise元素的返回值和promise失败的个数，当个数等于数组的长度的时候，promise.all()执行reject()函数，当任意一个promise执行过resolve之后，则promise.all()直接调用resovle函数.\n","slug":"promise","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4rb000ioejxhwnosfdw","content":"<p>Promise是ES6中的一个重要的概念。promise是一个对象，简单来说，是一个容器，里面保存着某个未来才会结束的事件的结果.从它可以获取异步操作的消息。我们要是实现Promise，就要了解Promise的运行机制以及特点。<a id=\"more\"></a></p>\n<h2 id=\"Promise的特点及用法\"><a href=\"#Promise的特点及用法\" class=\"headerlink\" title=\"Promise的特点及用法\"></a>Promise的特点及用法</h2><ol>\n<li>特点：对象有三种状态:Pending,Resolved,Rejected.状态从pending到Resolved，或者 从pending到Rejected。只有这两种状态改变且改变之后不会再改变.</li>\n<li>用法：ES6规定，Promise对象是一个构造函数，用来生成Promise实例.</li>\n<li>实例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'步骤一:执行'</span>)</div><div class=\"line\">    resolve(<span class=\"string\">'1'</span>)</div><div class=\"line\">  &#125;,<span class=\"number\">1000</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'步骤二:执行'</span>)</div><div class=\"line\">    resolve(<span class=\"string\">'2'</span>)</div><div class=\"line\">  &#125;,<span class=\"number\">500</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(fn1).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(val)</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(fn2)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(val)</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1111</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(val)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果如下图:<img src=\"\" alt=\"\"><br>这里解释一下:promise的运行机制:then()是好比一个入队列的操作，把待执行的函数，压入队列中.resolve()好比是一个出队列的操作,取出要执行的函数并执行，且then的返回值是一个新的promise对象.于是乎，我们可以大致写出这么一个对象promise：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promise</span>(<span class=\"params\">fn</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  self._resolves=[]</div><div class=\"line\">  self._rejects =[]</div><div class=\"line\">  self.then=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">        self._resolves.push(done)</div><div class=\"line\">        <span class=\"keyword\">return</span> self</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//确保执行之前then全部执行完</span></div><div class=\"line\">      self._resolves.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">        value = callback&amp;&amp;callback(value)</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reson</span>)</span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    fn(resolve,reject)</div><div class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> e</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>先把fn1添加到resolves中，接着调用then方法依次把function放进队列中，执行到任务队列末尾，调用fn1的settimeout函数，输出’步骤一:执行’，接着调用resolve(‘1’)。<br>可以发现这里出现了个问题：如果返回值是promise对象的话，则上一个promise的_resolves数组中的callback无法调用，为了解决这个问题，把then函数改为返回一个promise对象。并且对then中的函数用handle包装起来，如果返回值是promise对象的话，就使 promise.then调用上一个promise的resolve()。这样就可以保证有序的执行，得到我们想要的结果了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promise</span>(<span class=\"params\">fn</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  self._resolves=[]</div><div class=\"line\">  self._rejects =[]</div><div class=\"line\">  self._status = <span class=\"string\">'PENDING'</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.then=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onfulfilled</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> promise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> ret = <span class=\"keyword\">typeof</span> onfulfilled === <span class=\"string\">'function'</span> &amp;&amp;onfulfilled(value)||value</div><div class=\"line\">        <span class=\"keyword\">if</span>(ret &amp;&amp; ret[<span class=\"string\">'then'</span>] === <span class=\"string\">'function'</span>)&#123;</div><div class=\"line\">            ret.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">              resolve(value)</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          resolve(ret)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'PENDING'</span>)</div><div class=\"line\">        self._resolves.push(handle)</div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'FULFILLED'</span>)</div><div class=\"line\">        handle(value)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//确保执行之前then全部执行完</span></div><div class=\"line\">      self._status = <span class=\"string\">'FULLFILED'</span></div><div class=\"line\">      self._resolves.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">\t  callback(val)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t&#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reson</span>)</span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    fn(resolve,reject)</div><div class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> e</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来就是把reject添加进去就大致完成了promise<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promise</span>(<span class=\"params\">fn</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  self._resolves=[]</div><div class=\"line\">  self._rejects =[]</div><div class=\"line\">  self._status = <span class=\"string\">'PENDING'</span></div><div class=\"line\">  self.then=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onfulfilled,onRejected</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> promise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> ret = <span class=\"keyword\">typeof</span> onfulfilled === <span class=\"string\">'function'</span> &amp;&amp;onfulfilled(value)||value</div><div class=\"line\">        <span class=\"keyword\">if</span>(ret &amp;&amp; ret[<span class=\"string\">'then'</span>] === <span class=\"string\">'function'</span>)&#123;</div><div class=\"line\">            ret.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">              resolve(value)</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          resolve(ret)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errback</span>(<span class=\"params\">reason</span>)</span>&#123;</div><div class=\"line\">\treason = isFunction(onRejected)&amp;&amp;onRejected(reason)||reason</div><div class=\"line\">\treject(reason)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'PENDING'</span>)&#123;</div><div class=\"line\">        self._resolves.push(handle)</div><div class=\"line\">\tself._rejects.push(errback)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'FULFILLED'</span>)</div><div class=\"line\">        handle(value)</div><div class=\"line\">    &#125;)<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'REJECTED'</span>)&#123;</div><div class=\"line\">\terrback(self._reason)</div><div class=\"line\">\t&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//确保执行之前then全部执行完</span></div><div class=\"line\">      self._status = <span class=\"string\">'FULLFILED'</span></div><div class=\"line\">      self._resolves.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">\t  callback(val)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t&#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reson</span>)</span>&#123;</div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\tself._status = <span class=\"string\">'REJECTED'</span></div><div class=\"line\">\tself._rejects.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">\t\tself._reason = callback(value)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t&#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    fn(resolve,reject)</div><div class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> e</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的话，promise大致就简单的实现了～～～yeah<br><strong><em>后序更新</em></strong></p>\n<h3 id=\"promise-all-的实现\"><a href=\"#promise-all-的实现\" class=\"headerlink\" title=\"promise.all()的实现\"></a>promise.all()的实现</h3><p>promise.all(args) 参数为一个promise数组，当且进当数组中所有的promise都执行完才执行后续的回调函数.内部的实现原理为:对数组进行遍历，对每个promise元素添加一个回调函数(通过then())，这个回调函数是一个闭包函数，记录着promise元素的返回值和promise执行完的个数，当个数等于数组的长度的时候 代表所有的promise都已经执行完毕.如果有一个reject则promise.all()直接调用reject返回。</p>\n<h3 id=\"promise-race-的实现\"><a href=\"#promise-race-的实现\" class=\"headerlink\" title=\"promise.race()的实现\"></a>promise.race()的实现</h3><p>promise.race(args) 与all(),差不太多。区别就是当且仅当有一个promise元素resolve之后promise.all()则执行resolve()函数.内部的实现原理为：对数组进行遍历，对每隔promise元素添加一个回调函数(通过then())，这个回调函数同样是一个比包函数，记录着promise元素的返回值和promise失败的个数，当个数等于数组的长度的时候，promise.all()执行reject()函数，当任意一个promise执行过resolve之后，则promise.all()直接调用resovle函数.</p>\n","site":{"data":{}},"excerpt":"<p>Promise是ES6中的一个重要的概念。promise是一个对象，简单来说，是一个容器，里面保存着某个未来才会结束的事件的结果.从它可以获取异步操作的消息。我们要是实现Promise，就要了解Promise的运行机制以及特点。","more":"</p>\n<h2 id=\"Promise的特点及用法\"><a href=\"#Promise的特点及用法\" class=\"headerlink\" title=\"Promise的特点及用法\"></a>Promise的特点及用法</h2><ol>\n<li>特点：对象有三种状态:Pending,Resolved,Rejected.状态从pending到Resolved，或者 从pending到Rejected。只有这两种状态改变且改变之后不会再改变.</li>\n<li>用法：ES6规定，Promise对象是一个构造函数，用来生成Promise实例.</li>\n<li>实例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'步骤一:执行'</span>)</div><div class=\"line\">    resolve(<span class=\"string\">'1'</span>)</div><div class=\"line\">  &#125;,<span class=\"number\">1000</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'步骤二:执行'</span>)</div><div class=\"line\">    resolve(<span class=\"string\">'2'</span>)</div><div class=\"line\">  &#125;,<span class=\"number\">500</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(fn1).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(val)</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(fn2)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(val)</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1111</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(val)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>运行结果如下图:<img src=\"\" alt=\"\"><br>这里解释一下:promise的运行机制:then()是好比一个入队列的操作，把待执行的函数，压入队列中.resolve()好比是一个出队列的操作,取出要执行的函数并执行，且then的返回值是一个新的promise对象.于是乎，我们可以大致写出这么一个对象promise：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promise</span>(<span class=\"params\">fn</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  self._resolves=[]</div><div class=\"line\">  self._rejects =[]</div><div class=\"line\">  self.then=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">        self._resolves.push(done)</div><div class=\"line\">        <span class=\"keyword\">return</span> self</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//确保执行之前then全部执行完</span></div><div class=\"line\">      self._resolves.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">        value = callback&amp;&amp;callback(value)</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reson</span>)</span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    fn(resolve,reject)</div><div class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> e</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>先把fn1添加到resolves中，接着调用then方法依次把function放进队列中，执行到任务队列末尾，调用fn1的settimeout函数，输出’步骤一:执行’，接着调用resolve(‘1’)。<br>可以发现这里出现了个问题：如果返回值是promise对象的话，则上一个promise的_resolves数组中的callback无法调用，为了解决这个问题，把then函数改为返回一个promise对象。并且对then中的函数用handle包装起来，如果返回值是promise对象的话，就使 promise.then调用上一个promise的resolve()。这样就可以保证有序的执行，得到我们想要的结果了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promise</span>(<span class=\"params\">fn</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  self._resolves=[]</div><div class=\"line\">  self._rejects =[]</div><div class=\"line\">  self._status = <span class=\"string\">'PENDING'</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.then=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onfulfilled</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> promise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> ret = <span class=\"keyword\">typeof</span> onfulfilled === <span class=\"string\">'function'</span> &amp;&amp;onfulfilled(value)||value</div><div class=\"line\">        <span class=\"keyword\">if</span>(ret &amp;&amp; ret[<span class=\"string\">'then'</span>] === <span class=\"string\">'function'</span>)&#123;</div><div class=\"line\">            ret.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">              resolve(value)</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          resolve(ret)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'PENDING'</span>)</div><div class=\"line\">        self._resolves.push(handle)</div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'FULFILLED'</span>)</div><div class=\"line\">        handle(value)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//确保执行之前then全部执行完</span></div><div class=\"line\">      self._status = <span class=\"string\">'FULLFILED'</span></div><div class=\"line\">      self._resolves.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">\t  callback(val)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t&#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reson</span>)</span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    fn(resolve,reject)</div><div class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> e</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来就是把reject添加进去就大致完成了promise<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promise</span>(<span class=\"params\">fn</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></div><div class=\"line\">  self._resolves=[]</div><div class=\"line\">  self._rejects =[]</div><div class=\"line\">  self._status = <span class=\"string\">'PENDING'</span></div><div class=\"line\">  self.then=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onfulfilled,onRejected</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> promise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> ret = <span class=\"keyword\">typeof</span> onfulfilled === <span class=\"string\">'function'</span> &amp;&amp;onfulfilled(value)||value</div><div class=\"line\">        <span class=\"keyword\">if</span>(ret &amp;&amp; ret[<span class=\"string\">'then'</span>] === <span class=\"string\">'function'</span>)&#123;</div><div class=\"line\">            ret.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</div><div class=\"line\">              resolve(value)</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          resolve(ret)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errback</span>(<span class=\"params\">reason</span>)</span>&#123;</div><div class=\"line\">\treason = isFunction(onRejected)&amp;&amp;onRejected(reason)||reason</div><div class=\"line\">\treject(reason)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'PENDING'</span>)&#123;</div><div class=\"line\">        self._resolves.push(handle)</div><div class=\"line\">\tself._rejects.push(errback)</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'FULFILLED'</span>)</div><div class=\"line\">        handle(value)</div><div class=\"line\">    &#125;)<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(self._status === <span class=\"string\">'REJECTED'</span>)&#123;</div><div class=\"line\">\terrback(self._reason)</div><div class=\"line\">\t&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">val</span>)</span>&#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;     <span class=\"comment\">//确保执行之前then全部执行完</span></div><div class=\"line\">      self._status = <span class=\"string\">'FULLFILED'</span></div><div class=\"line\">      self._resolves.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">\t  callback(val)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t&#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reson</span>)</span>&#123;</div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\tself._status = <span class=\"string\">'REJECTED'</span></div><div class=\"line\">\tself._rejects.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>&#123;</div><div class=\"line\">\t\tself._reason = callback(value)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t&#125;,<span class=\"number\">0</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    fn(resolve,reject)</div><div class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> e</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的话，promise大致就简单的实现了～～～yeah<br><strong><em>后序更新</em></strong></p>\n<h3 id=\"promise-all-的实现\"><a href=\"#promise-all-的实现\" class=\"headerlink\" title=\"promise.all()的实现\"></a>promise.all()的实现</h3><p>promise.all(args) 参数为一个promise数组，当且进当数组中所有的promise都执行完才执行后续的回调函数.内部的实现原理为:对数组进行遍历，对每个promise元素添加一个回调函数(通过then())，这个回调函数是一个闭包函数，记录着promise元素的返回值和promise执行完的个数，当个数等于数组的长度的时候 代表所有的promise都已经执行完毕.如果有一个reject则promise.all()直接调用reject返回。</p>\n<h3 id=\"promise-race-的实现\"><a href=\"#promise-race-的实现\" class=\"headerlink\" title=\"promise.race()的实现\"></a>promise.race()的实现</h3><p>promise.race(args) 与all(),差不太多。区别就是当且仅当有一个promise元素resolve之后promise.all()则执行resolve()函数.内部的实现原理为：对数组进行遍历，对每隔promise元素添加一个回调函数(通过then())，这个回调函数同样是一个比包函数，记录着promise元素的返回值和promise失败的个数，当个数等于数组的长度的时候，promise.all()执行reject()函数，当任意一个promise执行过resolve之后，则promise.all()直接调用resovle函数.</p>"},{"title":"正则表达式","date":"2016-09-23T10:49:39.000Z","_content":"### **什么是 RegExp？**\nRegExp 是正则表达式的缩写。\n当您检索某个文本时，可以使用一种模式来描述要检索的内容。RegExp 就是这种模式。\n简单的模式可以是一个单独的字符。\n更复杂的模式包括了更多的字符，并可用于解析、格式检查、替换等等。\n您可以规定字符串中的检索位置，以及要检索的字符类型，等等。<!--more-->\n<table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>\\b</td><td>代表着**_单词的开头或结尾(单词分界处)_**</td></tr><tr><td>\\d</td><td>匹配一位数字</td></tr><tr><td>{n}</td><td>重复匹配n次</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配字符串结束位置</td></tr><tr><td>*</td><td>匹配前面的表达式0次或多次</td></tr><tr><td>+</td><td>匹配前面的表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的表达式0次或一次,跟在任何一个其他限制符后面时,匹配模式是非贪婪的</td></tr><tr><td>{n,m}</td><td>至少匹配n次最多匹配m次</td></tr><tr><td>.</td><td>匹配除”\\n”之外的任何单个字符</td></tr><tr><td>\\w</td><td>匹配包括下划线的任何单词字符</td></tr><tr><td>\\W</td><td>匹配任何非单词字符</td></tr></tbody></table>\n(?0\\d{2}[) -]?\\d{8}\n这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n### 分支条件|\n(?=exp)也叫零宽度正预测先行断言\n(?<=exp)也叫零宽度正回顾后发断言\n零宽度负预测先行断言(?!exp)\n零宽度负回顾后发断言(?<!exp)\n(?<=<(\\w+)>).*(?=<\\/\\1>)匹配不包含属性的简单HTML标签内里的内容\njs 中，正则表达式后面可以跟三个 flag，比如 /something/igm\n\n* i 的意义是不区分大小写\n* g 的意义是，匹配多个\n* m 的意义是，是 ^ 和 $ 可以匹配每一行的开头\n```javascript\n/a/.test(‘A’) // => false\n/a/i.test(‘A’) // => true\n‘hello hell hoo’.match(/h.?\\b/) // => [ ‘hello’, index: 0, input: ‘hello hell hoo’ ]\n‘hello hell hoo’.match(/h.?\\b/g) // => [ ‘hello’, ‘hell’, ‘hoo’ ]\n‘aaa\\nbbb\\nccc’.match(/^[\\s\\S]?$/g) // => [ ‘aaa\\nbbb\\nccc’ ]\n‘aaa\\nbbb\\nccc’.match(/^[\\s\\S]?$/gm) // => [ ‘aaa’, ‘bbb’, ‘ccc’ ]\n```\n直接用 . 匹配不到 \\n，所以我们需要找到一个原子，能匹配包括 \\n 在内的所有字符。这个原子的惯用写法就是 [\\s\\S]\n```javascript\nvar match1 = text.match(/^```[\\s\\S]+?^```/gm);\nconsole.log(match1) // => [ '```\\ncode code2 code3```\\n```' ]\n\n// 这里有一种很骚的写法，[^] 与 [\\s\\S] 等价\nvar match2 = text.match(/^```[^]+?^```/gm)\nconsole.log(match2) // => [ '```\\ncode code2 .code3```\\n```' ]\n```\n","source":"_posts/regexp.md","raw":"---\ntitle: 正则表达式\ndate: 2016-09-23 03:49:39\ntags: [regexp]\n---\n### **什么是 RegExp？**\nRegExp 是正则表达式的缩写。\n当您检索某个文本时，可以使用一种模式来描述要检索的内容。RegExp 就是这种模式。\n简单的模式可以是一个单独的字符。\n更复杂的模式包括了更多的字符，并可用于解析、格式检查、替换等等。\n您可以规定字符串中的检索位置，以及要检索的字符类型，等等。<!--more-->\n<table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>\\b</td><td>代表着**_单词的开头或结尾(单词分界处)_**</td></tr><tr><td>\\d</td><td>匹配一位数字</td></tr><tr><td>{n}</td><td>重复匹配n次</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配字符串结束位置</td></tr><tr><td>*</td><td>匹配前面的表达式0次或多次</td></tr><tr><td>+</td><td>匹配前面的表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的表达式0次或一次,跟在任何一个其他限制符后面时,匹配模式是非贪婪的</td></tr><tr><td>{n,m}</td><td>至少匹配n次最多匹配m次</td></tr><tr><td>.</td><td>匹配除”\\n”之外的任何单个字符</td></tr><tr><td>\\w</td><td>匹配包括下划线的任何单词字符</td></tr><tr><td>\\W</td><td>匹配任何非单词字符</td></tr></tbody></table>\n(?0\\d{2}[) -]?\\d{8}\n这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。\n### 分支条件|\n(?=exp)也叫零宽度正预测先行断言\n(?<=exp)也叫零宽度正回顾后发断言\n零宽度负预测先行断言(?!exp)\n零宽度负回顾后发断言(?<!exp)\n(?<=<(\\w+)>).*(?=<\\/\\1>)匹配不包含属性的简单HTML标签内里的内容\njs 中，正则表达式后面可以跟三个 flag，比如 /something/igm\n\n* i 的意义是不区分大小写\n* g 的意义是，匹配多个\n* m 的意义是，是 ^ 和 $ 可以匹配每一行的开头\n```javascript\n/a/.test(‘A’) // => false\n/a/i.test(‘A’) // => true\n‘hello hell hoo’.match(/h.?\\b/) // => [ ‘hello’, index: 0, input: ‘hello hell hoo’ ]\n‘hello hell hoo’.match(/h.?\\b/g) // => [ ‘hello’, ‘hell’, ‘hoo’ ]\n‘aaa\\nbbb\\nccc’.match(/^[\\s\\S]?$/g) // => [ ‘aaa\\nbbb\\nccc’ ]\n‘aaa\\nbbb\\nccc’.match(/^[\\s\\S]?$/gm) // => [ ‘aaa’, ‘bbb’, ‘ccc’ ]\n```\n直接用 . 匹配不到 \\n，所以我们需要找到一个原子，能匹配包括 \\n 在内的所有字符。这个原子的惯用写法就是 [\\s\\S]\n```javascript\nvar match1 = text.match(/^```[\\s\\S]+?^```/gm);\nconsole.log(match1) // => [ '```\\ncode code2 code3```\\n```' ]\n\n// 这里有一种很骚的写法，[^] 与 [\\s\\S] 等价\nvar match2 = text.match(/^```[^]+?^```/gm)\nconsole.log(match2) // => [ '```\\ncode code2 .code3```\\n```' ]\n```\n","slug":"regexp","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4rd000joejxi31gwnzt","content":"<h3 id=\"什么是-RegExp？\"><a href=\"#什么是-RegExp？\" class=\"headerlink\" title=\"什么是 RegExp？\"></a><strong>什么是 RegExp？</strong></h3><p>RegExp 是正则表达式的缩写。<br>当您检索某个文本时，可以使用一种模式来描述要检索的内容。RegExp 就是这种模式。<br>简单的模式可以是一个单独的字符。<br>更复杂的模式包括了更多的字符，并可用于解析、格式检查、替换等等。<br>您可以规定字符串中的检索位置，以及要检索的字符类型，等等。<a id=\"more\"></a></p>\n<p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>\\b</td><td>代表着<strong><em>单词的开头或结尾(单词分界处)</em></strong></td></tr><tr><td>\\d</td><td>匹配一位数字</td></tr><tr><td>{n}</td><td>重复匹配n次</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配字符串结束位置</td></tr><tr><td>*</td><td>匹配前面的表达式0次或多次</td></tr><tr><td>+</td><td>匹配前面的表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的表达式0次或一次,跟在任何一个其他限制符后面时,匹配模式是非贪婪的</td></tr><tr><td>{n,m}</td><td>至少匹配n次最多匹配m次</td></tr><tr><td>.</td><td>匹配除”\\n”之外的任何单个字符</td></tr><tr><td>\\w</td><td>匹配包括下划线的任何单词字符</td></tr><tr><td>\\W</td><td>匹配任何非单词字符</td></tr></tbody></table><br>(?0\\d{2}[) -]?\\d{8}<br>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n<h3 id=\"分支条件\"><a href=\"#分支条件\" class=\"headerlink\" title=\"分支条件|\"></a>分支条件|</h3><p>(?=exp)也叫零宽度正预测先行断言<br>(?&lt;=exp)也叫零宽度正回顾后发断言<br>零宽度负预测先行断言(?!exp)<br>零宽度负回顾后发断言(?&lt;!exp)<br>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容<br>js 中，正则表达式后面可以跟三个 flag，比如 /something/igm</p>\n<ul>\n<li>i 的意义是不区分大小写</li>\n<li>g 的意义是，匹配多个</li>\n<li>m 的意义是，是 ^ 和 $ 可以匹配每一行的开头<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">/a/.test(‘A’) <span class=\"comment\">// =&gt; false</span></div><div class=\"line\">/a/i.test(‘A’) <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">‘hello hell hoo’.match(<span class=\"regexp\">/h.?\\b/</span>) <span class=\"comment\">// =&gt; [ ‘hello’, index: 0, input: ‘hello hell hoo’ ]</span></div><div class=\"line\">‘hello hell hoo’.match(<span class=\"regexp\">/h.?\\b/g</span>) <span class=\"comment\">// =&gt; [ ‘hello’, ‘hell’, ‘hoo’ ]</span></div><div class=\"line\">‘aaa\\nbbb\\nccc’.match(<span class=\"regexp\">/^[\\s\\S]?$/g</span>) <span class=\"comment\">// =&gt; [ ‘aaa\\nbbb\\nccc’ ]</span></div><div class=\"line\">‘aaa\\nbbb\\nccc’.match(<span class=\"regexp\">/^[\\s\\S]?$/gm</span>) <span class=\"comment\">// =&gt; [ ‘aaa’, ‘bbb’, ‘ccc’ ]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>直接用 . 匹配不到 \\n，所以我们需要找到一个原子，能匹配包括 \\n 在内的所有字符。这个原子的惯用写法就是 [\\s\\S]<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> match1 = text.match(<span class=\"regexp\">/^```[\\s\\S]+?^```/gm</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(match1) <span class=\"comment\">// =&gt; [ '```\\ncode code2 code3```\\n```' ]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这里有一种很骚的写法，[^] 与 [\\s\\S] 等价</span></div><div class=\"line\"><span class=\"keyword\">var</span> match2 = text.match(<span class=\"regexp\">/^```[^]+?^```/gm</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(match2) <span class=\"comment\">// =&gt; [ '```\\ncode code2 .code3```\\n```' ]</span></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是-RegExp？\"><a href=\"#什么是-RegExp？\" class=\"headerlink\" title=\"什么是 RegExp？\"></a><strong>什么是 RegExp？</strong></h3><p>RegExp 是正则表达式的缩写。<br>当您检索某个文本时，可以使用一种模式来描述要检索的内容。RegExp 就是这种模式。<br>简单的模式可以是一个单独的字符。<br>更复杂的模式包括了更多的字符，并可用于解析、格式检查、替换等等。<br>您可以规定字符串中的检索位置，以及要检索的字符类型，等等。","more":"</p>\n<p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>\\b</td><td>代表着<strong><em>单词的开头或结尾(单词分界处)</em></strong></td></tr><tr><td>\\d</td><td>匹配一位数字</td></tr><tr><td>{n}</td><td>重复匹配n次</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配字符串结束位置</td></tr><tr><td>*</td><td>匹配前面的表达式0次或多次</td></tr><tr><td>+</td><td>匹配前面的表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的表达式0次或一次,跟在任何一个其他限制符后面时,匹配模式是非贪婪的</td></tr><tr><td>{n,m}</td><td>至少匹配n次最多匹配m次</td></tr><tr><td>.</td><td>匹配除”\\n”之外的任何单个字符</td></tr><tr><td>\\w</td><td>匹配包括下划线的任何单词字符</td></tr><tr><td>\\W</td><td>匹配任何非单词字符</td></tr></tbody></table><br>(?0\\d{2}[) -]?\\d{8}<br>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n<h3 id=\"分支条件\"><a href=\"#分支条件\" class=\"headerlink\" title=\"分支条件|\"></a>分支条件|</h3><p>(?=exp)也叫零宽度正预测先行断言<br>(?&lt;=exp)也叫零宽度正回顾后发断言<br>零宽度负预测先行断言(?!exp)<br>零宽度负回顾后发断言(?&lt;!exp)<br>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容<br>js 中，正则表达式后面可以跟三个 flag，比如 /something/igm</p>\n<ul>\n<li>i 的意义是不区分大小写</li>\n<li>g 的意义是，匹配多个</li>\n<li>m 的意义是，是 ^ 和 $ 可以匹配每一行的开头<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">/a/.test(‘A’) <span class=\"comment\">// =&gt; false</span></div><div class=\"line\">/a/i.test(‘A’) <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">‘hello hell hoo’.match(<span class=\"regexp\">/h.?\\b/</span>) <span class=\"comment\">// =&gt; [ ‘hello’, index: 0, input: ‘hello hell hoo’ ]</span></div><div class=\"line\">‘hello hell hoo’.match(<span class=\"regexp\">/h.?\\b/g</span>) <span class=\"comment\">// =&gt; [ ‘hello’, ‘hell’, ‘hoo’ ]</span></div><div class=\"line\">‘aaa\\nbbb\\nccc’.match(<span class=\"regexp\">/^[\\s\\S]?$/g</span>) <span class=\"comment\">// =&gt; [ ‘aaa\\nbbb\\nccc’ ]</span></div><div class=\"line\">‘aaa\\nbbb\\nccc’.match(<span class=\"regexp\">/^[\\s\\S]?$/gm</span>) <span class=\"comment\">// =&gt; [ ‘aaa’, ‘bbb’, ‘ccc’ ]</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>直接用 . 匹配不到 \\n，所以我们需要找到一个原子，能匹配包括 \\n 在内的所有字符。这个原子的惯用写法就是 [\\s\\S]<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> match1 = text.match(<span class=\"regexp\">/^```[\\s\\S]+?^```/gm</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(match1) <span class=\"comment\">// =&gt; [ '```\\ncode code2 code3```\\n```' ]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这里有一种很骚的写法，[^] 与 [\\s\\S] 等价</span></div><div class=\"line\"><span class=\"keyword\">var</span> match2 = text.match(<span class=\"regexp\">/^```[^]+?^```/gm</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(match2) <span class=\"comment\">// =&gt; [ '```\\ncode code2 .code3```\\n```' ]</span></div></pre></td></tr></table></figure></p>"},{"title":"从输入url到显示页面的步骤(详细)","date":"2017-04-14T04:39:14.000Z","_content":"这个问题在前端面试中会经常被问到。作为一个前端工程师，明白网页从输入URL到显示页面到底发生了什么，这是一件很有必要的事情.\n**从表面上分为以下几个过程**\n1. 输入URL->DNS解析\n2. 与服务器建立TCP连接\n3. 发送HTTP请求\n4. 服务器发送回应报文\n5. 浏览器解析HTML文档并渲染页面\n<!--more-->\n## DNS解析\n当输入url时，比如www.google.com，经过DNS解析为一个IP地址，这个IP地址就是服务器的地址。\n### 域的划分\n根域->顶级域->二级域名->三级域名......\n举个例子\n.com是根域名，baidu.com是顶级域名，www.baidu.com是二级域名.\n### 域名服务器\n能提供域名解析的服务器,上面的记录类型可以是A记录,NS记录,MX记录,CNAME\n接下来一一解释这几个记录的意思：\n* A记录：记录一个IP地址和一个主机名字(或者域名)，表示记录了主机为a的IP。\n* NS记录：NS即Name Server，用来指定该域名由哪个DNS服务器进行解析\n* CNAME记录：别名记录.这种记录允许将多个名字映射到同一台计算机上\n### 解析过程\n当我要通过浏览器访问一个网址的时候，根据电脑网络设置里的DNS，向这个域名解析服务器发送请求，然后本地DNS域名解析服务器会检查自己的缓存是否拥有这个地址，有的话直接返回所对应的IP地址.如果缓存中没有的话，就会从配置文件中读取根域名服务器的地址，然后依次从根域名服务器到顶级域名服务器到本地域名服务器，这样得到了要访问的主机的IP地址。其实就是一个递归查询的过程\n## TCP连接\n通过三次握手建立TCP连接.过程是：\n1.客户机向服务器发送连接请求: SYN=1,seq=client_isn\n2.服务器收到请求，回应: ack = client_isn+1,SYN=1,seq=server_isn\n3.客户机收到回应之后发送回应:ack = server_isn+1,SYN=0,seq=client_isn+1\n## 发送HTTP请求\n建立TCP连接之后，发送HTTP请求，HTTP报文包裹在TCP报文中.服务器收到此报文然后提取处HTTP报文，然后处理HTTP请求，并发送回应报文。\n**HTTPS**：https 中的s指的是SSL。SSL在HTTP和TCP之间，在HTTP报文进入TCP报文之前先对HTTP报文进行加密.加密过程在上一篇文章中已经提及过了，这里不再赘述。\n#### HTTP请求由三部分组成：请求行，请求报头和请求正文.\n* 请求行: Method Request-URL HTTP-Version CRLF\n* 请求报头: Accept,Accept-Charset,Accept-Encoding,Accept-Language,Content-Type,Cookie,User-Agent\n* 请求正文:当使用POST时，发送的数据储存在请求正文中，数据格式一般为json，此时需要设置Content-Type:application/json\n#### HTTP响应报文由三部分组成: 状态码，响应报头，响应报文\n状态码：\n* 1xx: 100  101服务器遵从用户的请求转换到另外一种协议\n* 2xx: 200  OK  \n* 3xx: 301  Moved Permanently 永久性转移 302 临时转移 304 Not Modified\n* 4xx: 401 Unauthorized 未授权 403 Forbidden  404 Not Found \n* 5xx: 500 服务器出现错误，不能完成客户请求  505 服务器不支持请求中的HTTP版本\n\n## 浏览器解析并渲染页面\n首先我们要明白，浏览器是边解析边进行页面渲染的.浏览器对HTML文件进行解析，构建DOM树。\n如果遇到link标签且引用了外部CSS，则发出CSS文件的请求，服务器返回这个CSS文件，浏览器继续解析body部分的代码，遇到img标签引用了图片，向服务器发送请求，浏览器不会等到图片下载完，而是继续渲染后面的代码。\n服务器返回图片文件，由于图片占用了一定的面积，影响了段落的排布，此时浏览器需要重新渲染这部分代码\n当浏览器发现script标签时候，会立即执行这部分代码。\n构造出DOM树和计算出样式数据之后，构造渲染树。渲染树和DOM有些相似，但是渲染树会忽略掉不需要渲染的元素，比如display:none的元素，渲染树创建好之后，浏览器就可以直接把页面绘制到屏幕上。\n**重绘(repaints)**\n部分节点需要更新，但是没有改变他的形状，比如改变了背景颜色，这样就会发生重绘\n**重排(reflows)**\n渲染树的一部分必须要更新，且节点的尺寸发生了变化，这样就会触发重排\n**什么情况下触发重绘或重排**\n增加或删除DOM节点\n设置display:none(重排并重绘) visibility:hidden(重排)\n\n","source":"_posts/urlTopage.md","raw":"---\ntitle: 从输入url到显示页面的步骤(详细)\ndate: 2017-04-13 21:39:14\ntags: [HTML]\n---\n这个问题在前端面试中会经常被问到。作为一个前端工程师，明白网页从输入URL到显示页面到底发生了什么，这是一件很有必要的事情.\n**从表面上分为以下几个过程**\n1. 输入URL->DNS解析\n2. 与服务器建立TCP连接\n3. 发送HTTP请求\n4. 服务器发送回应报文\n5. 浏览器解析HTML文档并渲染页面\n<!--more-->\n## DNS解析\n当输入url时，比如www.google.com，经过DNS解析为一个IP地址，这个IP地址就是服务器的地址。\n### 域的划分\n根域->顶级域->二级域名->三级域名......\n举个例子\n.com是根域名，baidu.com是顶级域名，www.baidu.com是二级域名.\n### 域名服务器\n能提供域名解析的服务器,上面的记录类型可以是A记录,NS记录,MX记录,CNAME\n接下来一一解释这几个记录的意思：\n* A记录：记录一个IP地址和一个主机名字(或者域名)，表示记录了主机为a的IP。\n* NS记录：NS即Name Server，用来指定该域名由哪个DNS服务器进行解析\n* CNAME记录：别名记录.这种记录允许将多个名字映射到同一台计算机上\n### 解析过程\n当我要通过浏览器访问一个网址的时候，根据电脑网络设置里的DNS，向这个域名解析服务器发送请求，然后本地DNS域名解析服务器会检查自己的缓存是否拥有这个地址，有的话直接返回所对应的IP地址.如果缓存中没有的话，就会从配置文件中读取根域名服务器的地址，然后依次从根域名服务器到顶级域名服务器到本地域名服务器，这样得到了要访问的主机的IP地址。其实就是一个递归查询的过程\n## TCP连接\n通过三次握手建立TCP连接.过程是：\n1.客户机向服务器发送连接请求: SYN=1,seq=client_isn\n2.服务器收到请求，回应: ack = client_isn+1,SYN=1,seq=server_isn\n3.客户机收到回应之后发送回应:ack = server_isn+1,SYN=0,seq=client_isn+1\n## 发送HTTP请求\n建立TCP连接之后，发送HTTP请求，HTTP报文包裹在TCP报文中.服务器收到此报文然后提取处HTTP报文，然后处理HTTP请求，并发送回应报文。\n**HTTPS**：https 中的s指的是SSL。SSL在HTTP和TCP之间，在HTTP报文进入TCP报文之前先对HTTP报文进行加密.加密过程在上一篇文章中已经提及过了，这里不再赘述。\n#### HTTP请求由三部分组成：请求行，请求报头和请求正文.\n* 请求行: Method Request-URL HTTP-Version CRLF\n* 请求报头: Accept,Accept-Charset,Accept-Encoding,Accept-Language,Content-Type,Cookie,User-Agent\n* 请求正文:当使用POST时，发送的数据储存在请求正文中，数据格式一般为json，此时需要设置Content-Type:application/json\n#### HTTP响应报文由三部分组成: 状态码，响应报头，响应报文\n状态码：\n* 1xx: 100  101服务器遵从用户的请求转换到另外一种协议\n* 2xx: 200  OK  \n* 3xx: 301  Moved Permanently 永久性转移 302 临时转移 304 Not Modified\n* 4xx: 401 Unauthorized 未授权 403 Forbidden  404 Not Found \n* 5xx: 500 服务器出现错误，不能完成客户请求  505 服务器不支持请求中的HTTP版本\n\n## 浏览器解析并渲染页面\n首先我们要明白，浏览器是边解析边进行页面渲染的.浏览器对HTML文件进行解析，构建DOM树。\n如果遇到link标签且引用了外部CSS，则发出CSS文件的请求，服务器返回这个CSS文件，浏览器继续解析body部分的代码，遇到img标签引用了图片，向服务器发送请求，浏览器不会等到图片下载完，而是继续渲染后面的代码。\n服务器返回图片文件，由于图片占用了一定的面积，影响了段落的排布，此时浏览器需要重新渲染这部分代码\n当浏览器发现script标签时候，会立即执行这部分代码。\n构造出DOM树和计算出样式数据之后，构造渲染树。渲染树和DOM有些相似，但是渲染树会忽略掉不需要渲染的元素，比如display:none的元素，渲染树创建好之后，浏览器就可以直接把页面绘制到屏幕上。\n**重绘(repaints)**\n部分节点需要更新，但是没有改变他的形状，比如改变了背景颜色，这样就会发生重绘\n**重排(reflows)**\n渲染树的一部分必须要更新，且节点的尺寸发生了变化，这样就会触发重排\n**什么情况下触发重绘或重排**\n增加或删除DOM节点\n设置display:none(重排并重绘) visibility:hidden(重排)\n\n","slug":"urlTopage","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4rf000moejxzq7b8r0z","content":"<p>这个问题在前端面试中会经常被问到。作为一个前端工程师，明白网页从输入URL到显示页面到底发生了什么，这是一件很有必要的事情.<br><strong>从表面上分为以下几个过程</strong></p>\n<ol>\n<li>输入URL-&gt;DNS解析</li>\n<li>与服务器建立TCP连接</li>\n<li>发送HTTP请求</li>\n<li>服务器发送回应报文</li>\n<li>浏览器解析HTML文档并渲染页面<a id=\"more\"></a>\n<h2 id=\"DNS解析\"><a href=\"#DNS解析\" class=\"headerlink\" title=\"DNS解析\"></a>DNS解析</h2>当输入url时，比如www.google.com，经过DNS解析为一个IP地址，这个IP地址就是服务器的地址。<h3 id=\"域的划分\"><a href=\"#域的划分\" class=\"headerlink\" title=\"域的划分\"></a>域的划分</h3>根域-&gt;顶级域-&gt;二级域名-&gt;三级域名……<br>举个例子<br>.com是根域名，baidu.com是顶级域名，www.baidu.com是二级域名.<h3 id=\"域名服务器\"><a href=\"#域名服务器\" class=\"headerlink\" title=\"域名服务器\"></a>域名服务器</h3>能提供域名解析的服务器,上面的记录类型可以是A记录,NS记录,MX记录,CNAME<br>接下来一一解释这几个记录的意思：</li>\n</ol>\n<ul>\n<li>A记录：记录一个IP地址和一个主机名字(或者域名)，表示记录了主机为a的IP。</li>\n<li>NS记录：NS即Name Server，用来指定该域名由哪个DNS服务器进行解析</li>\n<li>CNAME记录：别名记录.这种记录允许将多个名字映射到同一台计算机上<h3 id=\"解析过程\"><a href=\"#解析过程\" class=\"headerlink\" title=\"解析过程\"></a>解析过程</h3>当我要通过浏览器访问一个网址的时候，根据电脑网络设置里的DNS，向这个域名解析服务器发送请求，然后本地DNS域名解析服务器会检查自己的缓存是否拥有这个地址，有的话直接返回所对应的IP地址.如果缓存中没有的话，就会从配置文件中读取根域名服务器的地址，然后依次从根域名服务器到顶级域名服务器到本地域名服务器，这样得到了要访问的主机的IP地址。其实就是一个递归查询的过程<h2 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h2>通过三次握手建立TCP连接.过程是：<br>1.客户机向服务器发送连接请求: SYN=1,seq=client_isn<br>2.服务器收到请求，回应: ack = client_isn+1,SYN=1,seq=server_isn<br>3.客户机收到回应之后发送回应:ack = server_isn+1,SYN=0,seq=client_isn+1<h2 id=\"发送HTTP请求\"><a href=\"#发送HTTP请求\" class=\"headerlink\" title=\"发送HTTP请求\"></a>发送HTTP请求</h2>建立TCP连接之后，发送HTTP请求，HTTP报文包裹在TCP报文中.服务器收到此报文然后提取处HTTP报文，然后处理HTTP请求，并发送回应报文。<br><strong>HTTPS</strong>：https 中的s指的是SSL。SSL在HTTP和TCP之间，在HTTP报文进入TCP报文之前先对HTTP报文进行加密.加密过程在上一篇文章中已经提及过了，这里不再赘述。<h4 id=\"HTTP请求由三部分组成：请求行，请求报头和请求正文\"><a href=\"#HTTP请求由三部分组成：请求行，请求报头和请求正文\" class=\"headerlink\" title=\"HTTP请求由三部分组成：请求行，请求报头和请求正文.\"></a>HTTP请求由三部分组成：请求行，请求报头和请求正文.</h4></li>\n<li>请求行: Method Request-URL HTTP-Version CRLF</li>\n<li>请求报头: Accept,Accept-Charset,Accept-Encoding,Accept-Language,Content-Type,Cookie,User-Agent</li>\n<li>请求正文:当使用POST时，发送的数据储存在请求正文中，数据格式一般为json，此时需要设置Content-Type:application/json<h4 id=\"HTTP响应报文由三部分组成-状态码，响应报头，响应报文\"><a href=\"#HTTP响应报文由三部分组成-状态码，响应报头，响应报文\" class=\"headerlink\" title=\"HTTP响应报文由三部分组成: 状态码，响应报头，响应报文\"></a>HTTP响应报文由三部分组成: 状态码，响应报头，响应报文</h4>状态码：</li>\n<li>1xx: 100  101服务器遵从用户的请求转换到另外一种协议</li>\n<li>2xx: 200  OK  </li>\n<li>3xx: 301  Moved Permanently 永久性转移 302 临时转移 304 Not Modified</li>\n<li>4xx: 401 Unauthorized 未授权 403 Forbidden  404 Not Found </li>\n<li>5xx: 500 服务器出现错误，不能完成客户请求  505 服务器不支持请求中的HTTP版本</li>\n</ul>\n<h2 id=\"浏览器解析并渲染页面\"><a href=\"#浏览器解析并渲染页面\" class=\"headerlink\" title=\"浏览器解析并渲染页面\"></a>浏览器解析并渲染页面</h2><p>首先我们要明白，浏览器是边解析边进行页面渲染的.浏览器对HTML文件进行解析，构建DOM树。<br>如果遇到link标签且引用了外部CSS，则发出CSS文件的请求，服务器返回这个CSS文件，浏览器继续解析body部分的代码，遇到img标签引用了图片，向服务器发送请求，浏览器不会等到图片下载完，而是继续渲染后面的代码。<br>服务器返回图片文件，由于图片占用了一定的面积，影响了段落的排布，此时浏览器需要重新渲染这部分代码<br>当浏览器发现script标签时候，会立即执行这部分代码。<br>构造出DOM树和计算出样式数据之后，构造渲染树。渲染树和DOM有些相似，但是渲染树会忽略掉不需要渲染的元素，比如display:none的元素，渲染树创建好之后，浏览器就可以直接把页面绘制到屏幕上。<br><strong>重绘(repaints)</strong><br>部分节点需要更新，但是没有改变他的形状，比如改变了背景颜色，这样就会发生重绘<br><strong>重排(reflows)</strong><br>渲染树的一部分必须要更新，且节点的尺寸发生了变化，这样就会触发重排<br><strong>什么情况下触发重绘或重排</strong><br>增加或删除DOM节点<br>设置display:none(重排并重绘) visibility:hidden(重排)</p>\n","site":{"data":{}},"excerpt":"<p>这个问题在前端面试中会经常被问到。作为一个前端工程师，明白网页从输入URL到显示页面到底发生了什么，这是一件很有必要的事情.<br><strong>从表面上分为以下几个过程</strong></p>\n<ol>\n<li>输入URL-&gt;DNS解析</li>\n<li>与服务器建立TCP连接</li>\n<li>发送HTTP请求</li>\n<li>服务器发送回应报文</li>\n<li>浏览器解析HTML文档并渲染页面","more":"<h2 id=\"DNS解析\"><a href=\"#DNS解析\" class=\"headerlink\" title=\"DNS解析\"></a>DNS解析</h2>当输入url时，比如www.google.com，经过DNS解析为一个IP地址，这个IP地址就是服务器的地址。<h3 id=\"域的划分\"><a href=\"#域的划分\" class=\"headerlink\" title=\"域的划分\"></a>域的划分</h3>根域-&gt;顶级域-&gt;二级域名-&gt;三级域名……<br>举个例子<br>.com是根域名，baidu.com是顶级域名，www.baidu.com是二级域名.<h3 id=\"域名服务器\"><a href=\"#域名服务器\" class=\"headerlink\" title=\"域名服务器\"></a>域名服务器</h3>能提供域名解析的服务器,上面的记录类型可以是A记录,NS记录,MX记录,CNAME<br>接下来一一解释这几个记录的意思：</li>\n</ol>\n<ul>\n<li>A记录：记录一个IP地址和一个主机名字(或者域名)，表示记录了主机为a的IP。</li>\n<li>NS记录：NS即Name Server，用来指定该域名由哪个DNS服务器进行解析</li>\n<li>CNAME记录：别名记录.这种记录允许将多个名字映射到同一台计算机上<h3 id=\"解析过程\"><a href=\"#解析过程\" class=\"headerlink\" title=\"解析过程\"></a>解析过程</h3>当我要通过浏览器访问一个网址的时候，根据电脑网络设置里的DNS，向这个域名解析服务器发送请求，然后本地DNS域名解析服务器会检查自己的缓存是否拥有这个地址，有的话直接返回所对应的IP地址.如果缓存中没有的话，就会从配置文件中读取根域名服务器的地址，然后依次从根域名服务器到顶级域名服务器到本地域名服务器，这样得到了要访问的主机的IP地址。其实就是一个递归查询的过程<h2 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h2>通过三次握手建立TCP连接.过程是：<br>1.客户机向服务器发送连接请求: SYN=1,seq=client_isn<br>2.服务器收到请求，回应: ack = client_isn+1,SYN=1,seq=server_isn<br>3.客户机收到回应之后发送回应:ack = server_isn+1,SYN=0,seq=client_isn+1<h2 id=\"发送HTTP请求\"><a href=\"#发送HTTP请求\" class=\"headerlink\" title=\"发送HTTP请求\"></a>发送HTTP请求</h2>建立TCP连接之后，发送HTTP请求，HTTP报文包裹在TCP报文中.服务器收到此报文然后提取处HTTP报文，然后处理HTTP请求，并发送回应报文。<br><strong>HTTPS</strong>：https 中的s指的是SSL。SSL在HTTP和TCP之间，在HTTP报文进入TCP报文之前先对HTTP报文进行加密.加密过程在上一篇文章中已经提及过了，这里不再赘述。<h4 id=\"HTTP请求由三部分组成：请求行，请求报头和请求正文\"><a href=\"#HTTP请求由三部分组成：请求行，请求报头和请求正文\" class=\"headerlink\" title=\"HTTP请求由三部分组成：请求行，请求报头和请求正文.\"></a>HTTP请求由三部分组成：请求行，请求报头和请求正文.</h4></li>\n<li>请求行: Method Request-URL HTTP-Version CRLF</li>\n<li>请求报头: Accept,Accept-Charset,Accept-Encoding,Accept-Language,Content-Type,Cookie,User-Agent</li>\n<li>请求正文:当使用POST时，发送的数据储存在请求正文中，数据格式一般为json，此时需要设置Content-Type:application/json<h4 id=\"HTTP响应报文由三部分组成-状态码，响应报头，响应报文\"><a href=\"#HTTP响应报文由三部分组成-状态码，响应报头，响应报文\" class=\"headerlink\" title=\"HTTP响应报文由三部分组成: 状态码，响应报头，响应报文\"></a>HTTP响应报文由三部分组成: 状态码，响应报头，响应报文</h4>状态码：</li>\n<li>1xx: 100  101服务器遵从用户的请求转换到另外一种协议</li>\n<li>2xx: 200  OK  </li>\n<li>3xx: 301  Moved Permanently 永久性转移 302 临时转移 304 Not Modified</li>\n<li>4xx: 401 Unauthorized 未授权 403 Forbidden  404 Not Found </li>\n<li>5xx: 500 服务器出现错误，不能完成客户请求  505 服务器不支持请求中的HTTP版本</li>\n</ul>\n<h2 id=\"浏览器解析并渲染页面\"><a href=\"#浏览器解析并渲染页面\" class=\"headerlink\" title=\"浏览器解析并渲染页面\"></a>浏览器解析并渲染页面</h2><p>首先我们要明白，浏览器是边解析边进行页面渲染的.浏览器对HTML文件进行解析，构建DOM树。<br>如果遇到link标签且引用了外部CSS，则发出CSS文件的请求，服务器返回这个CSS文件，浏览器继续解析body部分的代码，遇到img标签引用了图片，向服务器发送请求，浏览器不会等到图片下载完，而是继续渲染后面的代码。<br>服务器返回图片文件，由于图片占用了一定的面积，影响了段落的排布，此时浏览器需要重新渲染这部分代码<br>当浏览器发现script标签时候，会立即执行这部分代码。<br>构造出DOM树和计算出样式数据之后，构造渲染树。渲染树和DOM有些相似，但是渲染树会忽略掉不需要渲染的元素，比如display:none的元素，渲染树创建好之后，浏览器就可以直接把页面绘制到屏幕上。<br><strong>重绘(repaints)</strong><br>部分节点需要更新，但是没有改变他的形状，比如改变了背景颜色，这样就会发生重绘<br><strong>重排(reflows)</strong><br>渲染树的一部分必须要更新，且节点的尺寸发生了变化，这样就会触发重排<br><strong>什么情况下触发重绘或重排</strong><br>增加或删除DOM节点<br>设置display:none(重排并重绘) visibility:hidden(重排)</p>"},{"title":"vue源码分析","date":"2017-04-16T21:54:41.000Z","_content":"想要真正的掌握一个框架就应该了解它的源码，知道整个框架是如何工作的.Vue是一个轻量化但非常好用的前端框架.它是以数据驱动为核心的javascript框架.Vue2.0更是重写之前的vue代码。本次要看的vue版本是2.03,线上包只有12Kb，性能也是非常不错的.\n接下来从生命周期的各个过程去分析vue源码.<!--more-->\n## 生命周期\n我们首先需要对Vue的生命周期有一个完整的理解，在下面放两张图。\n![](http://of8m1pnnt.bkt.clouddn.com/3504099265-580628fd03258_articlex.png)\n![](http://of8m1pnnt.bkt.clouddn.com/3346068135-580822cd52898_articlex.png)\n从这个生命周期图我们可以得知vue的声明周期主要是4个过程：\n* create\n* mount\n* update\n* destroy\n\n### Create\nnew Vue()的时候发生了哪些事情呢？先从 vue/src/core/instance/index.js看起。\nindex.js\n主要代码片段如下: 解析写在注释里\n```javascript\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }  // 这个if判断是用来说明 Vue这个函数是个构造函数只能够通过 new的方式调用\n  this._init(options) // 用来初始化vue的函数(这个函数是在vue.prototype上的)\n}\n//以下是对Vue这个构造函数的初始化\ninitMixin(Vue) \nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n``` \n接下来是对每个函数的解析\n\n### this._init(vm)\n\n文件为 vue/src/core/instance/init.js\n主要代码片段为\n```javascript\nexport function initMixin (Vue: Class<Component>) {\n  //初始化vue的函数 也就是上文中调用的this._init函数\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    //...中间一部分省略掉\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n      vm.$mount(vm.$options.el)\n  }\n}\n```\n在这个_init函数中主要做了什么事情呢？没错，就是主要执行以下这些函数：\n\n*    initLifecycle(vm)\n*   initEvents(vm)\n*    initRender(vm)\n*    callHook(vm,”..”)\n*    initInjections(vm)\n*    initState(vm)\n*    initProvide(vm)\n*    vm.$mount(vm.$options.el)\n\n### initLifecycle(vm)\n文件路径 vue/src/core/instance/state.js\n主要代码如下:\n```javascript\nexport function initLifecycle (vm: Component) {\n  const options = vm.$options\n  let parent = options.parent\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n  vm.$children = []\n  vm.$refs = {}\n  vm._watcher = null\n  vm._inactive = null\n  vm._directInactive = false\n  vm._isMounted = false\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n}\n```\n\n### initEvents(Vm)\n文件路径 vue/src/core/instance/event.js\n主要代码如下:\n```javascript\nexport function initEvents (vm: Component) {\n  vm._events = Object.create(null)\n  vm._hasHookEvent = false\n  // init parent attached events\n  const listeners = vm.$options._parentListeners\n  if (listeners) {\n    updateComponentListeners(vm, listeners)\n  }\n}\n```\n\n### initRender(vm)\n文件位于 vue/src/core/instance/render.js\n主要代码如下：\n```javascript\nexport function initRender (vm: Component) {\n  vm.$vnode = null // the placeholder node in parent tree\n  vm._vnode = null // the root of the child tree\n  vm._staticTrees = null\n  const parentVnode = vm.$options._parentVnode\n  const renderContext = parentVnode && parentVnode.context\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)\n  vm.$scopedSlots = emptyObject\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n}\n```\n\n### callHook(vm,'beforeCreate')\n首先callHook函数定义在 lifestyle.js中\n```javascript\n\nexport function callHook (vm: Component, hook: string) {\n  const handlers = vm.$options[hook]\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm)\n      } catch (e) {\n        handleError(e, vm, `${hook} hook`)\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook)\n  }\n}\n```\n\n### initInjections(vm)\n文件代码位于 vue/src/core/instance/inject.js\n主要代码如下：\n```javascript\nexport function initInjections (vm: Component) {\n  const result = resolveInject(vm.$options.inject, vm)\n  if (result) {\n    Object.keys(result).forEach(key => {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, key, result[key], () => {\n          warn(\n            `Avoid mutating an injected value directly since the changes will be ` +\n            `overwritten whenever the provided component re-renders. ` +\n            `injection being mutated: \"${key}\"`,\n            vm\n          )\n        })\n      } else {\n        defineReactive(vm, key, result[key])\n      }\n    })\n  }\n}\n```\n\n### initState(vm)\n\n文件位于 vue/src/core/state.js\n代码如下:\n```javascript\nexport function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch) initWatch(vm, opts.watch)\n}\n```\ninitState(vm)做了什么呢？\n\n1.    初始化vm._watchers这个数组\n2.    initProps 初始化options.props\n3.    initMethods 初始化options.methods\n4.    initData 初始化options.data\n\n### callHook(vm,’created’)\n调用options.created这个对象里的函数，表示这些函数在vue实例created之后调用\n\n以上几个函数代表的是，.init()初始化，依次调用lifecycle，events，render，state模块中的初始化函数\n接下来的函数是在.init()末尾调用的vm.$mount()\n\n### vm.$mount(vm.$options.el)\n具体相关代码如下：\n```javascript\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n  const options = this.$options\n  //...省略一些代码\n  if (!options.render) {  //如果存在render方法，直接运行mount\n    let template = options.template\n    if (template) { //如果有template，获取template\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) { //如果获取到了模板，则将模板转化为render方法\n      //....省略一些代码\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n```\n这个函数做了什么呢？\n根据el，template，以及render去生成Vue的AST render方法\n解释一下:vue.prototype.$mount这个方法在 web-runtime.js和web-runtime-with-compiler.js均有定义,执行顺序是：先const mount = web-runtiome.js中的vue.prototype.$mount，然后在web-runtime-with-compiler.js中重写vue.prototype.$mount,最后在重写的vue.prototype.$mount末尾处调用mount方法.接着继续调用mountComponent()这个方法.这个方法定义在lifecycle.js中。\n\n### mountComponent\n\n主要代码如下：\n```javascript\nupdateComponent = () => {\n      vm._update(vm._render(), hydrating)\n}\nvm._watcher = new Watcher(vm, updateComponent, noop)\n```\n这段代码传入render方法生成的vNode对象，生成一个watcher.\n接下来看生成watcher的过程\n\n### wathcer\n\nWathcer构造函数定义在../observer/watcher.js中\n主要逻辑代码如下:\n```javascript\nthis.vm = vm\n    vm._watchers.push(this)\n    //...省略的部分\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n  get () {\n    pushTarget(this)\n  \tlet value = this.getter.call(vm, vm)\n    const vm = this.vm\n    if (this.deep) {\n      traverse(value)\n    }\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n```\n中间的一大部分初始化操作可以省略不看，重点在于最后一句this.value ，this.lazy初始为false，则调用了this.get().\n看看get()发生了什么？主要是调用了this.getter，在上面省略的代码中可知this.getter就是在上文中传入的第二个参数即 updateCompount这个函数，内部是两个函数的调用，先调用vm._render(),这个函数的返回值即vNode作为参数传入 vm._update()，来更新vDom。\n接下来在看一看vm._render()和vm._update()\n代码如下:\n```javascript\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate')\n    }\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const prevActiveInstance = activeInstance\n    activeInstance = vm\n    vm._vnode = vnode\n    if (!prevVnode) { //初次加载\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      // 更新vnode\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    activeInstance = prevActiveInstance\n    //...后续省略.\n  }\n```\nvm._render()这个函数之后再进行赘述，这里只需要知道这个函数返回值是vNode就可以了。\nvm._update()这个函数的主要逻辑就是执行了vm.patch(prevVnode,vnode),对Virtual DOM 进行更新。\n***综合以上三步***\n1. 初始化之后调用vm.$mount(),生成AST render方法\n2. 调用mount()，即调用mountComponent()这个函数，生成watcher\n3. 生成watcher的过程中，调用了this.get(),这个函数内部通过调用this.getter()即传递进来的第二个参数updateComponent()来调用vm._render()生成vnode节点，调用vm._update更新vDom。\n\n\n## 如何实现数据绑定的?\nvue的数据绑定重中之重就是把数据(Model)和视图(view)建立起关系\n回顾一下watcher构造函数中，调用了get(),这个函数中调用了pushTarget()和popTarget()\n代码位于 src/core/observer/dep.js\n代码如下：\n```javascript\nexport function pushTarget (_target: Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n```\n这两个函数用于处理Dep.target,分别是数组的push()和pop()，\nDep.target调用方式为 Dep.target.addDep(this) 调用的时候会涉及到依赖收集，从而建立数据绑定的关系。\n这里我们得知，在使用数据进行渲染的过程中，会对数据属性进行“读”操作，从而触发dep.depend(),进而收集到这个依赖关系。\n\n我们需要找到这个dep.depend()调用所在处，在observer/index.js中，defineReactive()\n代码如下：\n```javascript\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  const dep = new Dep()\n  const getter = property && property.get\n  const setter = property && property.set\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n        //...省略\n        dep.depend()\n    },\n    set: function reactiveSetter (newVal) {\n        //...省略\n      dep.notify()\n    }\n  })\n}\n```\n当数据的属性的get()被调用时，会通过dep.depend()收集依赖关系,记录到vm中\n在数据的属性的set()被调用时，会通过dep.notify()来通知vm，从而触发vm的更新操作。\n回头来看state.js,是在initProps()中调用了defineReactive().而initProps()是在initState()中调用，而initState()是在this._init()中被调用\n\n总结如下：\n\n1.    初始化：new Vue()->vm._init()\n2.    数据劫持: initState(vm)->initProps(),initData()->dep.depend()\n3.    依赖收集: vm.$mount()->vm._mount()->new Watcher()->vm._render()->vm._update()\n\n\n","source":"_posts/vue.md","raw":"---\ntitle: vue源码分析\ndate: 2017-04-16 14:54:41\ntags: [javascript]\n---\n想要真正的掌握一个框架就应该了解它的源码，知道整个框架是如何工作的.Vue是一个轻量化但非常好用的前端框架.它是以数据驱动为核心的javascript框架.Vue2.0更是重写之前的vue代码。本次要看的vue版本是2.03,线上包只有12Kb，性能也是非常不错的.\n接下来从生命周期的各个过程去分析vue源码.<!--more-->\n## 生命周期\n我们首先需要对Vue的生命周期有一个完整的理解，在下面放两张图。\n![](http://of8m1pnnt.bkt.clouddn.com/3504099265-580628fd03258_articlex.png)\n![](http://of8m1pnnt.bkt.clouddn.com/3346068135-580822cd52898_articlex.png)\n从这个生命周期图我们可以得知vue的声明周期主要是4个过程：\n* create\n* mount\n* update\n* destroy\n\n### Create\nnew Vue()的时候发生了哪些事情呢？先从 vue/src/core/instance/index.js看起。\nindex.js\n主要代码片段如下: 解析写在注释里\n```javascript\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }  // 这个if判断是用来说明 Vue这个函数是个构造函数只能够通过 new的方式调用\n  this._init(options) // 用来初始化vue的函数(这个函数是在vue.prototype上的)\n}\n//以下是对Vue这个构造函数的初始化\ninitMixin(Vue) \nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n``` \n接下来是对每个函数的解析\n\n### this._init(vm)\n\n文件为 vue/src/core/instance/init.js\n主要代码片段为\n```javascript\nexport function initMixin (Vue: Class<Component>) {\n  //初始化vue的函数 也就是上文中调用的this._init函数\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    //...中间一部分省略掉\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n      vm.$mount(vm.$options.el)\n  }\n}\n```\n在这个_init函数中主要做了什么事情呢？没错，就是主要执行以下这些函数：\n\n*    initLifecycle(vm)\n*   initEvents(vm)\n*    initRender(vm)\n*    callHook(vm,”..”)\n*    initInjections(vm)\n*    initState(vm)\n*    initProvide(vm)\n*    vm.$mount(vm.$options.el)\n\n### initLifecycle(vm)\n文件路径 vue/src/core/instance/state.js\n主要代码如下:\n```javascript\nexport function initLifecycle (vm: Component) {\n  const options = vm.$options\n  let parent = options.parent\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n  vm.$children = []\n  vm.$refs = {}\n  vm._watcher = null\n  vm._inactive = null\n  vm._directInactive = false\n  vm._isMounted = false\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n}\n```\n\n### initEvents(Vm)\n文件路径 vue/src/core/instance/event.js\n主要代码如下:\n```javascript\nexport function initEvents (vm: Component) {\n  vm._events = Object.create(null)\n  vm._hasHookEvent = false\n  // init parent attached events\n  const listeners = vm.$options._parentListeners\n  if (listeners) {\n    updateComponentListeners(vm, listeners)\n  }\n}\n```\n\n### initRender(vm)\n文件位于 vue/src/core/instance/render.js\n主要代码如下：\n```javascript\nexport function initRender (vm: Component) {\n  vm.$vnode = null // the placeholder node in parent tree\n  vm._vnode = null // the root of the child tree\n  vm._staticTrees = null\n  const parentVnode = vm.$options._parentVnode\n  const renderContext = parentVnode && parentVnode.context\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)\n  vm.$scopedSlots = emptyObject\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)\n  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)\n}\n```\n\n### callHook(vm,'beforeCreate')\n首先callHook函数定义在 lifestyle.js中\n```javascript\n\nexport function callHook (vm: Component, hook: string) {\n  const handlers = vm.$options[hook]\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm)\n      } catch (e) {\n        handleError(e, vm, `${hook} hook`)\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook)\n  }\n}\n```\n\n### initInjections(vm)\n文件代码位于 vue/src/core/instance/inject.js\n主要代码如下：\n```javascript\nexport function initInjections (vm: Component) {\n  const result = resolveInject(vm.$options.inject, vm)\n  if (result) {\n    Object.keys(result).forEach(key => {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, key, result[key], () => {\n          warn(\n            `Avoid mutating an injected value directly since the changes will be ` +\n            `overwritten whenever the provided component re-renders. ` +\n            `injection being mutated: \"${key}\"`,\n            vm\n          )\n        })\n      } else {\n        defineReactive(vm, key, result[key])\n      }\n    })\n  }\n}\n```\n\n### initState(vm)\n\n文件位于 vue/src/core/state.js\n代码如下:\n```javascript\nexport function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch) initWatch(vm, opts.watch)\n}\n```\ninitState(vm)做了什么呢？\n\n1.    初始化vm._watchers这个数组\n2.    initProps 初始化options.props\n3.    initMethods 初始化options.methods\n4.    initData 初始化options.data\n\n### callHook(vm,’created’)\n调用options.created这个对象里的函数，表示这些函数在vue实例created之后调用\n\n以上几个函数代表的是，.init()初始化，依次调用lifecycle，events，render，state模块中的初始化函数\n接下来的函数是在.init()末尾调用的vm.$mount()\n\n### vm.$mount(vm.$options.el)\n具体相关代码如下：\n```javascript\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && query(el)\n  const options = this.$options\n  //...省略一些代码\n  if (!options.render) {  //如果存在render方法，直接运行mount\n    let template = options.template\n    if (template) { //如果有template，获取template\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) { //如果获取到了模板，则将模板转化为render方法\n      //....省略一些代码\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n    }\n  }\n  return mount.call(this, el, hydrating)\n}\n```\n这个函数做了什么呢？\n根据el，template，以及render去生成Vue的AST render方法\n解释一下:vue.prototype.$mount这个方法在 web-runtime.js和web-runtime-with-compiler.js均有定义,执行顺序是：先const mount = web-runtiome.js中的vue.prototype.$mount，然后在web-runtime-with-compiler.js中重写vue.prototype.$mount,最后在重写的vue.prototype.$mount末尾处调用mount方法.接着继续调用mountComponent()这个方法.这个方法定义在lifecycle.js中。\n\n### mountComponent\n\n主要代码如下：\n```javascript\nupdateComponent = () => {\n      vm._update(vm._render(), hydrating)\n}\nvm._watcher = new Watcher(vm, updateComponent, noop)\n```\n这段代码传入render方法生成的vNode对象，生成一个watcher.\n接下来看生成watcher的过程\n\n### wathcer\n\nWathcer构造函数定义在../observer/watcher.js中\n主要逻辑代码如下:\n```javascript\nthis.vm = vm\n    vm._watchers.push(this)\n    //...省略的部分\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n  get () {\n    pushTarget(this)\n  \tlet value = this.getter.call(vm, vm)\n    const vm = this.vm\n    if (this.deep) {\n      traverse(value)\n    }\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n```\n中间的一大部分初始化操作可以省略不看，重点在于最后一句this.value ，this.lazy初始为false，则调用了this.get().\n看看get()发生了什么？主要是调用了this.getter，在上面省略的代码中可知this.getter就是在上文中传入的第二个参数即 updateCompount这个函数，内部是两个函数的调用，先调用vm._render(),这个函数的返回值即vNode作为参数传入 vm._update()，来更新vDom。\n接下来在看一看vm._render()和vm._update()\n代码如下:\n```javascript\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate')\n    }\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const prevActiveInstance = activeInstance\n    activeInstance = vm\n    vm._vnode = vnode\n    if (!prevVnode) { //初次加载\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      // 更新vnode\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    activeInstance = prevActiveInstance\n    //...后续省略.\n  }\n```\nvm._render()这个函数之后再进行赘述，这里只需要知道这个函数返回值是vNode就可以了。\nvm._update()这个函数的主要逻辑就是执行了vm.patch(prevVnode,vnode),对Virtual DOM 进行更新。\n***综合以上三步***\n1. 初始化之后调用vm.$mount(),生成AST render方法\n2. 调用mount()，即调用mountComponent()这个函数，生成watcher\n3. 生成watcher的过程中，调用了this.get(),这个函数内部通过调用this.getter()即传递进来的第二个参数updateComponent()来调用vm._render()生成vnode节点，调用vm._update更新vDom。\n\n\n## 如何实现数据绑定的?\nvue的数据绑定重中之重就是把数据(Model)和视图(view)建立起关系\n回顾一下watcher构造函数中，调用了get(),这个函数中调用了pushTarget()和popTarget()\n代码位于 src/core/observer/dep.js\n代码如下：\n```javascript\nexport function pushTarget (_target: Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n```\n这两个函数用于处理Dep.target,分别是数组的push()和pop()，\nDep.target调用方式为 Dep.target.addDep(this) 调用的时候会涉及到依赖收集，从而建立数据绑定的关系。\n这里我们得知，在使用数据进行渲染的过程中，会对数据属性进行“读”操作，从而触发dep.depend(),进而收集到这个依赖关系。\n\n我们需要找到这个dep.depend()调用所在处，在observer/index.js中，defineReactive()\n代码如下：\n```javascript\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  const dep = new Dep()\n  const getter = property && property.get\n  const setter = property && property.set\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n        //...省略\n        dep.depend()\n    },\n    set: function reactiveSetter (newVal) {\n        //...省略\n      dep.notify()\n    }\n  })\n}\n```\n当数据的属性的get()被调用时，会通过dep.depend()收集依赖关系,记录到vm中\n在数据的属性的set()被调用时，会通过dep.notify()来通知vm，从而触发vm的更新操作。\n回头来看state.js,是在initProps()中调用了defineReactive().而initProps()是在initState()中调用，而initState()是在this._init()中被调用\n\n总结如下：\n\n1.    初始化：new Vue()->vm._init()\n2.    数据劫持: initState(vm)->initProps(),initData()->dep.depend()\n3.    依赖收集: vm.$mount()->vm._mount()->new Watcher()->vm._render()->vm._update()\n\n\n","slug":"vue","published":1,"updated":"2017-04-20T22:12:33.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4ri000ooejxz5e95wko","content":"<p>想要真正的掌握一个框架就应该了解它的源码，知道整个框架是如何工作的.Vue是一个轻量化但非常好用的前端框架.它是以数据驱动为核心的javascript框架.Vue2.0更是重写之前的vue代码。本次要看的vue版本是2.03,线上包只有12Kb，性能也是非常不错的.<br>接下来从生命周期的各个过程去分析vue源码.<a id=\"more\"></a></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>我们首先需要对Vue的生命周期有一个完整的理解，在下面放两张图。<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/3504099265-580628fd03258_articlex.png\" alt=\"\"><br><img src=\"http://of8m1pnnt.bkt.clouddn.com/3346068135-580822cd52898_articlex.png\" alt=\"\"><br>从这个生命周期图我们可以得知vue的声明周期主要是4个过程：</p>\n<ul>\n<li>create</li>\n<li>mount</li>\n<li>update</li>\n<li>destroy</li>\n</ul>\n<h3 id=\"Create\"><a href=\"#Create\" class=\"headerlink\" title=\"Create\"></a>Create</h3><p>new Vue()的时候发生了哪些事情呢？先从 vue/src/core/instance/index.js看起。<br>index.js<br>主要代码片段如下: 解析写在注释里<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vue</span> (<span class=\"params\">options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</div><div class=\"line\">    !(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Vue)) &#123;</div><div class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class=\"line\">  &#125;  <span class=\"comment\">// 这个if判断是用来说明 Vue这个函数是个构造函数只能够通过 new的方式调用</span></div><div class=\"line\">  <span class=\"keyword\">this</span>._init(options) <span class=\"comment\">// 用来初始化vue的函数(这个函数是在vue.prototype上的)</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//以下是对Vue这个构造函数的初始化</span></div><div class=\"line\">initMixin(Vue) </div><div class=\"line\">stateMixin(Vue)</div><div class=\"line\">eventsMixin(Vue)</div><div class=\"line\">lifecycleMixin(Vue)</div><div class=\"line\">renderMixin(Vue)</div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\">接下来是对每个函数的解析</div><div class=\"line\"></div><div class=\"line\">### this._init(vm)</div><div class=\"line\"></div><div class=\"line\">文件为 vue/src/core/instance/init.js</div><div class=\"line\">主要代码片段为</div><div class=\"line\">`<span class=\"string\">``</span>javascript</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initMixin</span> (<span class=\"params\">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//初始化vue的函数 也就是上文中调用的this._init函数</span></div><div class=\"line\">  Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options?: Object</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> vm: Component = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"comment\">//...中间一部分省略掉</span></div><div class=\"line\">    vm._self = vm</div><div class=\"line\">    initLifecycle(vm)</div><div class=\"line\">    initEvents(vm)</div><div class=\"line\">    initRender(vm)</div><div class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</div><div class=\"line\">    initInjections(vm) <span class=\"comment\">// resolve injections before data/props</span></div><div class=\"line\">    initState(vm)</div><div class=\"line\">    initProvide(vm) <span class=\"comment\">// resolve provide after data/props</span></div><div class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</div><div class=\"line\">      vm.$mount(vm.$options.el)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这个_init函数中主要做了什么事情呢？没错，就是主要执行以下这些函数：</p>\n<ul>\n<li>initLifecycle(vm)</li>\n<li>initEvents(vm)</li>\n<li>initRender(vm)</li>\n<li>callHook(vm,”..”)</li>\n<li>initInjections(vm)</li>\n<li>initState(vm)</li>\n<li>initProvide(vm)</li>\n<li>vm.$mount(vm.$options.el)</li>\n</ul>\n<h3 id=\"initLifecycle-vm\"><a href=\"#initLifecycle-vm\" class=\"headerlink\" title=\"initLifecycle(vm)\"></a>initLifecycle(vm)</h3><p>文件路径 vue/src/core/instance/state.js<br>主要代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initLifecycle</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> options = vm.$options</div><div class=\"line\">  <span class=\"keyword\">let</span> parent = options.parent</div><div class=\"line\">  <span class=\"keyword\">if</span> (parent &amp;&amp; !options.abstract) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</div><div class=\"line\">      parent = parent.$parent</div><div class=\"line\">    &#125;</div><div class=\"line\">    parent.$children.push(vm)</div><div class=\"line\">  &#125;</div><div class=\"line\">  vm.$parent = parent</div><div class=\"line\">  vm.$root = parent ? parent.$root : vm</div><div class=\"line\">  vm.$children = []</div><div class=\"line\">  vm.$refs = &#123;&#125;</div><div class=\"line\">  vm._watcher = <span class=\"literal\">null</span></div><div class=\"line\">  vm._inactive = <span class=\"literal\">null</span></div><div class=\"line\">  vm._directInactive = <span class=\"literal\">false</span></div><div class=\"line\">  vm._isMounted = <span class=\"literal\">false</span></div><div class=\"line\">  vm._isDestroyed = <span class=\"literal\">false</span></div><div class=\"line\">  vm._isBeingDestroyed = <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initEvents-Vm\"><a href=\"#initEvents-Vm\" class=\"headerlink\" title=\"initEvents(Vm)\"></a>initEvents(Vm)</h3><p>文件路径 vue/src/core/instance/event.js<br>主要代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initEvents</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  vm._events = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</div><div class=\"line\">  vm._hasHookEvent = <span class=\"literal\">false</span></div><div class=\"line\">  <span class=\"comment\">// init parent attached events</span></div><div class=\"line\">  <span class=\"keyword\">const</span> listeners = vm.$options._parentListeners</div><div class=\"line\">  <span class=\"keyword\">if</span> (listeners) &#123;</div><div class=\"line\">    updateComponentListeners(vm, listeners)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initRender-vm\"><a href=\"#initRender-vm\" class=\"headerlink\" title=\"initRender(vm)\"></a>initRender(vm)</h3><p>文件位于 vue/src/core/instance/render.js<br>主要代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initRender</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  vm.$vnode = <span class=\"literal\">null</span> <span class=\"comment\">// the placeholder node in parent tree</span></div><div class=\"line\">  vm._vnode = <span class=\"literal\">null</span> <span class=\"comment\">// the root of the child tree</span></div><div class=\"line\">  vm._staticTrees = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">const</span> parentVnode = vm.$options._parentVnode</div><div class=\"line\">  <span class=\"keyword\">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</div><div class=\"line\">  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)</div><div class=\"line\">  vm.$scopedSlots = emptyObject</div><div class=\"line\">  vm._c = <span class=\"function\">(<span class=\"params\">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class=\"literal\">false</span>)</div><div class=\"line\">  vm.$createElement = <span class=\"function\">(<span class=\"params\">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class=\"literal\">true</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"callHook-vm-’beforeCreate’\"><a href=\"#callHook-vm-’beforeCreate’\" class=\"headerlink\" title=\"callHook(vm,’beforeCreate’)\"></a>callHook(vm,’beforeCreate’)</h3><p>首先callHook函数定义在 lifestyle.js中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callHook</span> (<span class=\"params\">vm: Component, hook: string</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> handlers = vm.$options[hook]</div><div class=\"line\">  <span class=\"keyword\">if</span> (handlers) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = handlers.length; i &lt; j; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        handlers[i].call(vm)</div><div class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">        handleError(e, vm, <span class=\"string\">`<span class=\"subst\">$&#123;hook&#125;</span> hook`</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (vm._hasHookEvent) &#123;</div><div class=\"line\">    vm.$emit(<span class=\"string\">'hook:'</span> + hook)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initInjections-vm\"><a href=\"#initInjections-vm\" class=\"headerlink\" title=\"initInjections(vm)\"></a>initInjections(vm)</h3><p>文件代码位于 vue/src/core/instance/inject.js<br>主要代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initInjections</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> result = resolveInject(vm.$options.inject, vm)</div><div class=\"line\">  <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.keys(result).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"comment\">/* istanbul ignore else */</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">        defineReactive(vm, key, result[key], () =&gt; &#123;</div><div class=\"line\">          warn(</div><div class=\"line\">            <span class=\"string\">`Avoid mutating an injected value directly since the changes will be `</span> +</div><div class=\"line\">            <span class=\"string\">`overwritten whenever the provided component re-renders. `</span> +</div><div class=\"line\">            <span class=\"string\">`injection being mutated: \"<span class=\"subst\">$&#123;key&#125;</span>\"`</span>,</div><div class=\"line\">            vm</div><div class=\"line\">          )</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        defineReactive(vm, key, result[key])</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initState-vm\"><a href=\"#initState-vm\" class=\"headerlink\" title=\"initState(vm)\"></a>initState(vm)</h3><p>文件位于 vue/src/core/state.js<br>代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initState</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  vm._watchers = []</div><div class=\"line\">  <span class=\"keyword\">const</span> opts = vm.$options</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.props) initProps(vm, opts.props)</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.methods) initMethods(vm, opts.methods)</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.data) &#123;</div><div class=\"line\">    initData(vm)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    observe(vm._data = &#123;&#125;, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.computed) initComputed(vm, opts.computed)</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.watch) initWatch(vm, opts.watch)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>initState(vm)做了什么呢？</p>\n<ol>\n<li>初始化vm._watchers这个数组</li>\n<li>initProps 初始化options.props</li>\n<li>initMethods 初始化options.methods</li>\n<li>initData 初始化options.data</li>\n</ol>\n<h3 id=\"callHook-vm-’created’\"><a href=\"#callHook-vm-’created’\" class=\"headerlink\" title=\"callHook(vm,’created’)\"></a>callHook(vm,’created’)</h3><p>调用options.created这个对象里的函数，表示这些函数在vue实例created之后调用</p>\n<p>以上几个函数代表的是，.init()初始化，依次调用lifecycle，events，render，state模块中的初始化函数<br>接下来的函数是在.init()末尾调用的vm.$mount()</p>\n<h3 id=\"vm-mount-vm-options-el\"><a href=\"#vm-mount-vm-options-el\" class=\"headerlink\" title=\"vm.$mount(vm.$options.el)\"></a>vm.$mount(vm.$options.el)</h3><p>具体相关代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$mount = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span></span></div><div class=\"line\">  el?: string | Element,</div><div class=\"line\">  hydrating?: boolean</div><div class=\"line\">): <span class=\"title\">Component</span> &#123;</div><div class=\"line\">  el = el &amp;&amp; query(el)</div><div class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</div><div class=\"line\">  <span class=\"comment\">//...省略一些代码</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!options.render) &#123;  <span class=\"comment\">//如果存在render方法，直接运行mount</span></div><div class=\"line\">    <span class=\"keyword\">let</span> template = options.template</div><div class=\"line\">    <span class=\"keyword\">if</span> (template) &#123; <span class=\"comment\">//如果有template，获取template</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> template === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (template.charAt(<span class=\"number\">0</span>) === <span class=\"string\">'#'</span>) &#123;</div><div class=\"line\">          template = idToTemplate(template)</div><div class=\"line\">          <span class=\"comment\">/* istanbul ignore if */</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; !template) &#123;</div><div class=\"line\">            warn(</div><div class=\"line\">              <span class=\"string\">`Template element not found or is empty: <span class=\"subst\">$&#123;options.template&#125;</span>`</span>,</div><div class=\"line\">              <span class=\"keyword\">this</span></div><div class=\"line\">            )</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (template.nodeType) &#123;</div><div class=\"line\">        template = template.innerHTML</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">          warn(<span class=\"string\">'invalid template option:'</span> + template, <span class=\"keyword\">this</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el) &#123;</div><div class=\"line\">      template = getOuterHTML(el)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (template) &#123; <span class=\"comment\">//如果获取到了模板，则将模板转化为render方法</span></div><div class=\"line\">      <span class=\"comment\">//....省略一些代码</span></div><div class=\"line\">      <span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class=\"line\">        shouldDecodeNewlines,</div><div class=\"line\">        <span class=\"attr\">delimiters</span>: options.delimiters</div><div class=\"line\">      &#125;, <span class=\"keyword\">this</span>)</div><div class=\"line\">      options.render = render</div><div class=\"line\">      options.staticRenderFns = staticRenderFns</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> mount.call(<span class=\"keyword\">this</span>, el, hydrating)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个函数做了什么呢？<br>根据el，template，以及render去生成Vue的AST render方法<br>解释一下:vue.prototype.$mount这个方法在 web-runtime.js和web-runtime-with-compiler.js均有定义,执行顺序是：先const mount = web-runtiome.js中的vue.prototype.$mount，然后在web-runtime-with-compiler.js中重写vue.prototype.$mount,最后在重写的vue.prototype.$mount末尾处调用mount方法.接着继续调用mountComponent()这个方法.这个方法定义在lifecycle.js中。</p>\n<h3 id=\"mountComponent\"><a href=\"#mountComponent\" class=\"headerlink\" title=\"mountComponent\"></a>mountComponent</h3><p>主要代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">updateComponent = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      vm._update(vm._render(), hydrating)</div><div class=\"line\">&#125;</div><div class=\"line\">vm._watcher = <span class=\"keyword\">new</span> Watcher(vm, updateComponent, noop)</div></pre></td></tr></table></figure></p>\n<p>这段代码传入render方法生成的vNode对象，生成一个watcher.<br>接下来看生成watcher的过程</p>\n<h3 id=\"wathcer\"><a href=\"#wathcer\" class=\"headerlink\" title=\"wathcer\"></a>wathcer</h3><p>Wathcer构造函数定义在../observer/watcher.js中<br>主要逻辑代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.vm = vm</div><div class=\"line\">    vm._watchers.push(<span class=\"keyword\">this</span>)</div><div class=\"line\">    <span class=\"comment\">//...省略的部分</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.lazy</div><div class=\"line\">      ? <span class=\"literal\">undefined</span></div><div class=\"line\">      : <span class=\"keyword\">this</span>.get()</div><div class=\"line\">  &#125;</div><div class=\"line\">  get () &#123;</div><div class=\"line\">    pushTarget(<span class=\"keyword\">this</span>)</div><div class=\"line\">  \t<span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.getter.call(vm, vm)</div><div class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span>.vm</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deep) &#123;</div><div class=\"line\">      traverse(value)</div><div class=\"line\">    &#125;</div><div class=\"line\">    popTarget()</div><div class=\"line\">    <span class=\"keyword\">this</span>.cleanupDeps()</div><div class=\"line\">    <span class=\"keyword\">return</span> value</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>中间的一大部分初始化操作可以省略不看，重点在于最后一句this.value ，this.lazy初始为false，则调用了this.get().<br>看看get()发生了什么？主要是调用了this.getter，在上面省略的代码中可知this.getter就是在上文中传入的第二个参数即 updateCompount这个函数，内部是两个函数的调用，先调用vm._render(),这个函数的返回值即vNode作为参数传入 vm._update()，来更新vDom。<br>接下来在看一看vm._render()和vm._update()<br>代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.prototype._update = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> vm: Component = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (vm._isMounted) &#123;</div><div class=\"line\">      callHook(vm, <span class=\"string\">'beforeUpdate'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> prevEl = vm.$el</div><div class=\"line\">    <span class=\"keyword\">const</span> prevVnode = vm._vnode</div><div class=\"line\">    <span class=\"keyword\">const</span> prevActiveInstance = activeInstance</div><div class=\"line\">    activeInstance = vm</div><div class=\"line\">    vm._vnode = vnode</div><div class=\"line\">    <span class=\"keyword\">if</span> (!prevVnode) &#123; <span class=\"comment\">//初次加载</span></div><div class=\"line\">      vm.$el = vm.__patch__(</div><div class=\"line\">        vm.$el, vnode, hydrating, <span class=\"literal\">false</span> <span class=\"comment\">/* removeOnly */</span>,</div><div class=\"line\">        vm.$options._parentElm,</div><div class=\"line\">        vm.$options._refElm</div><div class=\"line\">      )</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 更新vnode</span></div><div class=\"line\">      vm.$el = vm.__patch__(prevVnode, vnode)</div><div class=\"line\">    &#125;</div><div class=\"line\">    activeInstance = prevActiveInstance</div><div class=\"line\">    <span class=\"comment\">//...后续省略.</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>vm._render()这个函数之后再进行赘述，这里只需要知道这个函数返回值是vNode就可以了。<br>vm._update()这个函数的主要逻辑就是执行了vm.patch(prevVnode,vnode),对Virtual DOM 进行更新。<br><strong><em>综合以上三步</em></strong></p>\n<ol>\n<li>初始化之后调用vm.$mount(),生成AST render方法</li>\n<li>调用mount()，即调用mountComponent()这个函数，生成watcher</li>\n<li>生成watcher的过程中，调用了this.get(),这个函数内部通过调用this.getter()即传递进来的第二个参数updateComponent()来调用vm._render()生成vnode节点，调用vm._update更新vDom。</li>\n</ol>\n<h2 id=\"如何实现数据绑定的\"><a href=\"#如何实现数据绑定的\" class=\"headerlink\" title=\"如何实现数据绑定的?\"></a>如何实现数据绑定的?</h2><p>vue的数据绑定重中之重就是把数据(Model)和视图(view)建立起关系<br>回顾一下watcher构造函数中，调用了get(),这个函数中调用了pushTarget()和popTarget()<br>代码位于 src/core/observer/dep.js<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushTarget</span> (<span class=\"params\">_target: Watcher</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (Dep.target) targetStack.push(Dep.target)</div><div class=\"line\">  Dep.target = _target</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popTarget</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  Dep.target = targetStack.pop()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这两个函数用于处理Dep.target,分别是数组的push()和pop()，<br>Dep.target调用方式为 Dep.target.addDep(this) 调用的时候会涉及到依赖收集，从而建立数据绑定的关系。<br>这里我们得知，在使用数据进行渲染的过程中，会对数据属性进行“读”操作，从而触发dep.depend(),进而收集到这个依赖关系。</p>\n<p>我们需要找到这个dep.depend()调用所在处，在observer/index.js中，defineReactive()<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\"></span></span></div><div class=\"line\">  obj: Object,</div><div class=\"line\">  key: string,</div><div class=\"line\">  val: any,</div><div class=\"line\">  customSetter?: Function</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep()</div><div class=\"line\">  <span class=\"keyword\">const</span> getter = property &amp;&amp; property.get</div><div class=\"line\">  <span class=\"keyword\">const</span> setter = property &amp;&amp; property.set</div><div class=\"line\">  <span class=\"keyword\">let</span> childOb = observe(val)</div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveGetter</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...省略</span></div><div class=\"line\">        dep.depend()</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveSetter</span> (<span class=\"params\">newVal</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...省略</span></div><div class=\"line\">      dep.notify()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当数据的属性的get()被调用时，会通过dep.depend()收集依赖关系,记录到vm中<br>在数据的属性的set()被调用时，会通过dep.notify()来通知vm，从而触发vm的更新操作。<br>回头来看state.js,是在initProps()中调用了defineReactive().而initProps()是在initState()中调用，而initState()是在this._init()中被调用</p>\n<p>总结如下：</p>\n<ol>\n<li>初始化：new Vue()-&gt;vm._init()</li>\n<li>数据劫持: initState(vm)-&gt;initProps(),initData()-&gt;dep.depend()</li>\n<li>依赖收集: vm.$mount()-&gt;vm._mount()-&gt;new Watcher()-&gt;vm._render()-&gt;vm._update()</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>想要真正的掌握一个框架就应该了解它的源码，知道整个框架是如何工作的.Vue是一个轻量化但非常好用的前端框架.它是以数据驱动为核心的javascript框架.Vue2.0更是重写之前的vue代码。本次要看的vue版本是2.03,线上包只有12Kb，性能也是非常不错的.<br>接下来从生命周期的各个过程去分析vue源码.","more":"</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>我们首先需要对Vue的生命周期有一个完整的理解，在下面放两张图。<br><img src=\"http://of8m1pnnt.bkt.clouddn.com/3504099265-580628fd03258_articlex.png\" alt=\"\"><br><img src=\"http://of8m1pnnt.bkt.clouddn.com/3346068135-580822cd52898_articlex.png\" alt=\"\"><br>从这个生命周期图我们可以得知vue的声明周期主要是4个过程：</p>\n<ul>\n<li>create</li>\n<li>mount</li>\n<li>update</li>\n<li>destroy</li>\n</ul>\n<h3 id=\"Create\"><a href=\"#Create\" class=\"headerlink\" title=\"Create\"></a>Create</h3><p>new Vue()的时候发生了哪些事情呢？先从 vue/src/core/instance/index.js看起。<br>index.js<br>主要代码片段如下: 解析写在注释里<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vue</span> (<span class=\"params\">options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</div><div class=\"line\">    !(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Vue)) &#123;</div><div class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class=\"line\">  &#125;  <span class=\"comment\">// 这个if判断是用来说明 Vue这个函数是个构造函数只能够通过 new的方式调用</span></div><div class=\"line\">  <span class=\"keyword\">this</span>._init(options) <span class=\"comment\">// 用来初始化vue的函数(这个函数是在vue.prototype上的)</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//以下是对Vue这个构造函数的初始化</span></div><div class=\"line\">initMixin(Vue) </div><div class=\"line\">stateMixin(Vue)</div><div class=\"line\">eventsMixin(Vue)</div><div class=\"line\">lifecycleMixin(Vue)</div><div class=\"line\">renderMixin(Vue)</div><div class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </div><div class=\"line\">接下来是对每个函数的解析</div><div class=\"line\"></div><div class=\"line\">### this._init(vm)</div><div class=\"line\"></div><div class=\"line\">文件为 vue/src/core/instance/init.js</div><div class=\"line\">主要代码片段为</div><div class=\"line\">`</span><span class=\"string\">``</span>javascript</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initMixin</span> (<span class=\"params\">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//初始化vue的函数 也就是上文中调用的this._init函数</span></div><div class=\"line\">  Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options?: Object</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> vm: Component = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"comment\">//...中间一部分省略掉</span></div><div class=\"line\">    vm._self = vm</div><div class=\"line\">    initLifecycle(vm)</div><div class=\"line\">    initEvents(vm)</div><div class=\"line\">    initRender(vm)</div><div class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</div><div class=\"line\">    initInjections(vm) <span class=\"comment\">// resolve injections before data/props</span></div><div class=\"line\">    initState(vm)</div><div class=\"line\">    initProvide(vm) <span class=\"comment\">// resolve provide after data/props</span></div><div class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</div><div class=\"line\">      vm.$mount(vm.$options.el)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这个_init函数中主要做了什么事情呢？没错，就是主要执行以下这些函数：</p>\n<ul>\n<li>initLifecycle(vm)</li>\n<li>initEvents(vm)</li>\n<li>initRender(vm)</li>\n<li>callHook(vm,”..”)</li>\n<li>initInjections(vm)</li>\n<li>initState(vm)</li>\n<li>initProvide(vm)</li>\n<li>vm.$mount(vm.$options.el)</li>\n</ul>\n<h3 id=\"initLifecycle-vm\"><a href=\"#initLifecycle-vm\" class=\"headerlink\" title=\"initLifecycle(vm)\"></a>initLifecycle(vm)</h3><p>文件路径 vue/src/core/instance/state.js<br>主要代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initLifecycle</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> options = vm.$options</div><div class=\"line\">  <span class=\"keyword\">let</span> parent = options.parent</div><div class=\"line\">  <span class=\"keyword\">if</span> (parent &amp;&amp; !options.abstract) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</div><div class=\"line\">      parent = parent.$parent</div><div class=\"line\">    &#125;</div><div class=\"line\">    parent.$children.push(vm)</div><div class=\"line\">  &#125;</div><div class=\"line\">  vm.$parent = parent</div><div class=\"line\">  vm.$root = parent ? parent.$root : vm</div><div class=\"line\">  vm.$children = []</div><div class=\"line\">  vm.$refs = &#123;&#125;</div><div class=\"line\">  vm._watcher = <span class=\"literal\">null</span></div><div class=\"line\">  vm._inactive = <span class=\"literal\">null</span></div><div class=\"line\">  vm._directInactive = <span class=\"literal\">false</span></div><div class=\"line\">  vm._isMounted = <span class=\"literal\">false</span></div><div class=\"line\">  vm._isDestroyed = <span class=\"literal\">false</span></div><div class=\"line\">  vm._isBeingDestroyed = <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initEvents-Vm\"><a href=\"#initEvents-Vm\" class=\"headerlink\" title=\"initEvents(Vm)\"></a>initEvents(Vm)</h3><p>文件路径 vue/src/core/instance/event.js<br>主要代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initEvents</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  vm._events = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</div><div class=\"line\">  vm._hasHookEvent = <span class=\"literal\">false</span></div><div class=\"line\">  <span class=\"comment\">// init parent attached events</span></div><div class=\"line\">  <span class=\"keyword\">const</span> listeners = vm.$options._parentListeners</div><div class=\"line\">  <span class=\"keyword\">if</span> (listeners) &#123;</div><div class=\"line\">    updateComponentListeners(vm, listeners)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initRender-vm\"><a href=\"#initRender-vm\" class=\"headerlink\" title=\"initRender(vm)\"></a>initRender(vm)</h3><p>文件位于 vue/src/core/instance/render.js<br>主要代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initRender</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  vm.$vnode = <span class=\"literal\">null</span> <span class=\"comment\">// the placeholder node in parent tree</span></div><div class=\"line\">  vm._vnode = <span class=\"literal\">null</span> <span class=\"comment\">// the root of the child tree</span></div><div class=\"line\">  vm._staticTrees = <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">const</span> parentVnode = vm.$options._parentVnode</div><div class=\"line\">  <span class=\"keyword\">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</div><div class=\"line\">  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)</div><div class=\"line\">  vm.$scopedSlots = emptyObject</div><div class=\"line\">  vm._c = <span class=\"function\">(<span class=\"params\">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class=\"literal\">false</span>)</div><div class=\"line\">  vm.$createElement = <span class=\"function\">(<span class=\"params\">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class=\"literal\">true</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"callHook-vm-’beforeCreate’\"><a href=\"#callHook-vm-’beforeCreate’\" class=\"headerlink\" title=\"callHook(vm,’beforeCreate’)\"></a>callHook(vm,’beforeCreate’)</h3><p>首先callHook函数定义在 lifestyle.js中<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callHook</span> (<span class=\"params\">vm: Component, hook: string</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> handlers = vm.$options[hook]</div><div class=\"line\">  <span class=\"keyword\">if</span> (handlers) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = handlers.length; i &lt; j; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        handlers[i].call(vm)</div><div class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</div><div class=\"line\">        handleError(e, vm, <span class=\"string\">`<span class=\"subst\">$&#123;hook&#125;</span> hook`</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (vm._hasHookEvent) &#123;</div><div class=\"line\">    vm.$emit(<span class=\"string\">'hook:'</span> + hook)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initInjections-vm\"><a href=\"#initInjections-vm\" class=\"headerlink\" title=\"initInjections(vm)\"></a>initInjections(vm)</h3><p>文件代码位于 vue/src/core/instance/inject.js<br>主要代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initInjections</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> result = resolveInject(vm.$options.inject, vm)</div><div class=\"line\">  <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.keys(result).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"comment\">/* istanbul ignore else */</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">        defineReactive(vm, key, result[key], () =&gt; &#123;</div><div class=\"line\">          warn(</div><div class=\"line\">            <span class=\"string\">`Avoid mutating an injected value directly since the changes will be `</span> +</div><div class=\"line\">            <span class=\"string\">`overwritten whenever the provided component re-renders. `</span> +</div><div class=\"line\">            <span class=\"string\">`injection being mutated: \"<span class=\"subst\">$&#123;key&#125;</span>\"`</span>,</div><div class=\"line\">            vm</div><div class=\"line\">          )</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        defineReactive(vm, key, result[key])</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"initState-vm\"><a href=\"#initState-vm\" class=\"headerlink\" title=\"initState(vm)\"></a>initState(vm)</h3><p>文件位于 vue/src/core/state.js<br>代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initState</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</div><div class=\"line\">  vm._watchers = []</div><div class=\"line\">  <span class=\"keyword\">const</span> opts = vm.$options</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.props) initProps(vm, opts.props)</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.methods) initMethods(vm, opts.methods)</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.data) &#123;</div><div class=\"line\">    initData(vm)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    observe(vm._data = &#123;&#125;, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.computed) initComputed(vm, opts.computed)</div><div class=\"line\">  <span class=\"keyword\">if</span> (opts.watch) initWatch(vm, opts.watch)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>initState(vm)做了什么呢？</p>\n<ol>\n<li>初始化vm._watchers这个数组</li>\n<li>initProps 初始化options.props</li>\n<li>initMethods 初始化options.methods</li>\n<li>initData 初始化options.data</li>\n</ol>\n<h3 id=\"callHook-vm-’created’\"><a href=\"#callHook-vm-’created’\" class=\"headerlink\" title=\"callHook(vm,’created’)\"></a>callHook(vm,’created’)</h3><p>调用options.created这个对象里的函数，表示这些函数在vue实例created之后调用</p>\n<p>以上几个函数代表的是，.init()初始化，依次调用lifecycle，events，render，state模块中的初始化函数<br>接下来的函数是在.init()末尾调用的vm.$mount()</p>\n<h3 id=\"vm-mount-vm-options-el\"><a href=\"#vm-mount-vm-options-el\" class=\"headerlink\" title=\"vm.$mount(vm.$options.el)\"></a>vm.$mount(vm.$options.el)</h3><p>具体相关代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$mount = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></div><div class=\"line\">  el?: string | Element,</div><div class=\"line\">  hydrating?: boolean</div><div class=\"line\"></span>): <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  el = el &amp;&amp; query(el)</div><div class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</div><div class=\"line\">  <span class=\"comment\">//...省略一些代码</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (!options.render) &#123;  <span class=\"comment\">//如果存在render方法，直接运行mount</span></div><div class=\"line\">    <span class=\"keyword\">let</span> template = options.template</div><div class=\"line\">    <span class=\"keyword\">if</span> (template) &#123; <span class=\"comment\">//如果有template，获取template</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> template === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (template.charAt(<span class=\"number\">0</span>) === <span class=\"string\">'#'</span>) &#123;</div><div class=\"line\">          template = idToTemplate(template)</div><div class=\"line\">          <span class=\"comment\">/* istanbul ignore if */</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; !template) &#123;</div><div class=\"line\">            warn(</div><div class=\"line\">              <span class=\"string\">`Template element not found or is empty: <span class=\"subst\">$&#123;options.template&#125;</span>`</span>,</div><div class=\"line\">              <span class=\"keyword\">this</span></div><div class=\"line\">            )</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (template.nodeType) &#123;</div><div class=\"line\">        template = template.innerHTML</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">          warn(<span class=\"string\">'invalid template option:'</span> + template, <span class=\"keyword\">this</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el) &#123;</div><div class=\"line\">      template = getOuterHTML(el)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (template) &#123; <span class=\"comment\">//如果获取到了模板，则将模板转化为render方法</span></div><div class=\"line\">      <span class=\"comment\">//....省略一些代码</span></div><div class=\"line\">      <span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class=\"line\">        shouldDecodeNewlines,</div><div class=\"line\">        <span class=\"attr\">delimiters</span>: options.delimiters</div><div class=\"line\">      &#125;, <span class=\"keyword\">this</span>)</div><div class=\"line\">      options.render = render</div><div class=\"line\">      options.staticRenderFns = staticRenderFns</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> mount.call(<span class=\"keyword\">this</span>, el, hydrating)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个函数做了什么呢？<br>根据el，template，以及render去生成Vue的AST render方法<br>解释一下:vue.prototype.$mount这个方法在 web-runtime.js和web-runtime-with-compiler.js均有定义,执行顺序是：先const mount = web-runtiome.js中的vue.prototype.$mount，然后在web-runtime-with-compiler.js中重写vue.prototype.$mount,最后在重写的vue.prototype.$mount末尾处调用mount方法.接着继续调用mountComponent()这个方法.这个方法定义在lifecycle.js中。</p>\n<h3 id=\"mountComponent\"><a href=\"#mountComponent\" class=\"headerlink\" title=\"mountComponent\"></a>mountComponent</h3><p>主要代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">updateComponent = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      vm._update(vm._render(), hydrating)</div><div class=\"line\">&#125;</div><div class=\"line\">vm._watcher = <span class=\"keyword\">new</span> Watcher(vm, updateComponent, noop)</div></pre></td></tr></table></figure></p>\n<p>这段代码传入render方法生成的vNode对象，生成一个watcher.<br>接下来看生成watcher的过程</p>\n<h3 id=\"wathcer\"><a href=\"#wathcer\" class=\"headerlink\" title=\"wathcer\"></a>wathcer</h3><p>Wathcer构造函数定义在../observer/watcher.js中<br>主要逻辑代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.vm = vm</div><div class=\"line\">    vm._watchers.push(<span class=\"keyword\">this</span>)</div><div class=\"line\">    <span class=\"comment\">//...省略的部分</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.lazy</div><div class=\"line\">      ? <span class=\"literal\">undefined</span></div><div class=\"line\">      : <span class=\"keyword\">this</span>.get()</div><div class=\"line\">  &#125;</div><div class=\"line\">  get () &#123;</div><div class=\"line\">    pushTarget(<span class=\"keyword\">this</span>)</div><div class=\"line\">  \t<span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.getter.call(vm, vm)</div><div class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span>.vm</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deep) &#123;</div><div class=\"line\">      traverse(value)</div><div class=\"line\">    &#125;</div><div class=\"line\">    popTarget()</div><div class=\"line\">    <span class=\"keyword\">this</span>.cleanupDeps()</div><div class=\"line\">    <span class=\"keyword\">return</span> value</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>中间的一大部分初始化操作可以省略不看，重点在于最后一句this.value ，this.lazy初始为false，则调用了this.get().<br>看看get()发生了什么？主要是调用了this.getter，在上面省略的代码中可知this.getter就是在上文中传入的第二个参数即 updateCompount这个函数，内部是两个函数的调用，先调用vm._render(),这个函数的返回值即vNode作为参数传入 vm._update()，来更新vDom。<br>接下来在看一看vm._render()和vm._update()<br>代码如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.prototype._update = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> vm: Component = <span class=\"keyword\">this</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (vm._isMounted) &#123;</div><div class=\"line\">      callHook(vm, <span class=\"string\">'beforeUpdate'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> prevEl = vm.$el</div><div class=\"line\">    <span class=\"keyword\">const</span> prevVnode = vm._vnode</div><div class=\"line\">    <span class=\"keyword\">const</span> prevActiveInstance = activeInstance</div><div class=\"line\">    activeInstance = vm</div><div class=\"line\">    vm._vnode = vnode</div><div class=\"line\">    <span class=\"keyword\">if</span> (!prevVnode) &#123; <span class=\"comment\">//初次加载</span></div><div class=\"line\">      vm.$el = vm.__patch__(</div><div class=\"line\">        vm.$el, vnode, hydrating, <span class=\"literal\">false</span> <span class=\"comment\">/* removeOnly */</span>,</div><div class=\"line\">        vm.$options._parentElm,</div><div class=\"line\">        vm.$options._refElm</div><div class=\"line\">      )</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 更新vnode</span></div><div class=\"line\">      vm.$el = vm.__patch__(prevVnode, vnode)</div><div class=\"line\">    &#125;</div><div class=\"line\">    activeInstance = prevActiveInstance</div><div class=\"line\">    <span class=\"comment\">//...后续省略.</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>vm._render()这个函数之后再进行赘述，这里只需要知道这个函数返回值是vNode就可以了。<br>vm._update()这个函数的主要逻辑就是执行了vm.patch(prevVnode,vnode),对Virtual DOM 进行更新。<br><strong><em>综合以上三步</em></strong></p>\n<ol>\n<li>初始化之后调用vm.$mount(),生成AST render方法</li>\n<li>调用mount()，即调用mountComponent()这个函数，生成watcher</li>\n<li>生成watcher的过程中，调用了this.get(),这个函数内部通过调用this.getter()即传递进来的第二个参数updateComponent()来调用vm._render()生成vnode节点，调用vm._update更新vDom。</li>\n</ol>\n<h2 id=\"如何实现数据绑定的\"><a href=\"#如何实现数据绑定的\" class=\"headerlink\" title=\"如何实现数据绑定的?\"></a>如何实现数据绑定的?</h2><p>vue的数据绑定重中之重就是把数据(Model)和视图(view)建立起关系<br>回顾一下watcher构造函数中，调用了get(),这个函数中调用了pushTarget()和popTarget()<br>代码位于 src/core/observer/dep.js<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushTarget</span> (<span class=\"params\">_target: Watcher</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (Dep.target) targetStack.push(Dep.target)</div><div class=\"line\">  Dep.target = _target</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popTarget</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  Dep.target = targetStack.pop()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这两个函数用于处理Dep.target,分别是数组的push()和pop()，<br>Dep.target调用方式为 Dep.target.addDep(this) 调用的时候会涉及到依赖收集，从而建立数据绑定的关系。<br>这里我们得知，在使用数据进行渲染的过程中，会对数据属性进行“读”操作，从而触发dep.depend(),进而收集到这个依赖关系。</p>\n<p>我们需要找到这个dep.depend()调用所在处，在observer/index.js中，defineReactive()<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\"></div><div class=\"line\">  obj: Object,</div><div class=\"line\">  key: string,</div><div class=\"line\">  val: any,</div><div class=\"line\">  customSetter?: Function</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep()</div><div class=\"line\">  <span class=\"keyword\">const</span> getter = property &amp;&amp; property.get</div><div class=\"line\">  <span class=\"keyword\">const</span> setter = property &amp;&amp; property.set</div><div class=\"line\">  <span class=\"keyword\">let</span> childOb = observe(val)</div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveGetter</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...省略</span></div><div class=\"line\">        dep.depend()</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveSetter</span> (<span class=\"params\">newVal</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...省略</span></div><div class=\"line\">      dep.notify()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当数据的属性的get()被调用时，会通过dep.depend()收集依赖关系,记录到vm中<br>在数据的属性的set()被调用时，会通过dep.notify()来通知vm，从而触发vm的更新操作。<br>回头来看state.js,是在initProps()中调用了defineReactive().而initProps()是在initState()中调用，而initState()是在this._init()中被调用</p>\n<p>总结如下：</p>\n<ol>\n<li>初始化：new Vue()-&gt;vm._init()</li>\n<li>数据劫持: initState(vm)-&gt;initProps(),initData()-&gt;dep.depend()</li>\n<li>依赖收集: vm.$mount()-&gt;vm._mount()-&gt;new Watcher()-&gt;vm._render()-&gt;vm._update()</li>\n</ol>"},{"title":"webpack入门","date":"2016-10-22T10:07:07.000Z","_content":"### Webpack\nWebpack 是模块加载器以及打包工具，能把各种资源作为模块来使用和处理\n工作方式为:把项目当做一个整体，通过一个给定的主文件，Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包成一个浏览器可识别的JavaScript文件。<!--more-->\n### 使用webpack\n* 安装\n```javascript\n//全局安装\nnpm install -g webpack\n//安装到项目目录 文件夹中应有package.json (npm init)\nnpm install --save-dev webpack  //写入到package.json中的devdependencies\n```\n* 使用\n在项目目录里 创建两个文件夹分别为src 和 dest\n```javascript\t\nmkdir src dest \ncd src\nvim main.js \ncd dest\nvim index.html\ncd ..\nvim webpack.config.js //webpack配置文件\n//main.js\nvar $=require('jquery')\n$('body').html(\"yeah!\")\n//index.html\n<!DOCTYPE html>\n<html>\n<body>\n</script src=\"bundle.js\"> //顺带一提 script放在此处的原因是 浏览器遇到body呈现内容，此时html 以及css 已经加载完毕\n</body>\n</html>\n//webpack.config.js\nmodule.exports={\n    entry:__dirname+\"/src/main.js\", //webpack入口文件\n    output:{\n        path:__dirname+\"/dest\", \n        filename:\"bundle.js\" //输出文件\n    }\n}\n//执行代码\n1.webpack\n2.打开index.html\n```\n* Loaders\n通过使用不同的loader，webpack调用外部的脚本或工具对各种各样的文件进行处理并把它转换为浏览器可以识别的js文件。\n1. Loaders的配置 在modules关键字下配置\n2. -test:loaders处理的文件的拓展名的正则表达式\n3. -loader:loader的名称\n4. -include/exclude:手动添加必须处理的文件或屏蔽不需要处理的文件\n5. -query:为loaders提供额外的设置选项\n```javascript\n//webpack.config.js\nmodule.exports={\n    entry:__dirname+\"/src/main.js\", //webpack入口文件\n    output:{\n        path:__dirname+\"/dest\", \n        filename:\"bundle.js\" //输出文件\n    },\n    module:{\n        loaders:[\n            {test:/\\.json$/,loader:\"json\"} \n        ]\n    }\n}\n```\n### webpack dev server\nWEBPACK DEV SERVER 是一个轻量的EXPRESS服务器，使用WEBPACK-DEV-MIDDLEWARE服务WEBPACK BUNDLE\n```javascript\nvar path = require('path')\nmodule.exports={\n    entry:[\n       webpack-dev-server/client?http://localhost:8080 /\n    ],\n    hot:true,\n    plugins:[\n        new webpack.HotModuleReplacementPlugin()\n    ]\n}\n```\n","source":"_posts/webpack.md","raw":"---\ntitle: webpack入门\ndate: 2016-10-22 03:07:07\ntags: [webpack]\n---\n### Webpack\nWebpack 是模块加载器以及打包工具，能把各种资源作为模块来使用和处理\n工作方式为:把项目当做一个整体，通过一个给定的主文件，Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包成一个浏览器可识别的JavaScript文件。<!--more-->\n### 使用webpack\n* 安装\n```javascript\n//全局安装\nnpm install -g webpack\n//安装到项目目录 文件夹中应有package.json (npm init)\nnpm install --save-dev webpack  //写入到package.json中的devdependencies\n```\n* 使用\n在项目目录里 创建两个文件夹分别为src 和 dest\n```javascript\t\nmkdir src dest \ncd src\nvim main.js \ncd dest\nvim index.html\ncd ..\nvim webpack.config.js //webpack配置文件\n//main.js\nvar $=require('jquery')\n$('body').html(\"yeah!\")\n//index.html\n<!DOCTYPE html>\n<html>\n<body>\n</script src=\"bundle.js\"> //顺带一提 script放在此处的原因是 浏览器遇到body呈现内容，此时html 以及css 已经加载完毕\n</body>\n</html>\n//webpack.config.js\nmodule.exports={\n    entry:__dirname+\"/src/main.js\", //webpack入口文件\n    output:{\n        path:__dirname+\"/dest\", \n        filename:\"bundle.js\" //输出文件\n    }\n}\n//执行代码\n1.webpack\n2.打开index.html\n```\n* Loaders\n通过使用不同的loader，webpack调用外部的脚本或工具对各种各样的文件进行处理并把它转换为浏览器可以识别的js文件。\n1. Loaders的配置 在modules关键字下配置\n2. -test:loaders处理的文件的拓展名的正则表达式\n3. -loader:loader的名称\n4. -include/exclude:手动添加必须处理的文件或屏蔽不需要处理的文件\n5. -query:为loaders提供额外的设置选项\n```javascript\n//webpack.config.js\nmodule.exports={\n    entry:__dirname+\"/src/main.js\", //webpack入口文件\n    output:{\n        path:__dirname+\"/dest\", \n        filename:\"bundle.js\" //输出文件\n    },\n    module:{\n        loaders:[\n            {test:/\\.json$/,loader:\"json\"} \n        ]\n    }\n}\n```\n### webpack dev server\nWEBPACK DEV SERVER 是一个轻量的EXPRESS服务器，使用WEBPACK-DEV-MIDDLEWARE服务WEBPACK BUNDLE\n```javascript\nvar path = require('path')\nmodule.exports={\n    entry:[\n       webpack-dev-server/client?http://localhost:8080 /\n    ],\n    hot:true,\n    plugins:[\n        new webpack.HotModuleReplacementPlugin()\n    ]\n}\n```\n","slug":"webpack","published":1,"updated":"2017-04-15T01:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1qyv4rl000qoejx8pc3euvj","content":"<h3 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h3><p>Webpack 是模块加载器以及打包工具，能把各种资源作为模块来使用和处理<br>工作方式为:把项目当做一个整体，通过一个给定的主文件，Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包成一个浏览器可识别的JavaScript文件。<a id=\"more\"></a></p>\n<h3 id=\"使用webpack\"><a href=\"#使用webpack\" class=\"headerlink\" title=\"使用webpack\"></a>使用webpack</h3><ul>\n<li><p>安装</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//全局安装</span></div><div class=\"line\">npm install -g webpack</div><div class=\"line\"><span class=\"comment\">//安装到项目目录 文件夹中应有package.json (npm init)</span></div><div class=\"line\">npm install --save-dev webpack  <span class=\"comment\">//写入到package.json中的devdependencies</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用<br>在项目目录里 创建两个文件夹分别为src 和 dest</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir src dest </div><div class=\"line\">cd src</div><div class=\"line\">vim main.js </div><div class=\"line\">cd dest</div><div class=\"line\">vim index.html</div><div class=\"line\">cd ..</div><div class=\"line\">vim webpack.config.js <span class=\"comment\">//webpack配置文件</span></div><div class=\"line\"><span class=\"comment\">//main.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> $=<span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>)</div><div class=\"line\">$(<span class=\"string\">'body'</span>).html(<span class=\"string\">\"yeah!\"</span>)</div><div class=\"line\"><span class=\"comment\">//index.html</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;/script src=\"bundle.js\"&gt; //顺带一提 script放在此处的原因是 浏览器遇到body呈现内容，此时html 以及css 已经加载完毕</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\"><span class=\"comment\">//webpack.config.js</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:__dirname+<span class=\"string\">\"/src/main.js\"</span>, <span class=\"comment\">//webpack入口文件</span></div><div class=\"line\">    output:&#123;</div><div class=\"line\">        <span class=\"attr\">path</span>:__dirname+<span class=\"string\">\"/dest\"</span>, </div><div class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">\"bundle.js\"</span> <span class=\"comment\">//输出文件</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//执行代码</span></div><div class=\"line\"><span class=\"number\">1.</span>webpack</div><div class=\"line\"><span class=\"number\">2.</span>打开index.html</div></pre></td></tr></table></figure>\n</li>\n<li><p>Loaders<br>通过使用不同的loader，webpack调用外部的脚本或工具对各种各样的文件进行处理并把它转换为浏览器可以识别的js文件。</p>\n</li>\n</ul>\n<ol>\n<li>Loaders的配置 在modules关键字下配置</li>\n<li>-test:loaders处理的文件的拓展名的正则表达式</li>\n<li>-loader:loader的名称</li>\n<li>-include/exclude:手动添加必须处理的文件或屏蔽不需要处理的文件</li>\n<li>-query:为loaders提供额外的设置选项<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//webpack.config.js</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:__dirname+<span class=\"string\">\"/src/main.js\"</span>, <span class=\"comment\">//webpack入口文件</span></div><div class=\"line\">    output:&#123;</div><div class=\"line\">        <span class=\"attr\">path</span>:__dirname+<span class=\"string\">\"/dest\"</span>, </div><div class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">\"bundle.js\"</span> <span class=\"comment\">//输出文件</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">module</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">loaders</span>:[</div><div class=\"line\">            &#123;<span class=\"attr\">test</span>:<span class=\"regexp\">/\\.json$/</span>,<span class=\"attr\">loader</span>:<span class=\"string\">\"json\"</span>&#125; </div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack dev server\"></a>webpack dev server</h3><p>WEBPACK DEV SERVER 是一个轻量的EXPRESS服务器，使用WEBPACK-DEV-MIDDLEWARE服务WEBPACK BUNDLE<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:[</div><div class=\"line\">       webpack-dev-server/client?http:<span class=\"comment\">//localhost:8080 /</span></div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">hot</span>:<span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">plugins</span>:[</div><div class=\"line\">        <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h3><p>Webpack 是模块加载器以及打包工具，能把各种资源作为模块来使用和处理<br>工作方式为:把项目当做一个整体，通过一个给定的主文件，Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包成一个浏览器可识别的JavaScript文件。","more":"</p>\n<h3 id=\"使用webpack\"><a href=\"#使用webpack\" class=\"headerlink\" title=\"使用webpack\"></a>使用webpack</h3><ul>\n<li><p>安装</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//全局安装</span></div><div class=\"line\">npm install -g webpack</div><div class=\"line\"><span class=\"comment\">//安装到项目目录 文件夹中应有package.json (npm init)</span></div><div class=\"line\">npm install --save-dev webpack  <span class=\"comment\">//写入到package.json中的devdependencies</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>使用<br>在项目目录里 创建两个文件夹分别为src 和 dest</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir src dest </div><div class=\"line\">cd src</div><div class=\"line\">vim main.js </div><div class=\"line\">cd dest</div><div class=\"line\">vim index.html</div><div class=\"line\">cd ..</div><div class=\"line\">vim webpack.config.js <span class=\"comment\">//webpack配置文件</span></div><div class=\"line\"><span class=\"comment\">//main.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> $=<span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>)</div><div class=\"line\">$(<span class=\"string\">'body'</span>).html(<span class=\"string\">\"yeah!\"</span>)</div><div class=\"line\"><span class=\"comment\">//index.html</span></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;/script src=\"bundle.js\"&gt; //顺带一提 script放在此处的原因是 浏览器遇到body呈现内容，此时html 以及css 已经加载完毕</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\"><span class=\"comment\">//webpack.config.js</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:__dirname+<span class=\"string\">\"/src/main.js\"</span>, <span class=\"comment\">//webpack入口文件</span></div><div class=\"line\">    output:&#123;</div><div class=\"line\">        <span class=\"attr\">path</span>:__dirname+<span class=\"string\">\"/dest\"</span>, </div><div class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">\"bundle.js\"</span> <span class=\"comment\">//输出文件</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//执行代码</span></div><div class=\"line\"><span class=\"number\">1.</span>webpack</div><div class=\"line\"><span class=\"number\">2.</span>打开index.html</div></pre></td></tr></table></figure>\n</li>\n<li><p>Loaders<br>通过使用不同的loader，webpack调用外部的脚本或工具对各种各样的文件进行处理并把它转换为浏览器可以识别的js文件。</p>\n</li>\n</ul>\n<ol>\n<li>Loaders的配置 在modules关键字下配置</li>\n<li>-test:loaders处理的文件的拓展名的正则表达式</li>\n<li>-loader:loader的名称</li>\n<li>-include/exclude:手动添加必须处理的文件或屏蔽不需要处理的文件</li>\n<li>-query:为loaders提供额外的设置选项<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//webpack.config.js</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:__dirname+<span class=\"string\">\"/src/main.js\"</span>, <span class=\"comment\">//webpack入口文件</span></div><div class=\"line\">    output:&#123;</div><div class=\"line\">        <span class=\"attr\">path</span>:__dirname+<span class=\"string\">\"/dest\"</span>, </div><div class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">\"bundle.js\"</span> <span class=\"comment\">//输出文件</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">module</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">loaders</span>:[</div><div class=\"line\">            &#123;<span class=\"attr\">test</span>:<span class=\"regexp\">/\\.json$/</span>,<span class=\"attr\">loader</span>:<span class=\"string\">\"json\"</span>&#125; </div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack dev server\"></a>webpack dev server</h3><p>WEBPACK DEV SERVER 是一个轻量的EXPRESS服务器，使用WEBPACK-DEV-MIDDLEWARE服务WEBPACK BUNDLE<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:[</div><div class=\"line\">       webpack-dev-server/client?http:<span class=\"comment\">//localhost:8080 /</span></div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">hot</span>:<span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">plugins</span>:[</div><div class=\"line\">        <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj1qyv4q50000oejx2dwaizk2","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4qx0007oejx1pdlw6c2"},{"post_id":"cj1qyv4qs0005oejx9iquinfg","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4qz0009oejxynnu5aeq"},{"post_id":"cj1qyv4qx0008oejxlcql8spc","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4r5000coejxcvoriam4"},{"post_id":"cj1qyv4qe0001oejx0h7na2qf","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4r9000eoejxsrx3rx1e"},{"post_id":"cj1qyv4qi0003oejxyiectf7r","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4rb000hoejxxch2png5"},{"post_id":"cj1qyv4rb000ioejxhwnosfdw","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4rf000loejxk45migey"},{"post_id":"cj1qyv4qr0004oejxk8sm5nat","tag_id":"cj1qyv4ra000goejxnr8cm5jn","_id":"cj1qyv4ri000noejxvfxjwudm"},{"post_id":"cj1qyv4qz000aoejx7ttys0fy","tag_id":"cj1qyv4re000koejxrcot2rls","_id":"cj1qyv4rr000roejx2ie6p8gw"},{"post_id":"cj1qyv4ri000ooejxz5e95wko","tag_id":"cj1qyv4qg0002oejxf8olvjsf","_id":"cj1qyv4rs000soejxvjcr1vi4"},{"post_id":"cj1qyv4r9000foejxtf5fg8bw","tag_id":"cj1qyv4rk000poejxkbmgm8tx","_id":"cj1qyv4ru000uoejxm4v4edfy"},{"post_id":"cj1qyv4rd000joejxi31gwnzt","tag_id":"cj1qyv4rt000toejx0amcxh4u","_id":"cj1qyv4rv000woejxi39c8acx"},{"post_id":"cj1qyv4rf000moejxzq7b8r0z","tag_id":"cj1qyv4ru000voejxawtl3iir","_id":"cj1qyv4ry000yoejx86xjsxbs"},{"post_id":"cj1qyv4rl000qoejx8pc3euvj","tag_id":"cj1qyv4ry000xoejxkiyg7zty","_id":"cj1qyv4ry000zoejxwrfqd346"}],"Tag":[{"name":"javascript","_id":"cj1qyv4qg0002oejxf8olvjsf"},{"name":"canvas","_id":"cj1qyv4ra000goejxnr8cm5jn"},{"name":"nodejs","_id":"cj1qyv4re000koejxrcot2rls"},{"name":"https","_id":"cj1qyv4rk000poejxkbmgm8tx"},{"name":"regexp","_id":"cj1qyv4rt000toejx0amcxh4u"},{"name":"HTML","_id":"cj1qyv4ru000voejxawtl3iir"},{"name":"webpack","_id":"cj1qyv4ry000xoejxkiyg7zty"}]}}